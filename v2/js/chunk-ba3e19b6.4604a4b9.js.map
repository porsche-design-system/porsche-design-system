{"version":3,"sources":["webpack:////github/workspace/node_modules/@babel/runtime/helpers/esm/typeof.js","webpack:////github/workspace/node_modules/@babel/runtime/helpers/esm/toPrimitive.js","webpack:////github/workspace/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","webpack:////github/workspace/node_modules/@babel/runtime/helpers/esm/createClass.js","webpack:////github/workspace/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","webpack:////github/workspace/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","webpack:////github/workspace/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","webpack:////github/workspace/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","webpack:////github/workspace/node_modules/jss/dist/jss.esm.js","webpack:///../utilities/projects/utilities/dist/js/esm/mediaQuery.js","webpack:////github/workspace/node_modules/sort-css-media-queries/index.js","webpack:///../utilities/projects/utilities/dist/js/esm/font/font-line-height.js","webpack:///../utilities/projects/utilities/dist/js/esm/font/font-family.js","webpack:////github/workspace/node_modules/core-js/modules/es.array.reduce.js","webpack:///../utilities/projects/utilities/dist/js/esm/typography/text/textLarge.js","webpack:////github/workspace/node_modules/jss-plugin-sort-css-media-queries/dist/index.js","webpack:///../utilities/projects/utilities/dist/js/esm/typography/text/textMedium.js","webpack:///../components/src/components/headline/headline-utils.ts","webpack:///../components/src/utils/dom/getHTMLElement.ts","webpack:///../components/src/utils/dom/transformSelectorToDirectChildSelector.ts","webpack:///../components/src/utils/dom/getHTMLElements.ts","webpack:///../components/src/utils/dom/getDirectChildHTMLElements.ts","webpack:///../components/src/utils/dom/getSlotTextContent.ts","webpack:///../components/src/utils/dom/hasNamedSlot.ts","webpack:///../components/src/utils/dom/isParentOfKind.ts","webpack:///../components/src/utils/has-window.ts","webpack:///../components/src/utils/attribute-observer.ts","webpack:///../components/src/utils/breakpoint-customizable.ts","webpack:///../utilities/projects/utilities/dist/js/esm/breakpoint.js","webpack:///../components/src/utils/breakpoint-observer.ts","webpack:///../components/src/utils/breakpoint-observer-utils.ts","webpack:///../components/src/utils/children-observer.ts","webpack:////github/workspace/node_modules/throttle-debounce/esm/index.js","webpack:///../components/src/utils/form/form-utils.ts","webpack:///../utilities/projects/styles/dist/js/esm/index.js","webpack:////github/workspace/node_modules/hyphenate-style-name/index.js","webpack:////github/workspace/node_modules/jss-plugin-camel-case/dist/jss-plugin-camel-case.esm.js","webpack:////github/workspace/node_modules/jss-plugin-global/dist/jss-plugin-global.esm.js","webpack:////github/workspace/node_modules/jss-plugin-nested/dist/jss-plugin-nested.esm.js","webpack:///../components/src/utils/jss.ts","webpack:///../components/src/utils/paramCaseToCamelCase.ts","webpack:///../components/src/utils/has-document.ts","webpack:///../components/src/utils/scrolling.ts","webpack:////github/workspace/node_modules/@stencil/core/internal/app-data/index.js","webpack:///../components/src/utils/slotted-styles.ts","webpack:////github/workspace/node_modules/@stencil/core/internal/client/index.js","webpack:///../components/src/utils/tag-name.ts","webpack:///../components/src/utils/theme/getDataThemeDarkAttribute.ts","webpack:///../components/src/utils/theme/theme.ts","webpack:///../components/src/utils/theme/theme-extended-electric.ts","webpack:///../utilities/projects/utilities/dist/js/esm/typography/text/textXSmall.js","webpack:///../utilities/projects/utilities/dist/js/esm/typography/text/textSmall.js","webpack:///../utilities/projects/utilities/dist/js/esm/typography/text/textXLarge.js","webpack:///../components/src/utils/typography/textMap.ts","webpack:///../components/src/utils/validation/getOnlyChildOfKindHTMLElementOrThrow.ts","webpack:///../components/src/utils/validation/throwIfChildCountIsExceeded.ts","webpack:///../components/src/utils/validation/validateProps.ts","webpack:///../utilities/projects/utilities/dist/js/esm/font/font-style.js","webpack:////github/workspace/node_modules/@babel/runtime/helpers/esm/extends.js","webpack:///../utilities/projects/utilities/dist/js/esm/font/font-behavior.js","webpack:///../utilities/projects/utilities/dist/js/esm/font/font-variant.js","webpack:////github/workspace/node_modules/core-js/internals/array-method-is-strict.js","webpack:///../utilities/projects/utilities/dist/js/esm/font/font-weight.js","webpack:///../shared/dist/esm/lib/tagNames.js","webpack:////github/workspace/node_modules/core-js/internals/array-reduce.js","webpack:////github/workspace/node_modules/jss-plugin-sort-css-media-queries/dist/_virtual/_tslib.js","webpack:///../utilities/projects/utilities/dist/js/esm/font/font-hyphenation.js","webpack:////github/workspace/node_modules/tiny-warning/dist/tiny-warning.esm.js","webpack:///../components/src/utils/theme/isThemeDark.ts","webpack:///../components/src/styles/colors.ts","webpack:///../components/src/styles/hover-media-query.ts","webpack:///../components/src/styles/common-styles.ts","webpack:////github/workspace/node_modules/is-in-browser/dist/module.js","webpack:////github/workspace/node_modules/@stencil/core/internal/client lazy ^\\.\\/.*\\.entry\\.js.*$ include: \\.entry\\.js$ exclude: \\.system\\.entry\\.js$ namespace object","webpack:////github/workspace/node_modules/core-js/internals/engine-is-node.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","_toPrimitive","input","hint","prim","toPrimitive","undefined","res","call","TypeError","String","Number","_toPropertyKey","arg","key","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","toPropertyKey","_createClass","Constructor","protoProps","staticProps","_setPrototypeOf","o","p","setPrototypeOf","bind","__proto__","_inheritsLoose","subClass","superClass","create","_assertThisInitialized","self","ReferenceError","_objectWithoutPropertiesLoose","source","excluded","sourceKeys","keys","indexOf","plainObjectConstrurctor","cloneStyle","style","Array","isArray","map","newStyle","name","createRule","decl","options","jss","declCopy","rule","plugins","onCreateRule","join","value","by","result","toCssValue","cssValue","getWhitespaceSymbols","format","linebreak","space","indentStr","str","indent","index","toCss","selector","_options","_options$indent","fallbacks","Infinity","_getWhitespaceSymbols","fallback","prop","_prop","_value","_prop2","_value2","allowEmpty","escapeRegex","nativeEscape","CSS","escape","replace","BaseStyleRule","this","type","isProcessed","sheet","Renderer","renderer","_proto","force","newValue","process","onChangeValue","isEmpty","isDefined","remove","renderable","removeProperty","setProperty","attached","_BaseStyleRule","StyleRule","_this","scoped","generateId","selectorText","id","_proto2","applyTo","json","toJSON","toString","link","opts","set","hasChanged","setSelector","replaceRule","get","pluginStyleRule","parent","defaultToStringOptions","children","atRegExp","ConditionalRule","styles","atMatch","match","at","query","rules","add","getRule","addRule","onProcessRule","newRule","keyRegExp","pluginConditionalRule","test","defaultToStringOptions$1","nameRegExp","KeyframesRule","frames","nameMatch","keyRegExp$1","refRegExp","findReferencedKeyframe","val","keyframes","replaceRef","refKeyframe","pluginKeyframesRule","onProcessStyle","KeyframeRule","apply","arguments","pluginKeyframeRule","FontFaceRule","keyRegExp$2","pluginFontFaceRule","ViewportRule","pluginViewportRule","SimpleRule","keysMap","pluginSimpleRule","defaultUpdateOptions","forceUpdateOptions","RuleList","raw","counter","classes","ruleOptions","_this$options","register","splice","oldRule","oldIndex","nameOrSelector","unregister","slice","forEach","update","data","updateOne","_this$options2","onUpdate","nextValue","prevValue","_nextValue","_prevValue","css","StyleSheet","deployed","attach","deploy","detach","queue","push","insertRule","deleteRule","addRules","added","_this$rules","PluginsRegistry","internal","external","registry","onProcessSheet","processedValue","use","newPlugin","concat","reduce","plugin","SheetsRegistry","reset","_temp","_ref","sheets","globalThis$1","globalThis","window","Math","Function","ns","moduleId","createGenerateId","ruleCounter","jssId","prefix","classNamePrefix","minify","memoize","fn","getPropertyValue","cssRule","attributeStyleMap","err","indexOfImportantFlag","cssValueWithoutImportantFlag","substr","delete","getHead","document","querySelector","findHigherSheet","insertionPoint","findHighestSheet","findCommentNode","text","head","childNodes","node","nodeType","nodeValue","trim","findPrevNode","element","parentNode","nextSibling","comment","insertStyle","nextNode","insertBefore","insertionPointElement","appendChild","getNonce","getAttribute","_insertRule","container","appendRule","cssRules","getValidRuleInsertionIndex","maxIndex","createStyle","el","createElement","textContent","DomRenderer","hasInsertedRules","media","meta","setAttribute","nonce","Boolean","removeChild","insertRules","nativeParent","latestNativeParent","_insertionIndex","refCssRule","ruleStr","insertionIndex","nativeRule","getRules","instanceCounter","Jss","version","setup","createStyleSheet","removeStyleSheet","_len","_key","createJss","SheetsManager","WeakMap","entry","has","refs","manage","unmanage","hasCSSTOMSupport","getDynamicStyles","to","extracted","breakpoint","mediaQueryMin","min","minMaxWidth","minWidth","maxMinWidth","maxWidth","isMinWidth","_testQuery","isMaxWidth","minMaxHeight","minHeight","maxMinHeight","maxHeight","isMinHeight","isMaxHeight","isPrint","isPrintOnly","maxValue","MAX_VALUE","_getQueryLength","exec","number","unit","parseFloat","doubleTestTrue","doubleTestFalse","singleTest","_testIsPrint","a","b","isPrintA","isPrintOnlyA","isPrintB","isPrintOnlyB","localeCompare","sortCSSmq","testIsPrint","minA","maxA","minB","maxB","lengthA","lengthB","desktopFirst","module","exports","fontLineHeight","fontFamily","$","$reduce","left","arrayMethodIsStrict","CHROME_VERSION","IS_NODE","STRICT_METHOD","CHROME_BUG","proto","forced","callbackfn","textLarge","font","fontStyle","fontVariant","fontWeight","regular","fontBehavior","fontHyphenation","_tslib","_interopDefaultLegacy","e","default","sortCSSmq__default","isPlainObject","sample","UN_QUERIED","recursiveInnerAndGetQueries","pluginOptions","queries","groups","groupsSortNames","hasOwnProperty","recursive","sort","aWeight","bWeight","_a","groupName","group","combineMediaQueries","i_1","__assign","i_2","jssCombineAndSortMQ","textMedium","HEADLINE_VARIANTS","getHTMLElement","transformSelectorToDirectChildSelector","split","part","getHTMLElements","from","querySelectorAll","getDirectChildHTMLElements","sel","flat","hasNamedSlot","slotName","isParentOfKind","tagName","parentElement","getTagNameWithoutPrefix","hasWindow","attributeMutationMap","Map","BREAKPOINTS","MutationObserver","mutations","filter","mutation","oldValue","attributeName","idx","arr","findIndex","m","parseJSON","JSON","parse","xxs","xs","s","l","xl","xxl","mediaQueries","entries","matchMedia","childrenMutationMap","getObservedNode","mutatedNode","throttle","delay","callback","timeoutID","_ref$noTrailing","noTrailing","_ref$noLeading","noLeading","_ref$debounceMode","debounceMode","cancelled","lastExec","clearExistingTimeout","clearTimeout","cancel","_ref2","_ref2$upcomingOnly","upcomingOnly","wrapper","arguments_","elapsed","Date","now","clear","setTimeout","debounce","_ref$atBegin","atBegin","ariaElement","innerText","maxLength","PORSCHE_DESIGN_SYSTEM_CDN","uppercasePattern","msPattern","toHyphenLower","toLowerCase","hyphenateStyleName","hName","convertCase","converted","camelCase","hyphenatedProp","atPrefix","GlobalContainerRule","GlobalPrefixedRule","separatorRegExp","addScope","scope","parts","handleNestedGlobalContainerRule","handlePrefixedGlobalRule","jssGlobal","parentRegExp","jssNested","getReplaceRef","replaceParentRefs","nestedProp","parentProp","parentSelectors","nestedSelectors","j","nested","getOptions","prevOptions","nestingLevel","styleRule","isNested","isNestedConditional","jssPluginGlobal","jssPluginNested","jssPluginCamelCase","jssPluginSortMediaQueries","getCss","jssStyles","supportsConstructableStylesheets","CSSStyleSheet","replaceSync","buildSlottedStyles","host","jssStyle","getTagName","addImportantToEachRule","buildResponsiveStyles","rawValue","getJssStyle","breakpointValue","base","isObject","mergeDeep","objects","prev","pVal","oVal","paramCaseToCamelCase","_","toUpperCase","hasDocument","documentElement","getScrollByX","scrollAreaElement","round","offsetWidth","BUILD","allRenderFn","cmpDidLoad","cmpDidUnload","cmpDidUpdate","cmpDidRender","cmpWillLoad","cmpWillUpdate","cmpWillRender","connectedCallback","disconnectedCallback","event","hasRenderFn","lifecycle","hostListener","hostListenerTargetWindow","hostListenerTargetDocument","hostListenerTargetBody","hostListenerTargetParent","hostListenerTarget","member","method","mode","observeAttribute","propMutable","reflect","shadowDom","slot","cssAnnotations","state","svg","updatable","vdomAttribute","vdomXlink","vdomClass","vdomFunctional","vdomKey","vdomListener","vdomRef","vdomPropOrAttr","vdomRender","vdomStyle","vdomText","watchCallback","taskQueue","hotModuleReplacement","isDebug","isDev","isTesting","hydrateServerSide","hydrateClientSide","lifecycleDOMEvents","lazyLoad","profile","slotRelocation","appendChildSlotFix","cloneNodeFix","hydratedAttribute","hydratedClass","safari10","scriptDataOpts","scopedSlotTextContentFix","shadowDomShim","slotChildNodesFix","invisiblePrehydration","propBoolean","propNumber","propString","cssVarShim","constructableCSS","cmpShouldUpdate","devTools","dynamicImportShim","shadowDelegatesFocus","initializeNextTick","asyncLoading","asyncQueue","transformTagName","attachStyles","win","doc","HTMLElement","tagNameWithoutPrefix","tagNamesWithoutTextAndHeadline","TAG_NAMES","item","PREFIXED_TAG_NAMES_CACHE","getPrefixedTagNames","tagNames","tag","THEMES","THEMES_EXTENDED_ELECTRIC","textXSmall","textSmall","textXLarge","getOnlyChildOfKindHTMLElementOrThrow","directChildren","Error","formatObjectOutput","stringify","_extends","assign","textSizeAdjust","WebkitTextSizeAdjust","fails","METHOD_NAME","argument","thin","semiBold","bold","aCallable","toObject","IndexedObject","lengthOfArrayLike","$TypeError","createMethod","IS_RIGHT","that","argumentsLength","memo","O","right","t","n","overflowWrap","hyphens","isProduction","warning","condition","message","console","warn","x","isThemeDark","theme","themeLight","baseColor","baseColorDarken","brandColor","backgroundColor","backgroundSurfaceColor","contrastLowColor","contrastMediumColor","contrastHighColor","contrastHighColorDarken","hoverColor","hoverColorDarken","activeColor","focusColor","disabledColor","errorColor","errorColorDarken","errorSoftColor","successColor","successColorDarken","successSoftColor","warningColor","warningSoftColor","neutralColor","neutralSoftColor","themeDark","themeLightElectric","themeDarkElectric","themes","getThemedColors","hoverMediaQuery","ROLLUP_REPLACE_IS_STAGING","transitionDuration","transitionTimingFunction","getTransition","cssProperty","pxToRemWithUnit","px","addImportantToRule","getHoverJssStyle","transition","color","getInsetJssStyle","top","bottom","getFocusJssStyle","pseudo","offset","outlineOffset","outlineColor","outline","border","content","position","getBaseSlottedStyles","withDarkTheme","textDecoration","isBrowser","webpackEmptyAsyncContext","req","Promise","resolve","then","code","classof","global"],"mappings":"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","file":"js/chunk-ba3e19b6.4604a4b9.js","sourcesContent":["export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}","import _extends from '@babel/runtime/helpers/esm/extends';\nimport isInBrowser from 'is-in-browser';\nimport warning from 'tiny-warning';\nimport _createClass from '@babel/runtime/helpers/esm/createClass';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\nvar plainObjectConstrurctor = {}.constructor;\nfunction cloneStyle(style) {\n  if (style == null || typeof style !== 'object') return style;\n  if (Array.isArray(style)) return style.map(cloneStyle);\n  if (style.constructor !== plainObjectConstrurctor) return style;\n  var newStyle = {};\n\n  for (var name in style) {\n    newStyle[name] = cloneStyle(style[name]);\n  }\n\n  return newStyle;\n}\n\n/**\n * Create a rule instance.\n */\n\nfunction createRule(name, decl, options) {\n  if (name === void 0) {\n    name = 'unnamed';\n  }\n\n  var jss = options.jss;\n  var declCopy = cloneStyle(decl);\n  var rule = jss.plugins.onCreateRule(name, declCopy, options);\n  if (rule) return rule; // It is an at-rule and it has no instance.\n\n  if (name[0] === '@') {\n    process.env.NODE_ENV !== \"production\" ? warning(false, \"[JSS] Unknown rule \" + name) : void 0;\n  }\n\n  return null;\n}\n\nvar join = function join(value, by) {\n  var result = '';\n\n  for (var i = 0; i < value.length; i++) {\n    // Remove !important from the value, it will be readded later.\n    if (value[i] === '!important') break;\n    if (result) result += by;\n    result += value[i];\n  }\n\n  return result;\n};\n/**\n * Converts JSS array value to a CSS string.\n *\n * `margin: [['5px', '10px']]` > `margin: 5px 10px;`\n * `border: ['1px', '2px']` > `border: 1px, 2px;`\n * `margin: [['5px', '10px'], '!important']` > `margin: 5px 10px !important;`\n * `color: ['red', !important]` > `color: red !important;`\n */\n\n\nvar toCssValue = function toCssValue(value) {\n  if (!Array.isArray(value)) return value;\n  var cssValue = ''; // Support space separated values via `[['5px', '10px']]`.\n\n  if (Array.isArray(value[0])) {\n    for (var i = 0; i < value.length; i++) {\n      if (value[i] === '!important') break;\n      if (cssValue) cssValue += ', ';\n      cssValue += join(value[i], ' ');\n    }\n  } else cssValue = join(value, ', '); // Add !important, because it was ignored.\n\n\n  if (value[value.length - 1] === '!important') {\n    cssValue += ' !important';\n  }\n\n  return cssValue;\n};\n\nfunction getWhitespaceSymbols(options) {\n  if (options && options.format === false) {\n    return {\n      linebreak: '',\n      space: ''\n    };\n  }\n\n  return {\n    linebreak: '\\n',\n    space: ' '\n  };\n}\n\n/**\n * Indent a string.\n * http://jsperf.com/array-join-vs-for\n */\n\nfunction indentStr(str, indent) {\n  var result = '';\n\n  for (var index = 0; index < indent; index++) {\n    result += '  ';\n  }\n\n  return result + str;\n}\n/**\n * Converts a Rule to CSS string.\n */\n\n\nfunction toCss(selector, style, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var result = '';\n  if (!style) return result;\n  var _options = options,\n      _options$indent = _options.indent,\n      indent = _options$indent === void 0 ? 0 : _options$indent;\n  var fallbacks = style.fallbacks;\n\n  if (options.format === false) {\n    indent = -Infinity;\n  }\n\n  var _getWhitespaceSymbols = getWhitespaceSymbols(options),\n      linebreak = _getWhitespaceSymbols.linebreak,\n      space = _getWhitespaceSymbols.space;\n\n  if (selector) indent++; // Apply fallbacks first.\n\n  if (fallbacks) {\n    // Array syntax {fallbacks: [{prop: value}]}\n    if (Array.isArray(fallbacks)) {\n      for (var index = 0; index < fallbacks.length; index++) {\n        var fallback = fallbacks[index];\n\n        for (var prop in fallback) {\n          var value = fallback[prop];\n\n          if (value != null) {\n            if (result) result += linebreak;\n            result += indentStr(prop + \":\" + space + toCssValue(value) + \";\", indent);\n          }\n        }\n      }\n    } else {\n      // Object syntax {fallbacks: {prop: value}}\n      for (var _prop in fallbacks) {\n        var _value = fallbacks[_prop];\n\n        if (_value != null) {\n          if (result) result += linebreak;\n          result += indentStr(_prop + \":\" + space + toCssValue(_value) + \";\", indent);\n        }\n      }\n    }\n  }\n\n  for (var _prop2 in style) {\n    var _value2 = style[_prop2];\n\n    if (_value2 != null && _prop2 !== 'fallbacks') {\n      if (result) result += linebreak;\n      result += indentStr(_prop2 + \":\" + space + toCssValue(_value2) + \";\", indent);\n    }\n  } // Allow empty style in this case, because properties will be added dynamically.\n\n\n  if (!result && !options.allowEmpty) return result; // When rule is being stringified before selector was defined.\n\n  if (!selector) return result;\n  indent--;\n  if (result) result = \"\" + linebreak + result + linebreak;\n  return indentStr(\"\" + selector + space + \"{\" + result, indent) + indentStr('}', indent);\n}\n\nvar escapeRegex = /([[\\].#*$><+~=|^:(),\"'`\\s])/g;\nvar nativeEscape = typeof CSS !== 'undefined' && CSS.escape;\nvar escape = (function (str) {\n  return nativeEscape ? nativeEscape(str) : str.replace(escapeRegex, '\\\\$1');\n});\n\nvar BaseStyleRule =\n/*#__PURE__*/\nfunction () {\n  function BaseStyleRule(key, style, options) {\n    this.type = 'style';\n    this.isProcessed = false;\n    var sheet = options.sheet,\n        Renderer = options.Renderer;\n    this.key = key;\n    this.options = options;\n    this.style = style;\n    if (sheet) this.renderer = sheet.renderer;else if (Renderer) this.renderer = new Renderer();\n  }\n  /**\n   * Get or set a style property.\n   */\n\n\n  var _proto = BaseStyleRule.prototype;\n\n  _proto.prop = function prop(name, value, options) {\n    // It's a getter.\n    if (value === undefined) return this.style[name]; // Don't do anything if the value has not changed.\n\n    var force = options ? options.force : false;\n    if (!force && this.style[name] === value) return this;\n    var newValue = value;\n\n    if (!options || options.process !== false) {\n      newValue = this.options.jss.plugins.onChangeValue(value, name, this);\n    }\n\n    var isEmpty = newValue == null || newValue === false;\n    var isDefined = name in this.style; // Value is empty and wasn't defined before.\n\n    if (isEmpty && !isDefined && !force) return this; // We are going to remove this value.\n\n    var remove = isEmpty && isDefined;\n    if (remove) delete this.style[name];else this.style[name] = newValue; // Renderable is defined if StyleSheet option `link` is true.\n\n    if (this.renderable && this.renderer) {\n      if (remove) this.renderer.removeProperty(this.renderable, name);else this.renderer.setProperty(this.renderable, name, newValue);\n      return this;\n    }\n\n    var sheet = this.options.sheet;\n\n    if (sheet && sheet.attached) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, '[JSS] Rule is not linked. Missing sheet option \"link: true\".') : void 0;\n    }\n\n    return this;\n  };\n\n  return BaseStyleRule;\n}();\nvar StyleRule =\n/*#__PURE__*/\nfunction (_BaseStyleRule) {\n  _inheritsLoose(StyleRule, _BaseStyleRule);\n\n  function StyleRule(key, style, options) {\n    var _this;\n\n    _this = _BaseStyleRule.call(this, key, style, options) || this;\n    var selector = options.selector,\n        scoped = options.scoped,\n        sheet = options.sheet,\n        generateId = options.generateId;\n\n    if (selector) {\n      _this.selectorText = selector;\n    } else if (scoped !== false) {\n      _this.id = generateId(_assertThisInitialized(_assertThisInitialized(_this)), sheet);\n      _this.selectorText = \".\" + escape(_this.id);\n    }\n\n    return _this;\n  }\n  /**\n   * Set selector string.\n   * Attention: use this with caution. Most browsers didn't implement\n   * selectorText setter, so this may result in rerendering of entire Style Sheet.\n   */\n\n\n  var _proto2 = StyleRule.prototype;\n\n  /**\n   * Apply rule to an element inline.\n   */\n  _proto2.applyTo = function applyTo(renderable) {\n    var renderer = this.renderer;\n\n    if (renderer) {\n      var json = this.toJSON();\n\n      for (var prop in json) {\n        renderer.setProperty(renderable, prop, json[prop]);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Returns JSON representation of the rule.\n   * Fallbacks are not supported.\n   * Useful for inline styles.\n   */\n  ;\n\n  _proto2.toJSON = function toJSON() {\n    var json = {};\n\n    for (var prop in this.style) {\n      var value = this.style[prop];\n      if (typeof value !== 'object') json[prop] = value;else if (Array.isArray(value)) json[prop] = toCssValue(value);\n    }\n\n    return json;\n  }\n  /**\n   * Generates a CSS string.\n   */\n  ;\n\n  _proto2.toString = function toString(options) {\n    var sheet = this.options.sheet;\n    var link = sheet ? sheet.options.link : false;\n    var opts = link ? _extends({}, options, {\n      allowEmpty: true\n    }) : options;\n    return toCss(this.selectorText, this.style, opts);\n  };\n\n  _createClass(StyleRule, [{\n    key: \"selector\",\n    set: function set(selector) {\n      if (selector === this.selectorText) return;\n      this.selectorText = selector;\n      var renderer = this.renderer,\n          renderable = this.renderable;\n      if (!renderable || !renderer) return;\n      var hasChanged = renderer.setSelector(renderable, selector); // If selector setter is not implemented, rerender the rule.\n\n      if (!hasChanged) {\n        renderer.replaceRule(renderable, this);\n      }\n    }\n    /**\n     * Get selector string.\n     */\n    ,\n    get: function get() {\n      return this.selectorText;\n    }\n  }]);\n\n  return StyleRule;\n}(BaseStyleRule);\nvar pluginStyleRule = {\n  onCreateRule: function onCreateRule(key, style, options) {\n    if (key[0] === '@' || options.parent && options.parent.type === 'keyframes') {\n      return null;\n    }\n\n    return new StyleRule(key, style, options);\n  }\n};\n\nvar defaultToStringOptions = {\n  indent: 1,\n  children: true\n};\nvar atRegExp = /@([\\w-]+)/;\n/**\n * Conditional rule for @media, @supports\n */\n\nvar ConditionalRule =\n/*#__PURE__*/\nfunction () {\n  function ConditionalRule(key, styles, options) {\n    this.type = 'conditional';\n    this.isProcessed = false;\n    this.key = key;\n    var atMatch = key.match(atRegExp);\n    this.at = atMatch ? atMatch[1] : 'unknown'; // Key might contain a unique suffix in case the `name` passed by user was duplicate.\n\n    this.query = options.name || \"@\" + this.at;\n    this.options = options;\n    this.rules = new RuleList(_extends({}, options, {\n      parent: this\n    }));\n\n    for (var name in styles) {\n      this.rules.add(name, styles[name]);\n    }\n\n    this.rules.process();\n  }\n  /**\n   * Get a rule.\n   */\n\n\n  var _proto = ConditionalRule.prototype;\n\n  _proto.getRule = function getRule(name) {\n    return this.rules.get(name);\n  }\n  /**\n   * Get index of a rule.\n   */\n  ;\n\n  _proto.indexOf = function indexOf(rule) {\n    return this.rules.indexOf(rule);\n  }\n  /**\n   * Create and register rule, run plugins.\n   */\n  ;\n\n  _proto.addRule = function addRule(name, style, options) {\n    var rule = this.rules.add(name, style, options);\n    if (!rule) return null;\n    this.options.jss.plugins.onProcessRule(rule);\n    return rule;\n  }\n  /**\n   * Replace rule, run plugins.\n   */\n  ;\n\n  _proto.replaceRule = function replaceRule(name, style, options) {\n    var newRule = this.rules.replace(name, style, options);\n    if (newRule) this.options.jss.plugins.onProcessRule(newRule);\n    return newRule;\n  }\n  /**\n   * Generates a CSS string.\n   */\n  ;\n\n  _proto.toString = function toString(options) {\n    if (options === void 0) {\n      options = defaultToStringOptions;\n    }\n\n    var _getWhitespaceSymbols = getWhitespaceSymbols(options),\n        linebreak = _getWhitespaceSymbols.linebreak;\n\n    if (options.indent == null) options.indent = defaultToStringOptions.indent;\n    if (options.children == null) options.children = defaultToStringOptions.children;\n\n    if (options.children === false) {\n      return this.query + \" {}\";\n    }\n\n    var children = this.rules.toString(options);\n    return children ? this.query + \" {\" + linebreak + children + linebreak + \"}\" : '';\n  };\n\n  return ConditionalRule;\n}();\nvar keyRegExp = /@media|@supports\\s+/;\nvar pluginConditionalRule = {\n  onCreateRule: function onCreateRule(key, styles, options) {\n    return keyRegExp.test(key) ? new ConditionalRule(key, styles, options) : null;\n  }\n};\n\nvar defaultToStringOptions$1 = {\n  indent: 1,\n  children: true\n};\nvar nameRegExp = /@keyframes\\s+([\\w-]+)/;\n/**\n * Rule for @keyframes\n */\n\nvar KeyframesRule =\n/*#__PURE__*/\nfunction () {\n  function KeyframesRule(key, frames, options) {\n    this.type = 'keyframes';\n    this.at = '@keyframes';\n    this.isProcessed = false;\n    var nameMatch = key.match(nameRegExp);\n\n    if (nameMatch && nameMatch[1]) {\n      this.name = nameMatch[1];\n    } else {\n      this.name = 'noname';\n      process.env.NODE_ENV !== \"production\" ? warning(false, \"[JSS] Bad keyframes name \" + key) : void 0;\n    }\n\n    this.key = this.type + \"-\" + this.name;\n    this.options = options;\n    var scoped = options.scoped,\n        sheet = options.sheet,\n        generateId = options.generateId;\n    this.id = scoped === false ? this.name : escape(generateId(this, sheet));\n    this.rules = new RuleList(_extends({}, options, {\n      parent: this\n    }));\n\n    for (var name in frames) {\n      this.rules.add(name, frames[name], _extends({}, options, {\n        parent: this\n      }));\n    }\n\n    this.rules.process();\n  }\n  /**\n   * Generates a CSS string.\n   */\n\n\n  var _proto = KeyframesRule.prototype;\n\n  _proto.toString = function toString(options) {\n    if (options === void 0) {\n      options = defaultToStringOptions$1;\n    }\n\n    var _getWhitespaceSymbols = getWhitespaceSymbols(options),\n        linebreak = _getWhitespaceSymbols.linebreak;\n\n    if (options.indent == null) options.indent = defaultToStringOptions$1.indent;\n    if (options.children == null) options.children = defaultToStringOptions$1.children;\n\n    if (options.children === false) {\n      return this.at + \" \" + this.id + \" {}\";\n    }\n\n    var children = this.rules.toString(options);\n    if (children) children = \"\" + linebreak + children + linebreak;\n    return this.at + \" \" + this.id + \" {\" + children + \"}\";\n  };\n\n  return KeyframesRule;\n}();\nvar keyRegExp$1 = /@keyframes\\s+/;\nvar refRegExp = /\\$([\\w-]+)/g;\n\nvar findReferencedKeyframe = function findReferencedKeyframe(val, keyframes) {\n  if (typeof val === 'string') {\n    return val.replace(refRegExp, function (match, name) {\n      if (name in keyframes) {\n        return keyframes[name];\n      }\n\n      process.env.NODE_ENV !== \"production\" ? warning(false, \"[JSS] Referenced keyframes rule \\\"\" + name + \"\\\" is not defined.\") : void 0;\n      return match;\n    });\n  }\n\n  return val;\n};\n/**\n * Replace the reference for a animation name.\n */\n\n\nvar replaceRef = function replaceRef(style, prop, keyframes) {\n  var value = style[prop];\n  var refKeyframe = findReferencedKeyframe(value, keyframes);\n\n  if (refKeyframe !== value) {\n    style[prop] = refKeyframe;\n  }\n};\n\nvar pluginKeyframesRule = {\n  onCreateRule: function onCreateRule(key, frames, options) {\n    return typeof key === 'string' && keyRegExp$1.test(key) ? new KeyframesRule(key, frames, options) : null;\n  },\n  // Animation name ref replacer.\n  onProcessStyle: function onProcessStyle(style, rule, sheet) {\n    if (rule.type !== 'style' || !sheet) return style;\n    if ('animation-name' in style) replaceRef(style, 'animation-name', sheet.keyframes);\n    if ('animation' in style) replaceRef(style, 'animation', sheet.keyframes);\n    return style;\n  },\n  onChangeValue: function onChangeValue(val, prop, rule) {\n    var sheet = rule.options.sheet;\n\n    if (!sheet) {\n      return val;\n    }\n\n    switch (prop) {\n      case 'animation':\n        return findReferencedKeyframe(val, sheet.keyframes);\n\n      case 'animation-name':\n        return findReferencedKeyframe(val, sheet.keyframes);\n\n      default:\n        return val;\n    }\n  }\n};\n\nvar KeyframeRule =\n/*#__PURE__*/\nfunction (_BaseStyleRule) {\n  _inheritsLoose(KeyframeRule, _BaseStyleRule);\n\n  function KeyframeRule() {\n    return _BaseStyleRule.apply(this, arguments) || this;\n  }\n\n  var _proto = KeyframeRule.prototype;\n\n  /**\n   * Generates a CSS string.\n   */\n  _proto.toString = function toString(options) {\n    var sheet = this.options.sheet;\n    var link = sheet ? sheet.options.link : false;\n    var opts = link ? _extends({}, options, {\n      allowEmpty: true\n    }) : options;\n    return toCss(this.key, this.style, opts);\n  };\n\n  return KeyframeRule;\n}(BaseStyleRule);\nvar pluginKeyframeRule = {\n  onCreateRule: function onCreateRule(key, style, options) {\n    if (options.parent && options.parent.type === 'keyframes') {\n      return new KeyframeRule(key, style, options);\n    }\n\n    return null;\n  }\n};\n\nvar FontFaceRule =\n/*#__PURE__*/\nfunction () {\n  function FontFaceRule(key, style, options) {\n    this.type = 'font-face';\n    this.at = '@font-face';\n    this.isProcessed = false;\n    this.key = key;\n    this.style = style;\n    this.options = options;\n  }\n  /**\n   * Generates a CSS string.\n   */\n\n\n  var _proto = FontFaceRule.prototype;\n\n  _proto.toString = function toString(options) {\n    var _getWhitespaceSymbols = getWhitespaceSymbols(options),\n        linebreak = _getWhitespaceSymbols.linebreak;\n\n    if (Array.isArray(this.style)) {\n      var str = '';\n\n      for (var index = 0; index < this.style.length; index++) {\n        str += toCss(this.at, this.style[index]);\n        if (this.style[index + 1]) str += linebreak;\n      }\n\n      return str;\n    }\n\n    return toCss(this.at, this.style, options);\n  };\n\n  return FontFaceRule;\n}();\nvar keyRegExp$2 = /@font-face/;\nvar pluginFontFaceRule = {\n  onCreateRule: function onCreateRule(key, style, options) {\n    return keyRegExp$2.test(key) ? new FontFaceRule(key, style, options) : null;\n  }\n};\n\nvar ViewportRule =\n/*#__PURE__*/\nfunction () {\n  function ViewportRule(key, style, options) {\n    this.type = 'viewport';\n    this.at = '@viewport';\n    this.isProcessed = false;\n    this.key = key;\n    this.style = style;\n    this.options = options;\n  }\n  /**\n   * Generates a CSS string.\n   */\n\n\n  var _proto = ViewportRule.prototype;\n\n  _proto.toString = function toString(options) {\n    return toCss(this.key, this.style, options);\n  };\n\n  return ViewportRule;\n}();\nvar pluginViewportRule = {\n  onCreateRule: function onCreateRule(key, style, options) {\n    return key === '@viewport' || key === '@-ms-viewport' ? new ViewportRule(key, style, options) : null;\n  }\n};\n\nvar SimpleRule =\n/*#__PURE__*/\nfunction () {\n  function SimpleRule(key, value, options) {\n    this.type = 'simple';\n    this.isProcessed = false;\n    this.key = key;\n    this.value = value;\n    this.options = options;\n  }\n  /**\n   * Generates a CSS string.\n   */\n  // eslint-disable-next-line no-unused-vars\n\n\n  var _proto = SimpleRule.prototype;\n\n  _proto.toString = function toString(options) {\n    if (Array.isArray(this.value)) {\n      var str = '';\n\n      for (var index = 0; index < this.value.length; index++) {\n        str += this.key + \" \" + this.value[index] + \";\";\n        if (this.value[index + 1]) str += '\\n';\n      }\n\n      return str;\n    }\n\n    return this.key + \" \" + this.value + \";\";\n  };\n\n  return SimpleRule;\n}();\nvar keysMap = {\n  '@charset': true,\n  '@import': true,\n  '@namespace': true\n};\nvar pluginSimpleRule = {\n  onCreateRule: function onCreateRule(key, value, options) {\n    return key in keysMap ? new SimpleRule(key, value, options) : null;\n  }\n};\n\nvar plugins = [pluginStyleRule, pluginConditionalRule, pluginKeyframesRule, pluginKeyframeRule, pluginFontFaceRule, pluginViewportRule, pluginSimpleRule];\n\nvar defaultUpdateOptions = {\n  process: true\n};\nvar forceUpdateOptions = {\n  force: true,\n  process: true\n  /**\n   * Contains rules objects and allows adding/removing etc.\n   * Is used for e.g. by `StyleSheet` or `ConditionalRule`.\n   */\n\n};\n\nvar RuleList =\n/*#__PURE__*/\nfunction () {\n  // Rules registry for access by .get() method.\n  // It contains the same rule registered by name and by selector.\n  // Original styles object.\n  // Used to ensure correct rules order.\n  function RuleList(options) {\n    this.map = {};\n    this.raw = {};\n    this.index = [];\n    this.counter = 0;\n    this.options = options;\n    this.classes = options.classes;\n    this.keyframes = options.keyframes;\n  }\n  /**\n   * Create and register rule.\n   *\n   * Will not render after Style Sheet was rendered the first time.\n   */\n\n\n  var _proto = RuleList.prototype;\n\n  _proto.add = function add(name, decl, ruleOptions) {\n    var _this$options = this.options,\n        parent = _this$options.parent,\n        sheet = _this$options.sheet,\n        jss = _this$options.jss,\n        Renderer = _this$options.Renderer,\n        generateId = _this$options.generateId,\n        scoped = _this$options.scoped;\n\n    var options = _extends({\n      classes: this.classes,\n      parent: parent,\n      sheet: sheet,\n      jss: jss,\n      Renderer: Renderer,\n      generateId: generateId,\n      scoped: scoped,\n      name: name,\n      keyframes: this.keyframes,\n      selector: undefined\n    }, ruleOptions); // When user uses .createStyleSheet(), duplicate names are not possible, but\n    // `sheet.addRule()` opens the door for any duplicate rule name. When this happens\n    // we need to make the key unique within this RuleList instance scope.\n\n\n    var key = name;\n\n    if (name in this.raw) {\n      key = name + \"-d\" + this.counter++;\n    } // We need to save the original decl before creating the rule\n    // because cache plugin needs to use it as a key to return a cached rule.\n\n\n    this.raw[key] = decl;\n\n    if (key in this.classes) {\n      // E.g. rules inside of @media container\n      options.selector = \".\" + escape(this.classes[key]);\n    }\n\n    var rule = createRule(key, decl, options);\n    if (!rule) return null;\n    this.register(rule);\n    var index = options.index === undefined ? this.index.length : options.index;\n    this.index.splice(index, 0, rule);\n    return rule;\n  }\n  /**\n   * Replace rule.\n   * Create a new rule and remove old one instead of overwriting\n   * because we want to invoke onCreateRule hook to make plugins work.\n   */\n  ;\n\n  _proto.replace = function replace(name, decl, ruleOptions) {\n    var oldRule = this.get(name);\n    var oldIndex = this.index.indexOf(oldRule);\n\n    if (oldRule) {\n      this.remove(oldRule);\n    }\n\n    var options = ruleOptions;\n    if (oldIndex !== -1) options = _extends({}, ruleOptions, {\n      index: oldIndex\n    });\n    return this.add(name, decl, options);\n  }\n  /**\n   * Get a rule by name or selector.\n   */\n  ;\n\n  _proto.get = function get(nameOrSelector) {\n    return this.map[nameOrSelector];\n  }\n  /**\n   * Delete a rule.\n   */\n  ;\n\n  _proto.remove = function remove(rule) {\n    this.unregister(rule);\n    delete this.raw[rule.key];\n    this.index.splice(this.index.indexOf(rule), 1);\n  }\n  /**\n   * Get index of a rule.\n   */\n  ;\n\n  _proto.indexOf = function indexOf(rule) {\n    return this.index.indexOf(rule);\n  }\n  /**\n   * Run `onProcessRule()` plugins on every rule.\n   */\n  ;\n\n  _proto.process = function process() {\n    var plugins = this.options.jss.plugins; // We need to clone array because if we modify the index somewhere else during a loop\n    // we end up with very hard-to-track-down side effects.\n\n    this.index.slice(0).forEach(plugins.onProcessRule, plugins);\n  }\n  /**\n   * Register a rule in `.map`, `.classes` and `.keyframes` maps.\n   */\n  ;\n\n  _proto.register = function register(rule) {\n    this.map[rule.key] = rule;\n\n    if (rule instanceof StyleRule) {\n      this.map[rule.selector] = rule;\n      if (rule.id) this.classes[rule.key] = rule.id;\n    } else if (rule instanceof KeyframesRule && this.keyframes) {\n      this.keyframes[rule.name] = rule.id;\n    }\n  }\n  /**\n   * Unregister a rule.\n   */\n  ;\n\n  _proto.unregister = function unregister(rule) {\n    delete this.map[rule.key];\n\n    if (rule instanceof StyleRule) {\n      delete this.map[rule.selector];\n      delete this.classes[rule.key];\n    } else if (rule instanceof KeyframesRule) {\n      delete this.keyframes[rule.name];\n    }\n  }\n  /**\n   * Update the function values with a new data.\n   */\n  ;\n\n  _proto.update = function update() {\n    var name;\n    var data;\n    var options;\n\n    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'string') {\n      name = arguments.length <= 0 ? undefined : arguments[0];\n      data = arguments.length <= 1 ? undefined : arguments[1];\n      options = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      data = arguments.length <= 0 ? undefined : arguments[0];\n      options = arguments.length <= 1 ? undefined : arguments[1];\n      name = null;\n    }\n\n    if (name) {\n      this.updateOne(this.get(name), data, options);\n    } else {\n      for (var index = 0; index < this.index.length; index++) {\n        this.updateOne(this.index[index], data, options);\n      }\n    }\n  }\n  /**\n   * Execute plugins, update rule props.\n   */\n  ;\n\n  _proto.updateOne = function updateOne(rule, data, options) {\n    if (options === void 0) {\n      options = defaultUpdateOptions;\n    }\n\n    var _this$options2 = this.options,\n        plugins = _this$options2.jss.plugins,\n        sheet = _this$options2.sheet; // It is a rules container like for e.g. ConditionalRule.\n\n    if (rule.rules instanceof RuleList) {\n      rule.rules.update(data, options);\n      return;\n    }\n\n    var style = rule.style;\n    plugins.onUpdate(data, rule, sheet, options); // We rely on a new `style` ref in case it was mutated during onUpdate hook.\n\n    if (options.process && style && style !== rule.style) {\n      // We need to run the plugins in case new `style` relies on syntax plugins.\n      plugins.onProcessStyle(rule.style, rule, sheet); // Update and add props.\n\n      for (var prop in rule.style) {\n        var nextValue = rule.style[prop];\n        var prevValue = style[prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.\n        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.\n\n        if (nextValue !== prevValue) {\n          rule.prop(prop, nextValue, forceUpdateOptions);\n        }\n      } // Remove props.\n\n\n      for (var _prop in style) {\n        var _nextValue = rule.style[_prop];\n        var _prevValue = style[_prop]; // We need to use `force: true` because `rule.style` has been updated during onUpdate hook, so `rule.prop()` will not update the CSSOM rule.\n        // We do this comparison to avoid unneeded `rule.prop()` calls, since we have the old `style` object here.\n\n        if (_nextValue == null && _nextValue !== _prevValue) {\n          rule.prop(_prop, null, forceUpdateOptions);\n        }\n      }\n    }\n  }\n  /**\n   * Convert rules to a CSS string.\n   */\n  ;\n\n  _proto.toString = function toString(options) {\n    var str = '';\n    var sheet = this.options.sheet;\n    var link = sheet ? sheet.options.link : false;\n\n    var _getWhitespaceSymbols = getWhitespaceSymbols(options),\n        linebreak = _getWhitespaceSymbols.linebreak;\n\n    for (var index = 0; index < this.index.length; index++) {\n      var rule = this.index[index];\n      var css = rule.toString(options); // No need to render an empty rule.\n\n      if (!css && !link) continue;\n      if (str) str += linebreak;\n      str += css;\n    }\n\n    return str;\n  };\n\n  return RuleList;\n}();\n\nvar StyleSheet =\n/*#__PURE__*/\nfunction () {\n  function StyleSheet(styles, options) {\n    this.attached = false;\n    this.deployed = false;\n    this.classes = {};\n    this.keyframes = {};\n    this.options = _extends({}, options, {\n      sheet: this,\n      parent: this,\n      classes: this.classes,\n      keyframes: this.keyframes\n    });\n\n    if (options.Renderer) {\n      this.renderer = new options.Renderer(this);\n    }\n\n    this.rules = new RuleList(this.options);\n\n    for (var name in styles) {\n      this.rules.add(name, styles[name]);\n    }\n\n    this.rules.process();\n  }\n  /**\n   * Attach renderable to the render tree.\n   */\n\n\n  var _proto = StyleSheet.prototype;\n\n  _proto.attach = function attach() {\n    if (this.attached) return this;\n    if (this.renderer) this.renderer.attach();\n    this.attached = true; // Order is important, because we can't use insertRule API if style element is not attached.\n\n    if (!this.deployed) this.deploy();\n    return this;\n  }\n  /**\n   * Remove renderable from render tree.\n   */\n  ;\n\n  _proto.detach = function detach() {\n    if (!this.attached) return this;\n    if (this.renderer) this.renderer.detach();\n    this.attached = false;\n    return this;\n  }\n  /**\n   * Add a rule to the current stylesheet.\n   * Will insert a rule also after the stylesheet has been rendered first time.\n   */\n  ;\n\n  _proto.addRule = function addRule(name, decl, options) {\n    var queue = this.queue; // Plugins can create rules.\n    // In order to preserve the right order, we need to queue all `.addRule` calls,\n    // which happen after the first `rules.add()` call.\n\n    if (this.attached && !queue) this.queue = [];\n    var rule = this.rules.add(name, decl, options);\n    if (!rule) return null;\n    this.options.jss.plugins.onProcessRule(rule);\n\n    if (this.attached) {\n      if (!this.deployed) return rule; // Don't insert rule directly if there is no stringified version yet.\n      // It will be inserted all together when .attach is called.\n\n      if (queue) queue.push(rule);else {\n        this.insertRule(rule);\n\n        if (this.queue) {\n          this.queue.forEach(this.insertRule, this);\n          this.queue = undefined;\n        }\n      }\n      return rule;\n    } // We can't add rules to a detached style node.\n    // We will redeploy the sheet once user will attach it.\n\n\n    this.deployed = false;\n    return rule;\n  }\n  /**\n   * Replace a rule in the current stylesheet.\n   */\n  ;\n\n  _proto.replaceRule = function replaceRule(nameOrSelector, decl, options) {\n    var oldRule = this.rules.get(nameOrSelector);\n    if (!oldRule) return this.addRule(nameOrSelector, decl, options);\n    var newRule = this.rules.replace(nameOrSelector, decl, options);\n\n    if (newRule) {\n      this.options.jss.plugins.onProcessRule(newRule);\n    }\n\n    if (this.attached) {\n      if (!this.deployed) return newRule; // Don't replace / delete rule directly if there is no stringified version yet.\n      // It will be inserted all together when .attach is called.\n\n      if (this.renderer) {\n        if (!newRule) {\n          this.renderer.deleteRule(oldRule);\n        } else if (oldRule.renderable) {\n          this.renderer.replaceRule(oldRule.renderable, newRule);\n        }\n      }\n\n      return newRule;\n    } // We can't replace rules to a detached style node.\n    // We will redeploy the sheet once user will attach it.\n\n\n    this.deployed = false;\n    return newRule;\n  }\n  /**\n   * Insert rule into the StyleSheet\n   */\n  ;\n\n  _proto.insertRule = function insertRule(rule) {\n    if (this.renderer) {\n      this.renderer.insertRule(rule);\n    }\n  }\n  /**\n   * Create and add rules.\n   * Will render also after Style Sheet was rendered the first time.\n   */\n  ;\n\n  _proto.addRules = function addRules(styles, options) {\n    var added = [];\n\n    for (var name in styles) {\n      var rule = this.addRule(name, styles[name], options);\n      if (rule) added.push(rule);\n    }\n\n    return added;\n  }\n  /**\n   * Get a rule by name or selector.\n   */\n  ;\n\n  _proto.getRule = function getRule(nameOrSelector) {\n    return this.rules.get(nameOrSelector);\n  }\n  /**\n   * Delete a rule by name.\n   * Returns `true`: if rule has been deleted from the DOM.\n   */\n  ;\n\n  _proto.deleteRule = function deleteRule(name) {\n    var rule = typeof name === 'object' ? name : this.rules.get(name);\n\n    if (!rule || // Style sheet was created without link: true and attached, in this case we\n    // won't be able to remove the CSS rule from the DOM.\n    this.attached && !rule.renderable) {\n      return false;\n    }\n\n    this.rules.remove(rule);\n\n    if (this.attached && rule.renderable && this.renderer) {\n      return this.renderer.deleteRule(rule.renderable);\n    }\n\n    return true;\n  }\n  /**\n   * Get index of a rule.\n   */\n  ;\n\n  _proto.indexOf = function indexOf(rule) {\n    return this.rules.indexOf(rule);\n  }\n  /**\n   * Deploy pure CSS string to a renderable.\n   */\n  ;\n\n  _proto.deploy = function deploy() {\n    if (this.renderer) this.renderer.deploy();\n    this.deployed = true;\n    return this;\n  }\n  /**\n   * Update the function values with a new data.\n   */\n  ;\n\n  _proto.update = function update() {\n    var _this$rules;\n\n    (_this$rules = this.rules).update.apply(_this$rules, arguments);\n\n    return this;\n  }\n  /**\n   * Updates a single rule.\n   */\n  ;\n\n  _proto.updateOne = function updateOne(rule, data, options) {\n    this.rules.updateOne(rule, data, options);\n    return this;\n  }\n  /**\n   * Convert rules to a CSS string.\n   */\n  ;\n\n  _proto.toString = function toString(options) {\n    return this.rules.toString(options);\n  };\n\n  return StyleSheet;\n}();\n\nvar PluginsRegistry =\n/*#__PURE__*/\nfunction () {\n  function PluginsRegistry() {\n    this.plugins = {\n      internal: [],\n      external: []\n    };\n    this.registry = {};\n  }\n\n  var _proto = PluginsRegistry.prototype;\n\n  /**\n   * Call `onCreateRule` hooks and return an object if returned by a hook.\n   */\n  _proto.onCreateRule = function onCreateRule(name, decl, options) {\n    for (var i = 0; i < this.registry.onCreateRule.length; i++) {\n      var rule = this.registry.onCreateRule[i](name, decl, options);\n      if (rule) return rule;\n    }\n\n    return null;\n  }\n  /**\n   * Call `onProcessRule` hooks.\n   */\n  ;\n\n  _proto.onProcessRule = function onProcessRule(rule) {\n    if (rule.isProcessed) return;\n    var sheet = rule.options.sheet;\n\n    for (var i = 0; i < this.registry.onProcessRule.length; i++) {\n      this.registry.onProcessRule[i](rule, sheet);\n    }\n\n    if (rule.style) this.onProcessStyle(rule.style, rule, sheet);\n    rule.isProcessed = true;\n  }\n  /**\n   * Call `onProcessStyle` hooks.\n   */\n  ;\n\n  _proto.onProcessStyle = function onProcessStyle(style, rule, sheet) {\n    for (var i = 0; i < this.registry.onProcessStyle.length; i++) {\n      rule.style = this.registry.onProcessStyle[i](rule.style, rule, sheet);\n    }\n  }\n  /**\n   * Call `onProcessSheet` hooks.\n   */\n  ;\n\n  _proto.onProcessSheet = function onProcessSheet(sheet) {\n    for (var i = 0; i < this.registry.onProcessSheet.length; i++) {\n      this.registry.onProcessSheet[i](sheet);\n    }\n  }\n  /**\n   * Call `onUpdate` hooks.\n   */\n  ;\n\n  _proto.onUpdate = function onUpdate(data, rule, sheet, options) {\n    for (var i = 0; i < this.registry.onUpdate.length; i++) {\n      this.registry.onUpdate[i](data, rule, sheet, options);\n    }\n  }\n  /**\n   * Call `onChangeValue` hooks.\n   */\n  ;\n\n  _proto.onChangeValue = function onChangeValue(value, prop, rule) {\n    var processedValue = value;\n\n    for (var i = 0; i < this.registry.onChangeValue.length; i++) {\n      processedValue = this.registry.onChangeValue[i](processedValue, prop, rule);\n    }\n\n    return processedValue;\n  }\n  /**\n   * Register a plugin.\n   */\n  ;\n\n  _proto.use = function use(newPlugin, options) {\n    if (options === void 0) {\n      options = {\n        queue: 'external'\n      };\n    }\n\n    var plugins = this.plugins[options.queue]; // Avoids applying same plugin twice, at least based on ref.\n\n    if (plugins.indexOf(newPlugin) !== -1) {\n      return;\n    }\n\n    plugins.push(newPlugin);\n    this.registry = [].concat(this.plugins.external, this.plugins.internal).reduce(function (registry, plugin) {\n      for (var name in plugin) {\n        if (name in registry) {\n          registry[name].push(plugin[name]);\n        } else {\n          process.env.NODE_ENV !== \"production\" ? warning(false, \"[JSS] Unknown hook \\\"\" + name + \"\\\".\") : void 0;\n        }\n      }\n\n      return registry;\n    }, {\n      onCreateRule: [],\n      onProcessRule: [],\n      onProcessStyle: [],\n      onProcessSheet: [],\n      onChangeValue: [],\n      onUpdate: []\n    });\n  };\n\n  return PluginsRegistry;\n}();\n\n/**\n * Sheets registry to access all instances in one place.\n */\n\nvar SheetsRegistry =\n/*#__PURE__*/\nfunction () {\n  function SheetsRegistry() {\n    this.registry = [];\n  }\n\n  var _proto = SheetsRegistry.prototype;\n\n  /**\n   * Register a Style Sheet.\n   */\n  _proto.add = function add(sheet) {\n    var registry = this.registry;\n    var index = sheet.options.index;\n    if (registry.indexOf(sheet) !== -1) return;\n\n    if (registry.length === 0 || index >= this.index) {\n      registry.push(sheet);\n      return;\n    } // Find a position.\n\n\n    for (var i = 0; i < registry.length; i++) {\n      if (registry[i].options.index > index) {\n        registry.splice(i, 0, sheet);\n        return;\n      }\n    }\n  }\n  /**\n   * Reset the registry.\n   */\n  ;\n\n  _proto.reset = function reset() {\n    this.registry = [];\n  }\n  /**\n   * Remove a Style Sheet.\n   */\n  ;\n\n  _proto.remove = function remove(sheet) {\n    var index = this.registry.indexOf(sheet);\n    this.registry.splice(index, 1);\n  }\n  /**\n   * Convert all attached sheets to a CSS string.\n   */\n  ;\n\n  _proto.toString = function toString(_temp) {\n    var _ref = _temp === void 0 ? {} : _temp,\n        attached = _ref.attached,\n        options = _objectWithoutPropertiesLoose(_ref, [\"attached\"]);\n\n    var _getWhitespaceSymbols = getWhitespaceSymbols(options),\n        linebreak = _getWhitespaceSymbols.linebreak;\n\n    var css = '';\n\n    for (var i = 0; i < this.registry.length; i++) {\n      var sheet = this.registry[i];\n\n      if (attached != null && sheet.attached !== attached) {\n        continue;\n      }\n\n      if (css) css += linebreak;\n      css += sheet.toString(options);\n    }\n\n    return css;\n  };\n\n  _createClass(SheetsRegistry, [{\n    key: \"index\",\n\n    /**\n     * Current highest index number.\n     */\n    get: function get() {\n      return this.registry.length === 0 ? 0 : this.registry[this.registry.length - 1].options.index;\n    }\n  }]);\n\n  return SheetsRegistry;\n}();\n\n/**\n * This is a global sheets registry. Only DomRenderer will add sheets to it.\n * On the server one should use an own SheetsRegistry instance and add the\n * sheets to it, because you need to make sure to create a new registry for\n * each request in order to not leak sheets across requests.\n */\n\nvar sheets = new SheetsRegistry();\n\n/* eslint-disable */\n\n/**\n * Now that `globalThis` is available on most platforms\n * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis#browser_compatibility)\n * we check for `globalThis` first. `globalThis` is necessary for jss\n * to run in Agoric's secure version of JavaScript (SES). Under SES,\n * `globalThis` exists, but `window`, `self`, and `Function('return\n * this')()` are all undefined for security reasons.\n *\n * https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n */\nvar globalThis$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' && window.Math === Math ? window : typeof self !== 'undefined' && self.Math === Math ? self : Function('return this')();\n\nvar ns = '2f1acc6c3a606b082e5eef5e54414ffb';\nif (globalThis$1[ns] == null) globalThis$1[ns] = 0; // Bundle may contain multiple JSS versions at the same time. In order to identify\n// the current version with just one short number and use it for classes generation\n// we use a counter. Also it is more accurate, because user can manually reevaluate\n// the module.\n\nvar moduleId = globalThis$1[ns]++;\n\nvar maxRules = 1e10;\n/**\n * Returns a function which generates unique class names based on counters.\n * When new generator function is created, rule counter is reseted.\n * We need to reset the rule counter for SSR for each request.\n */\n\nvar createGenerateId = function createGenerateId(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var ruleCounter = 0;\n\n  var generateId = function generateId(rule, sheet) {\n    ruleCounter += 1;\n\n    if (ruleCounter > maxRules) {\n      process.env.NODE_ENV !== \"production\" ? warning(false, \"[JSS] You might have a memory leak. Rule counter is at \" + ruleCounter + \".\") : void 0;\n    }\n\n    var jssId = '';\n    var prefix = '';\n\n    if (sheet) {\n      if (sheet.options.classNamePrefix) {\n        prefix = sheet.options.classNamePrefix;\n      }\n\n      if (sheet.options.jss.id != null) {\n        jssId = String(sheet.options.jss.id);\n      }\n    }\n\n    if (options.minify) {\n      // Using \"c\" because a number can't be the first char in a class name.\n      return \"\" + (prefix || 'c') + moduleId + jssId + ruleCounter;\n    }\n\n    return prefix + rule.key + \"-\" + moduleId + (jssId ? \"-\" + jssId : '') + \"-\" + ruleCounter;\n  };\n\n  return generateId;\n};\n\n/**\n * Cache the value from the first time a function is called.\n */\n\nvar memoize = function memoize(fn) {\n  var value;\n  return function () {\n    if (!value) value = fn();\n    return value;\n  };\n};\n/**\n * Get a style property value.\n */\n\n\nvar getPropertyValue = function getPropertyValue(cssRule, prop) {\n  try {\n    // Support CSSTOM.\n    if (cssRule.attributeStyleMap) {\n      return cssRule.attributeStyleMap.get(prop);\n    }\n\n    return cssRule.style.getPropertyValue(prop);\n  } catch (err) {\n    // IE may throw if property is unknown.\n    return '';\n  }\n};\n/**\n * Set a style property.\n */\n\n\nvar setProperty = function setProperty(cssRule, prop, value) {\n  try {\n    var cssValue = value;\n\n    if (Array.isArray(value)) {\n      cssValue = toCssValue(value);\n    } // Support CSSTOM.\n\n\n    if (cssRule.attributeStyleMap) {\n      cssRule.attributeStyleMap.set(prop, cssValue);\n    } else {\n      var indexOfImportantFlag = cssValue ? cssValue.indexOf('!important') : -1;\n      var cssValueWithoutImportantFlag = indexOfImportantFlag > -1 ? cssValue.substr(0, indexOfImportantFlag - 1) : cssValue;\n      cssRule.style.setProperty(prop, cssValueWithoutImportantFlag, indexOfImportantFlag > -1 ? 'important' : '');\n    }\n  } catch (err) {\n    // IE may throw if property is unknown.\n    return false;\n  }\n\n  return true;\n};\n/**\n * Remove a style property.\n */\n\n\nvar removeProperty = function removeProperty(cssRule, prop) {\n  try {\n    // Support CSSTOM.\n    if (cssRule.attributeStyleMap) {\n      cssRule.attributeStyleMap.delete(prop);\n    } else {\n      cssRule.style.removeProperty(prop);\n    }\n  } catch (err) {\n    process.env.NODE_ENV !== \"production\" ? warning(false, \"[JSS] DOMException \\\"\" + err.message + \"\\\" was thrown. Tried to remove property \\\"\" + prop + \"\\\".\") : void 0;\n  }\n};\n/**\n * Set the selector.\n */\n\n\nvar setSelector = function setSelector(cssRule, selectorText) {\n  cssRule.selectorText = selectorText; // Return false if setter was not successful.\n  // Currently works in chrome only.\n\n  return cssRule.selectorText === selectorText;\n};\n/**\n * Gets the `head` element upon the first call and caches it.\n * We assume it can't be null.\n */\n\n\nvar getHead = memoize(function () {\n  return document.querySelector('head');\n});\n/**\n * Find attached sheet with an index higher than the passed one.\n */\n\nfunction findHigherSheet(registry, options) {\n  for (var i = 0; i < registry.length; i++) {\n    var sheet = registry[i];\n\n    if (sheet.attached && sheet.options.index > options.index && sheet.options.insertionPoint === options.insertionPoint) {\n      return sheet;\n    }\n  }\n\n  return null;\n}\n/**\n * Find attached sheet with the highest index.\n */\n\n\nfunction findHighestSheet(registry, options) {\n  for (var i = registry.length - 1; i >= 0; i--) {\n    var sheet = registry[i];\n\n    if (sheet.attached && sheet.options.insertionPoint === options.insertionPoint) {\n      return sheet;\n    }\n  }\n\n  return null;\n}\n/**\n * Find a comment with \"jss\" inside.\n */\n\n\nfunction findCommentNode(text) {\n  var head = getHead();\n\n  for (var i = 0; i < head.childNodes.length; i++) {\n    var node = head.childNodes[i];\n\n    if (node.nodeType === 8 && node.nodeValue.trim() === text) {\n      return node;\n    }\n  }\n\n  return null;\n}\n/**\n * Find a node before which we can insert the sheet.\n */\n\n\nfunction findPrevNode(options) {\n  var registry = sheets.registry;\n\n  if (registry.length > 0) {\n    // Try to insert before the next higher sheet.\n    var sheet = findHigherSheet(registry, options);\n\n    if (sheet && sheet.renderer) {\n      return {\n        parent: sheet.renderer.element.parentNode,\n        node: sheet.renderer.element\n      };\n    } // Otherwise insert after the last attached.\n\n\n    sheet = findHighestSheet(registry, options);\n\n    if (sheet && sheet.renderer) {\n      return {\n        parent: sheet.renderer.element.parentNode,\n        node: sheet.renderer.element.nextSibling\n      };\n    }\n  } // Try to find a comment placeholder if registry is empty.\n\n\n  var insertionPoint = options.insertionPoint;\n\n  if (insertionPoint && typeof insertionPoint === 'string') {\n    var comment = findCommentNode(insertionPoint);\n\n    if (comment) {\n      return {\n        parent: comment.parentNode,\n        node: comment.nextSibling\n      };\n    } // If user specifies an insertion point and it can't be found in the document -\n    // bad specificity issues may appear.\n\n\n    process.env.NODE_ENV !== \"production\" ? warning(false, \"[JSS] Insertion point \\\"\" + insertionPoint + \"\\\" not found.\") : void 0;\n  }\n\n  return false;\n}\n/**\n * Insert style element into the DOM.\n */\n\n\nfunction insertStyle(style, options) {\n  var insertionPoint = options.insertionPoint;\n  var nextNode = findPrevNode(options);\n\n  if (nextNode !== false && nextNode.parent) {\n    nextNode.parent.insertBefore(style, nextNode.node);\n    return;\n  } // Works with iframes and any node types.\n\n\n  if (insertionPoint && typeof insertionPoint.nodeType === 'number') {\n    var insertionPointElement = insertionPoint;\n    var parentNode = insertionPointElement.parentNode;\n    if (parentNode) parentNode.insertBefore(style, insertionPointElement.nextSibling);else process.env.NODE_ENV !== \"production\" ? warning(false, '[JSS] Insertion point is not in the DOM.') : void 0;\n    return;\n  }\n\n  getHead().appendChild(style);\n}\n/**\n * Read jss nonce setting from the page if the user has set it.\n */\n\n\nvar getNonce = memoize(function () {\n  var node = document.querySelector('meta[property=\"csp-nonce\"]');\n  return node ? node.getAttribute('content') : null;\n});\n\nvar _insertRule = function insertRule(container, rule, index) {\n  try {\n    if ('insertRule' in container) {\n      container.insertRule(rule, index);\n    } // Keyframes rule.\n    else if ('appendRule' in container) {\n        container.appendRule(rule);\n      }\n  } catch (err) {\n    process.env.NODE_ENV !== \"production\" ? warning(false, \"[JSS] \" + err.message) : void 0;\n    return false;\n  }\n\n  return container.cssRules[index];\n};\n\nvar getValidRuleInsertionIndex = function getValidRuleInsertionIndex(container, index) {\n  var maxIndex = container.cssRules.length; // In case previous insertion fails, passed index might be wrong\n\n  if (index === undefined || index > maxIndex) {\n    // eslint-disable-next-line no-param-reassign\n    return maxIndex;\n  }\n\n  return index;\n};\n\nvar createStyle = function createStyle() {\n  var el = document.createElement('style'); // Without it, IE will have a broken source order specificity if we\n  // insert rules after we insert the style tag.\n  // It seems to kick-off the source order specificity algorithm.\n\n  el.textContent = '\\n';\n  return el;\n};\n\nvar DomRenderer =\n/*#__PURE__*/\nfunction () {\n  // Will be empty if link: true option is not set, because\n  // it is only for use together with insertRule API.\n  function DomRenderer(sheet) {\n    this.getPropertyValue = getPropertyValue;\n    this.setProperty = setProperty;\n    this.removeProperty = removeProperty;\n    this.setSelector = setSelector;\n    this.hasInsertedRules = false;\n    this.cssRules = [];\n    // There is no sheet when the renderer is used from a standalone StyleRule.\n    if (sheet) sheets.add(sheet);\n    this.sheet = sheet;\n\n    var _ref = this.sheet ? this.sheet.options : {},\n        media = _ref.media,\n        meta = _ref.meta,\n        element = _ref.element;\n\n    this.element = element || createStyle();\n    this.element.setAttribute('data-jss', '');\n    if (media) this.element.setAttribute('media', media);\n    if (meta) this.element.setAttribute('data-meta', meta);\n    var nonce = getNonce();\n    if (nonce) this.element.setAttribute('nonce', nonce);\n  }\n  /**\n   * Insert style element into render tree.\n   */\n\n\n  var _proto = DomRenderer.prototype;\n\n  _proto.attach = function attach() {\n    // In the case the element node is external and it is already in the DOM.\n    if (this.element.parentNode || !this.sheet) return;\n    insertStyle(this.element, this.sheet.options); // When rules are inserted using `insertRule` API, after `sheet.detach().attach()`\n    // most browsers create a new CSSStyleSheet, except of all IEs.\n\n    var deployed = Boolean(this.sheet && this.sheet.deployed);\n\n    if (this.hasInsertedRules && deployed) {\n      this.hasInsertedRules = false;\n      this.deploy();\n    }\n  }\n  /**\n   * Remove style element from render tree.\n   */\n  ;\n\n  _proto.detach = function detach() {\n    if (!this.sheet) return;\n    var parentNode = this.element.parentNode;\n    if (parentNode) parentNode.removeChild(this.element); // In the most browsers, rules inserted using insertRule() API will be lost when style element is removed.\n    // Though IE will keep them and we need a consistent behavior.\n\n    if (this.sheet.options.link) {\n      this.cssRules = [];\n      this.element.textContent = '\\n';\n    }\n  }\n  /**\n   * Inject CSS string into element.\n   */\n  ;\n\n  _proto.deploy = function deploy() {\n    var sheet = this.sheet;\n    if (!sheet) return;\n\n    if (sheet.options.link) {\n      this.insertRules(sheet.rules);\n      return;\n    }\n\n    this.element.textContent = \"\\n\" + sheet.toString() + \"\\n\";\n  }\n  /**\n   * Insert RuleList into an element.\n   */\n  ;\n\n  _proto.insertRules = function insertRules(rules, nativeParent) {\n    for (var i = 0; i < rules.index.length; i++) {\n      this.insertRule(rules.index[i], i, nativeParent);\n    }\n  }\n  /**\n   * Insert a rule into element.\n   */\n  ;\n\n  _proto.insertRule = function insertRule(rule, index, nativeParent) {\n    if (nativeParent === void 0) {\n      nativeParent = this.element.sheet;\n    }\n\n    if (rule.rules) {\n      var parent = rule;\n      var latestNativeParent = nativeParent;\n\n      if (rule.type === 'conditional' || rule.type === 'keyframes') {\n        var _insertionIndex = getValidRuleInsertionIndex(nativeParent, index); // We need to render the container without children first.\n\n\n        latestNativeParent = _insertRule(nativeParent, parent.toString({\n          children: false\n        }), _insertionIndex);\n\n        if (latestNativeParent === false) {\n          return false;\n        }\n\n        this.refCssRule(rule, _insertionIndex, latestNativeParent);\n      }\n\n      this.insertRules(parent.rules, latestNativeParent);\n      return latestNativeParent;\n    }\n\n    var ruleStr = rule.toString();\n    if (!ruleStr) return false;\n    var insertionIndex = getValidRuleInsertionIndex(nativeParent, index);\n\n    var nativeRule = _insertRule(nativeParent, ruleStr, insertionIndex);\n\n    if (nativeRule === false) {\n      return false;\n    }\n\n    this.hasInsertedRules = true;\n    this.refCssRule(rule, insertionIndex, nativeRule);\n    return nativeRule;\n  };\n\n  _proto.refCssRule = function refCssRule(rule, index, cssRule) {\n    rule.renderable = cssRule; // We only want to reference the top level rules, deleteRule API doesn't support removing nested rules\n    // like rules inside media queries or keyframes\n\n    if (rule.options.parent instanceof StyleSheet) {\n      this.cssRules.splice(index, 0, cssRule);\n    }\n  }\n  /**\n   * Delete a rule.\n   */\n  ;\n\n  _proto.deleteRule = function deleteRule(cssRule) {\n    var sheet = this.element.sheet;\n    var index = this.indexOf(cssRule);\n    if (index === -1) return false;\n    sheet.deleteRule(index);\n    this.cssRules.splice(index, 1);\n    return true;\n  }\n  /**\n   * Get index of a CSS Rule.\n   */\n  ;\n\n  _proto.indexOf = function indexOf(cssRule) {\n    return this.cssRules.indexOf(cssRule);\n  }\n  /**\n   * Generate a new CSS rule and replace the existing one.\n   */\n  ;\n\n  _proto.replaceRule = function replaceRule(cssRule, rule) {\n    var index = this.indexOf(cssRule);\n    if (index === -1) return false;\n    this.element.sheet.deleteRule(index);\n    this.cssRules.splice(index, 1);\n    return this.insertRule(rule, index);\n  }\n  /**\n   * Get all rules elements.\n   */\n  ;\n\n  _proto.getRules = function getRules() {\n    return this.element.sheet.cssRules;\n  };\n\n  return DomRenderer;\n}();\n\nvar instanceCounter = 0;\n\nvar Jss =\n/*#__PURE__*/\nfunction () {\n  function Jss(options) {\n    this.id = instanceCounter++;\n    this.version = \"10.9.2\";\n    this.plugins = new PluginsRegistry();\n    this.options = {\n      id: {\n        minify: false\n      },\n      createGenerateId: createGenerateId,\n      Renderer: isInBrowser ? DomRenderer : null,\n      plugins: []\n    };\n    this.generateId = createGenerateId({\n      minify: false\n    });\n\n    for (var i = 0; i < plugins.length; i++) {\n      this.plugins.use(plugins[i], {\n        queue: 'internal'\n      });\n    }\n\n    this.setup(options);\n  }\n  /**\n   * Prepares various options, applies plugins.\n   * Should not be used twice on the same instance, because there is no plugins\n   * deduplication logic.\n   */\n\n\n  var _proto = Jss.prototype;\n\n  _proto.setup = function setup(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (options.createGenerateId) {\n      this.options.createGenerateId = options.createGenerateId;\n    }\n\n    if (options.id) {\n      this.options.id = _extends({}, this.options.id, options.id);\n    }\n\n    if (options.createGenerateId || options.id) {\n      this.generateId = this.options.createGenerateId(this.options.id);\n    }\n\n    if (options.insertionPoint != null) this.options.insertionPoint = options.insertionPoint;\n\n    if ('Renderer' in options) {\n      this.options.Renderer = options.Renderer;\n    } // eslint-disable-next-line prefer-spread\n\n\n    if (options.plugins) this.use.apply(this, options.plugins);\n    return this;\n  }\n  /**\n   * Create a Style Sheet.\n   */\n  ;\n\n  _proto.createStyleSheet = function createStyleSheet(styles, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _options = options,\n        index = _options.index;\n\n    if (typeof index !== 'number') {\n      index = sheets.index === 0 ? 0 : sheets.index + 1;\n    }\n\n    var sheet = new StyleSheet(styles, _extends({}, options, {\n      jss: this,\n      generateId: options.generateId || this.generateId,\n      insertionPoint: this.options.insertionPoint,\n      Renderer: this.options.Renderer,\n      index: index\n    }));\n    this.plugins.onProcessSheet(sheet);\n    return sheet;\n  }\n  /**\n   * Detach the Style Sheet and remove it from the registry.\n   */\n  ;\n\n  _proto.removeStyleSheet = function removeStyleSheet(sheet) {\n    sheet.detach();\n    sheets.remove(sheet);\n    return this;\n  }\n  /**\n   * Create a rule without a Style Sheet.\n   * [Deprecated] will be removed in the next major version.\n   */\n  ;\n\n  _proto.createRule = function createRule$1(name, style, options) {\n    if (style === void 0) {\n      style = {};\n    }\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    // Enable rule without name for inline styles.\n    if (typeof name === 'object') {\n      return this.createRule(undefined, name, style);\n    }\n\n    var ruleOptions = _extends({}, options, {\n      name: name,\n      jss: this,\n      Renderer: this.options.Renderer\n    });\n\n    if (!ruleOptions.generateId) ruleOptions.generateId = this.generateId;\n    if (!ruleOptions.classes) ruleOptions.classes = {};\n    if (!ruleOptions.keyframes) ruleOptions.keyframes = {};\n\n    var rule = createRule(name, style, ruleOptions);\n\n    if (rule) this.plugins.onProcessRule(rule);\n    return rule;\n  }\n  /**\n   * Register plugin. Passed function will be invoked with a rule instance.\n   */\n  ;\n\n  _proto.use = function use() {\n    var _this = this;\n\n    for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {\n      plugins[_key] = arguments[_key];\n    }\n\n    plugins.forEach(function (plugin) {\n      _this.plugins.use(plugin);\n    });\n    return this;\n  };\n\n  return Jss;\n}();\n\nvar createJss = function createJss(options) {\n  return new Jss(options);\n};\n\n/**\n * SheetsManager is like a WeakMap which is designed to count StyleSheet\n * instances and attach/detach automatically.\n * Used in react-jss.\n */\n\nvar SheetsManager =\n/*#__PURE__*/\nfunction () {\n  function SheetsManager() {\n    this.length = 0;\n    this.sheets = new WeakMap();\n  }\n\n  var _proto = SheetsManager.prototype;\n\n  _proto.get = function get(key) {\n    var entry = this.sheets.get(key);\n    return entry && entry.sheet;\n  };\n\n  _proto.add = function add(key, sheet) {\n    if (this.sheets.has(key)) return;\n    this.length++;\n    this.sheets.set(key, {\n      sheet: sheet,\n      refs: 0\n    });\n  };\n\n  _proto.manage = function manage(key) {\n    var entry = this.sheets.get(key);\n\n    if (entry) {\n      if (entry.refs === 0) {\n        entry.sheet.attach();\n      }\n\n      entry.refs++;\n      return entry.sheet;\n    }\n\n    warning(false, \"[JSS] SheetsManager: can't find sheet to manage\");\n    return undefined;\n  };\n\n  _proto.unmanage = function unmanage(key) {\n    var entry = this.sheets.get(key);\n\n    if (entry) {\n      if (entry.refs > 0) {\n        entry.refs--;\n        if (entry.refs === 0) entry.sheet.detach();\n      }\n    } else {\n      warning(false, \"SheetsManager: can't find sheet to unmanage\");\n    }\n  };\n\n  _createClass(SheetsManager, [{\n    key: \"size\",\n    get: function get() {\n      return this.length;\n    }\n  }]);\n\n  return SheetsManager;\n}();\n\n/**\n* Export a constant indicating if this browser has CSSTOM support.\n* https://developers.google.com/web/updates/2018/03/cssom\n*/\nvar hasCSSTOMSupport = typeof CSS === 'object' && CSS != null && 'number' in CSS;\n\n/**\n * Extracts a styles object with only props that contain function values.\n */\nfunction getDynamicStyles(styles) {\n  var to = null;\n\n  for (var key in styles) {\n    var value = styles[key];\n    var type = typeof value;\n\n    if (type === 'function') {\n      if (!to) to = {};\n      to[key] = value;\n    } else if (type === 'object' && value !== null && !Array.isArray(value)) {\n      var extracted = getDynamicStyles(value);\n\n      if (extracted) {\n        if (!to) to = {};\n        to[key] = extracted;\n      }\n    }\n  }\n\n  return to;\n}\n\n/**\n * A better abstraction over CSS.\n *\n * @copyright Oleg Isonen (Slobodskoi) / Isonen 2014-present\n * @website https://github.com/cssinjs/jss\n * @license MIT\n */\nvar index = createJss();\n\nexport default index;\nexport { RuleList, SheetsManager, SheetsRegistry, createJss as create, createGenerateId, createRule, getDynamicStyles, hasCSSTOMSupport, sheets, toCssValue };\n","/* Auto Generated Start */\nconst breakpoint = {\n    \"xxs\": 0,\n    \"xs\": 480,\n    \"s\": 760,\n    \"m\": 1000,\n    \"l\": 1300,\n    \"xl\": 1760,\n    \"xxl\": 1920\n};\nfunction mediaQueryMin(min) {\n    return `@media(min-width:${breakpoint[min]}px)`;\n}\nfunction mediaQueryMax(max) {\n    return `@media(max-width:${breakpoint[max] - 1}px)`;\n}\nfunction mediaQueryMinMax(min, max) {\n    return `${mediaQueryMin(min)} and (max-width:${breakpoint[max] - 1}px)`;\n}\n\nexport { mediaQueryMax, mediaQueryMin, mediaQueryMinMax };\n","'use strict'\n\n/**\n * The custom `sort` method for\n * for the [`css-mqpacker`](https://www.npmjs.com/package/css-mqpacker) or\n * [`pleeease`](https://www.npmjs.com/package/pleeease) which using `css-mqpacker`\n * or, perhaps, something else ))\n *\n * @module sort-css-media-queries\n * @author Oleg Dutchenko <dutchenko.o.wezom@gmail.com>\n * @version 1.5.0\n */\n\n// ----------------------------------------\n// Private\n// ----------------------------------------\n\nconst minMaxWidth = /(!?\\(\\s*min(-device-)?-width)(.|\\n)+\\(\\s*max(-device)?-width/i\nconst minWidth = /\\(\\s*min(-device)?-width/i\nconst maxMinWidth = /(!?\\(\\s*max(-device)?-width)(.|\\n)+\\(\\s*min(-device)?-width/i\nconst maxWidth = /\\(\\s*max(-device)?-width/i\n\nconst isMinWidth = _testQuery(minMaxWidth, maxMinWidth, minWidth)\nconst isMaxWidth = _testQuery(maxMinWidth, minMaxWidth, maxWidth)\n\nconst minMaxHeight = /(!?\\(\\s*min(-device)?-height)(.|\\n)+\\(\\s*max(-device)?-height/i\nconst minHeight = /\\(\\s*min(-device)?-height/i\nconst maxMinHeight = /(!?\\(\\s*max(-device)?-height)(.|\\n)+\\(\\s*min(-device)?-height/i\nconst maxHeight = /\\(\\s*max(-device)?-height/i\n\nconst isMinHeight = _testQuery(minMaxHeight, maxMinHeight, minHeight)\nconst isMaxHeight = _testQuery(maxMinHeight, minMaxHeight, maxHeight)\n\nconst isPrint = /print/i\nconst isPrintOnly = /^print$/i\n\nconst maxValue = Number.MAX_VALUE\n\n/**\n * Obtain the length of the media request in pixels.\n * Copy from original source `function inspectLength (length)`\n * {@link https://github.com/hail2u/node-css-mqpacker/blob/master/index.js#L58}\n * @private\n * @param {string} length\n * @return {number}\n */\nfunction _getQueryLength (length) {\n  length = /(-?\\d*\\.?\\d+)(ch|em|ex|px|rem)/.exec(length)\n\n  if (length === null) {\n    return maxValue\n  }\n\n  let number = length[1]\n  const unit = length[2]\n\n  switch (unit) {\n    case 'ch':\n      number = parseFloat(number) * 8.8984375\n      break\n\n    case 'em':\n    case 'rem':\n      number = parseFloat(number) * 16\n      break\n\n    case 'ex':\n      number = parseFloat(number) * 8.296875\n      break\n\n    case 'px':\n      number = parseFloat(number)\n      break\n  }\n\n  return +number\n}\n\n/**\n * Wrapper for creating test functions\n * @private\n * @param {RegExp} doubleTestTrue\n * @param {RegExp} doubleTestFalse\n * @param {RegExp} singleTest\n * @return {Function}\n */\nfunction _testQuery (doubleTestTrue, doubleTestFalse, singleTest) {\n  /**\n   * @param {string} query\n   * @return {boolean}\n   */\n  return function (query) {\n    if (doubleTestTrue.test(query)) {\n      return true\n    } else if (doubleTestFalse.test(query)) {\n      return false\n    }\n    return singleTest.test(query)\n  }\n}\n\n/**\n * @private\n * @param {string} a\n * @param {string} b\n * @return {number|null}\n */\nfunction _testIsPrint (a, b) {\n  const isPrintA = isPrint.test(a)\n  const isPrintOnlyA = isPrintOnly.test(a)\n\n  const isPrintB = isPrint.test(b)\n  const isPrintOnlyB = isPrintOnly.test(b)\n\n  if (isPrintA && isPrintB) {\n    if (!isPrintOnlyA && isPrintOnlyB) {\n      return 1\n    }\n    if (isPrintOnlyA && !isPrintOnlyB) {\n      return -1\n    }\n    return a.localeCompare(b)\n  }\n  if (isPrintA) {\n    return 1\n  }\n  if (isPrintB) {\n    return -1\n  }\n\n  return null\n}\n\n// ----------------------------------------\n// Public\n// ----------------------------------------\n\n/**\n * Sorting an array with media queries\n * according to the mobile-first methodology.\n * @param {string} a\n * @param {string} b\n * @return {number} 1 / 0 / -1\n */\nfunction sortCSSmq (a, b) {\n  const testIsPrint = _testIsPrint(a, b)\n  if (testIsPrint !== null) {\n    return testIsPrint\n  }\n\n  const minA = isMinWidth(a) || isMinHeight(a)\n  const maxA = isMaxWidth(a) || isMaxHeight(a)\n\n  const minB = isMinWidth(b) || isMinHeight(b)\n  const maxB = isMaxWidth(b) || isMaxHeight(b)\n\n  if (minA && maxB) {\n    return -1\n  }\n  if (maxA && minB) {\n    return 1\n  }\n\n  let lengthA = _getQueryLength(a)\n  let lengthB = _getQueryLength(b)\n\n  if (lengthA === maxValue && lengthB === maxValue) {\n    return a.localeCompare(b)\n  } else if (lengthA === maxValue) {\n    return 1\n  } else if (lengthB === maxValue) {\n    return -1\n  }\n\n  if (lengthA > lengthB) {\n    if (maxA) {\n      return -1\n    }\n    return 1\n  }\n\n  if (lengthA < lengthB) {\n    if (maxA) {\n      return 1\n    }\n    return -1\n  }\n\n  return a.localeCompare(b)\n}\n\n/**\n * Sorting an array with media queries\n * according to the desktop-first methodology.\n * @param {string} a\n * @param {string} b\n * @return {number} 1 / 0 / -1\n */\nsortCSSmq.desktopFirst = function (a, b) {\n  const testIsPrint = _testIsPrint(a, b)\n  if (testIsPrint !== null) {\n    return testIsPrint\n  }\n\n  const minA = isMinWidth(a) || isMinHeight(a)\n  const maxA = isMaxWidth(a) || isMaxHeight(a)\n\n  const minB = isMinWidth(b) || isMinHeight(b)\n  const maxB = isMaxWidth(b) || isMaxHeight(b)\n\n  if (minA && maxB) {\n    return 1\n  }\n  if (maxA && minB) {\n    return -1\n  }\n\n  const lengthA = _getQueryLength(a)\n  const lengthB = _getQueryLength(b)\n\n  if (lengthA === maxValue && lengthB === maxValue) {\n    return a.localeCompare(b)\n  } else if (lengthA === maxValue) {\n    return 1\n  } else if (lengthB === maxValue) {\n    return -1\n  }\n\n  if (lengthA > lengthB) {\n    if (maxA) {\n      return -1\n    }\n    return 1\n  }\n\n  if (lengthA < lengthB) {\n    if (maxA) {\n      return 1\n    }\n    return -1\n  }\n\n  return -(a.localeCompare(b))\n}\n\n// ----------------------------------------\n// Exports\n// ----------------------------------------\n\nmodule.exports = sortCSSmq\n","const fontLineHeight = 'calc(6px + 2.125ex)'; // float px values may render differently on different browsers\n\nexport { fontLineHeight };\n","const fontFamily = \"'Porsche Next','Arial Narrow',Arial,'Heiti SC',SimHei,sans-serif\";\n\nexport { fontFamily };\n","'use strict';\nvar $ = require('../internals/export');\nvar $reduce = require('../internals/array-reduce').left;\nvar arrayMethodIsStrict = require('../internals/array-method-is-strict');\nvar CHROME_VERSION = require('../internals/engine-v8-version');\nvar IS_NODE = require('../internals/engine-is-node');\n\nvar STRICT_METHOD = arrayMethodIsStrict('reduce');\n// Chrome 80-82 has a critical bug\n// https://bugs.chromium.org/p/chromium/issues/detail?id=1049982\nvar CHROME_BUG = !IS_NODE && CHROME_VERSION > 79 && CHROME_VERSION < 83;\n\n// `Array.prototype.reduce` method\n// https://tc39.es/ecma262/#sec-array.prototype.reduce\n$({ target: 'Array', proto: true, forced: !STRICT_METHOD || CHROME_BUG }, {\n  reduce: function reduce(callbackfn /* , initialValue */) {\n    var length = arguments.length;\n    return $reduce(this, callbackfn, length, length > 1 ? arguments[1] : undefined);\n  }\n});\n","import { fontBehavior } from '../../font/font-behavior.js';\nimport { fontFamily } from '../../font/font-family.js';\nimport { fontHyphenation } from '../../font/font-hyphenation.js';\nimport { fontLineHeight } from '../../font/font-line-height.js';\nimport { fontWeight } from '../../font/font-weight.js';\nimport { fontStyle } from '../../font/font-style.js';\nimport { fontVariant } from '../../font/font-variant.js';\n\nconst textLarge = {\n    font: `${fontStyle} ${fontVariant} ${fontWeight.regular} 2.25rem/${fontLineHeight} ${fontFamily}`,\n    ...fontBehavior,\n    ...fontHyphenation,\n};\n\nexport { textLarge };\n","'use strict';\n\nvar _tslib = require('./_virtual/_tslib.js');\nvar jss = require('jss');\nvar sortCSSmq = require('sort-css-media-queries');\n\nfunction _interopDefaultLegacy(e) {\n\treturn e && typeof e === 'object' && 'default' in e ? e : { default: e };\n}\n\nvar sortCSSmq__default = /*#__PURE__*/ _interopDefaultLegacy(sortCSSmq);\n\nfunction isPlainObject(sample) {\n\treturn (\n\t\tsample !== null && typeof sample === 'object' && Array.isArray(sample) === false\n\t);\n}\nvar UN_QUERIED = '__UN_QUERIED';\nfunction recursiveInnerAndGetQueries(pluginOptions, rules) {\n\tvar queries = {\n\t\tgroups: {},\n\t\tgroupsSortNames: []\n\t};\n\tfor (var index = 0; index < rules.length; index++) {\n\t\tvar rule = rules[index];\n\t\tvar query =\n\t\t\trule.type === 'conditional' && typeof rule.query === 'string'\n\t\t\t\t? rule.query\n\t\t\t\t: UN_QUERIED;\n\t\tif (!queries.groups.hasOwnProperty(query)) {\n\t\t\tqueries.groupsSortNames.push(query);\n\t\t\tqueries.groups[query] = [];\n\t\t}\n\t\tqueries.groups[query].push(index);\n\t\t// eslint-disable-next-line @typescript-eslint/no-use-before-define\n\t\trecursive(pluginOptions, rule);\n\t}\n\tqueries.groupsSortNames.sort(function (a, b) {\n\t\tvar aWeight = a === UN_QUERIED ? 0 : a.length;\n\t\tvar bWeight = b === UN_QUERIED ? 0 : b.length;\n\t\tif (aWeight > 0 && bWeight > 0) {\n\t\t\tif (pluginOptions.desktopFirst) {\n\t\t\t\treturn sortCSSmq__default['default'].desktopFirst(a, b);\n\t\t\t} else {\n\t\t\t\treturn sortCSSmq__default['default'](a, b);\n\t\t\t}\n\t\t} else {\n\t\t\treturn aWeight - bWeight;\n\t\t}\n\t});\n\treturn queries;\n}\nfunction recursive(pluginOptions, data) {\n\tif (isPlainObject(data) && data.rules instanceof jss.RuleList) {\n\t\tdata.rules.toString = function (options) {\n\t\t\tif (options === void 0) {\n\t\t\t\toptions = {};\n\t\t\t}\n\t\t\tvar str = '';\n\t\t\tvar sheet = this.options.sheet;\n\t\t\tvar link = sheet ? sheet.options.link : false;\n\t\t\tvar _a = recursiveInnerAndGetQueries(pluginOptions, this.index),\n\t\t\t\tgroups = _a.groups,\n\t\t\t\tgroupsSortNames = _a.groupsSortNames;\n\t\t\tfor (var i = 0; i < groupsSortNames.length; i++) {\n\t\t\t\tvar groupName = groupsSortNames[i];\n\t\t\t\tvar group = groups[groupsSortNames[i]];\n\t\t\t\tif (groupName !== UN_QUERIED && pluginOptions.combineMediaQueries) {\n\t\t\t\t\tstr += '\\n' + groupName + ' {';\n\t\t\t\t\tfor (var i_1 = 0; i_1 < group.length; i_1++) {\n\t\t\t\t\t\tvar rule = this.index[group[i_1]];\n\t\t\t\t\t\tvar css = rule.rules.toString(\n\t\t\t\t\t\t\t_tslib.__assign(_tslib.__assign({}, options), {\n\t\t\t\t\t\t\t\tindent: (options.indent || 0) + 1\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (!css && !link) continue;\n\t\t\t\t\t\tif (str) str += '\\n';\n\t\t\t\t\t\tstr += css;\n\t\t\t\t\t}\n\t\t\t\t\tstr += '\\n}\\n';\n\t\t\t\t} else {\n\t\t\t\t\tfor (var i_2 = 0; i_2 < group.length; i_2++) {\n\t\t\t\t\t\tvar rule = this.index[group[i_2]];\n\t\t\t\t\t\tvar css = rule.toString(options);\n\t\t\t\t\t\tif (!css && !link) continue;\n\t\t\t\t\t\tif (str) str += '\\n';\n\t\t\t\t\t\tstr += css;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn str;\n\t\t};\n\t}\n}\nfunction jssCombineAndSortMQ(options) {\n\tif (options === void 0) {\n\t\toptions = {};\n\t}\n\treturn {\n\t\tonProcessSheet: function (sheet) {\n\t\t\trecursive(options, sheet);\n\t\t}\n\t};\n}\n\nmodule.exports = jssCombineAndSortMQ;\n","import { fontBehavior } from '../../font/font-behavior.js';\nimport { fontFamily } from '../../font/font-family.js';\nimport { fontHyphenation } from '../../font/font-hyphenation.js';\nimport { fontLineHeight } from '../../font/font-line-height.js';\nimport { fontWeight } from '../../font/font-weight.js';\nimport { fontStyle } from '../../font/font-style.js';\nimport { fontVariant } from '../../font/font-variant.js';\n\nconst textMedium = {\n    font: `${fontStyle} ${fontVariant} ${fontWeight.regular} 1.5rem/${fontLineHeight} ${fontFamily}`,\n    ...fontBehavior,\n    ...fontHyphenation,\n};\n\nexport { textMedium };\n","import type { BreakpointCustomizable, TextSize } from '../../types';\nimport { getHTMLElement } from '../../utils';\n\nexport const HEADLINE_VARIANTS = [\n  'large-title',\n  'headline-1',\n  'headline-2',\n  'headline-3',\n  'headline-4',\n  'headline-5',\n] as const;\n\nexport type VariantType = typeof HEADLINE_VARIANTS[number];\n\ntype HeadlineVariantCustom = Exclude<BreakpointCustomizable<TextSize>, TextSize>;\n\nexport type HeadlineVariant = VariantType | HeadlineVariantCustom | Extract<TextSize, 'inherit'>;\n\nexport const HEADLINE_TAGS = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] as const;\nexport type HeadlineTag = typeof HEADLINE_TAGS[number];\n\nexport const isVariantType = (variant: HeadlineVariant): boolean => {\n  return HEADLINE_VARIANTS.includes(variant as VariantType);\n};\n\nexport const hasSlottedHeadlineTag = (host: HTMLElement): boolean => {\n  // TODO: needs to be direct and only child\n  const el = getHTMLElement(host, ':first-child');\n  return el?.matches('h1, h2, h3, h4, h5, h6');\n};\n\nconst variantToTagMap: { [key in VariantType]: string } = {\n  'large-title': 'h1',\n  'headline-1': 'h1',\n  'headline-2': 'h2',\n  'headline-3': 'h3',\n  'headline-4': 'h4',\n  'headline-5': 'h5',\n};\n\nexport const getHeadlineTagName = (host: HTMLElement, variant?: HeadlineVariant, tag?: HeadlineTag): string => {\n  if (hasSlottedHeadlineTag(host)) {\n    return 'div';\n  } else if (tag) {\n    return tag;\n  } else if (!isVariantType(variant)) {\n    return 'h1';\n  } else {\n    return variantToTagMap[variant as VariantType];\n  }\n};\n","/* eslint-disable prefer-arrow/prefer-arrow-functions */\nimport type { HTMLElementOrShadowRoot } from './dom-types';\n\n// prettier-ignore\nexport function getHTMLElement<K extends keyof HTMLElementTagNameMap>(element: HTMLElementOrShadowRoot, selector: K): HTMLElementTagNameMap[K] | null;\n// prettier-ignore\nexport function getHTMLElement<E extends Element = Element>(element: HTMLElementOrShadowRoot, selector: string): E | null;\nexport function getHTMLElement(element: HTMLElementOrShadowRoot, selector: string): any {\n  return element?.querySelector(selector);\n}\n","export const transformSelectorToDirectChildSelector = (selector: string): string =>\n  selector\n    .split(',')\n    .map((part) => ':scope>' + part)\n    .join();\n","/* eslint-disable prefer-arrow/prefer-arrow-functions */\nimport type { HTMLElementOrShadowRoot } from './dom-types';\n\n// prettier-ignore\nexport function getHTMLElements<K extends keyof HTMLElementTagNameMap>(element: HTMLElementOrShadowRoot, selector: K): HTMLElementTagNameMap[K][];\n// prettier-ignore\nexport function getHTMLElements<E extends Element = Element>(element: HTMLElementOrShadowRoot, selector: string): E[];\nexport function getHTMLElements(element: HTMLElementOrShadowRoot, selector: string): any {\n  return element ? Array.from(element.querySelectorAll(selector)) : [];\n}\n","/* eslint-disable prefer-arrow/prefer-arrow-functions */\nimport { getHTMLElements } from './getHTMLElements';\nimport { transformSelectorToDirectChildSelector } from './transformSelectorToDirectChildSelector';\n\n// prettier-ignore\nexport function getDirectChildHTMLElements<K extends keyof HTMLElementTagNameMap>(element: HTMLElement, selector: K): HTMLElementTagNameMap[K][];\n// prettier-ignore\nexport function getDirectChildHTMLElements<E extends Element = Element>(element: HTMLElement, selector: string): E[];\nexport function getDirectChildHTMLElements(element: HTMLElement, selector: string): any {\n  // querySelector(All) doesn't work with :scope pseudo class and comma separator in jsdom, yet\n  // https://github.com/jsdom/jsdom/issues/3141\n  // therefore we got a workaround so it works nicely when consumed from jsdom-polyfill package\n  return transformSelectorToDirectChildSelector(selector)\n    .split(',')\n    .map((sel) => getHTMLElements(element, sel))\n    .flat(); // might contain duplicates\n}\n","import type { HTMLElementOrShadowRoot } from './dom-types';\nimport { getHTMLElement } from './getHTMLElement';\n\nexport const getSlotTextContent = (el: HTMLElementOrShadowRoot, slotName: string): string =>\n  getHTMLElement(el, `[slot=\"${slotName}\"]`)?.textContent;\n","import { getHTMLElement } from './getHTMLElement';\nimport type { HTMLElementOrShadowRoot } from './dom-types';\n\nexport const hasNamedSlot = (el: HTMLElementOrShadowRoot, slotName: string): boolean =>\n  !!getHTMLElement(el, `[slot=\"${slotName}\"]`);\n","import type { TagName } from '@porsche-design-system/shared';\nimport { getTagNameWithoutPrefix } from '..';\n\nexport const isParentOfKind = (element: HTMLElement, tagName: TagName): boolean => {\n  const { parentElement } = element;\n  return parentElement && getTagNameWithoutPrefix(parentElement) === tagName;\n};\n","export const hasWindow = typeof window !== 'undefined';\n","import { hasWindow } from './has-window';\n\nexport const attributeMutationMap: Map<Node, () => void> = new Map();\n\nconst attributeObserver =\n  hasWindow &&\n  new MutationObserver((mutations) => {\n    mutations\n      // reduce array to only entries that have really a changed value\n      .filter((mutation) => mutation.oldValue !== (mutation.target as HTMLElement).getAttribute(mutation.attributeName))\n      // remove duplicates so we execute callback only once per node\n      .filter((mutation, idx, arr) => arr.findIndex((m) => m.target === mutation.target) === idx)\n      .forEach((mutation) => attributeMutationMap.get(mutation.target)?.());\n  });\n\nexport const observeAttributes = <T extends HTMLElement, K = keyof T>(\n  node: T,\n  attributes: Lowercase<K extends string ? K : string>[],\n  callback: () => void\n): void => {\n  // node might not be defined in connectedCallback\n  if (node) {\n    attributeMutationMap.set(node, callback);\n    attributeObserver.observe(node, { attributeFilter: attributes as string[], attributeOldValue: true });\n  }\n};\n\nexport const unobserveAttributes = <T extends HTMLElement>(node: T): void => {\n  attributeMutationMap.delete(node);\n};\n","// TODO: resolve overlap with Breakpoint type from utilities package\nexport const BREAKPOINTS = ['base', 'xs', 's', 'm', 'l', 'xl'] as const;\nexport type BreakpointKey = typeof BREAKPOINTS[number];\nexport type BreakpointValues<T> = {\n  [key in BreakpointKey]?: T;\n} & {\n  base: T;\n};\n\n// string is needed in order to pass and parse objects via prop decorator\nexport type BreakpointCustomizable<T> = T | BreakpointValues<T> | string;\n\nexport type BreakpointValue = string | number | boolean;\n\nexport const parseJSON = (\n  prop: BreakpointCustomizable<BreakpointValue>\n): BreakpointValues<BreakpointValue> | BreakpointValue => {\n  if (typeof prop === 'string') {\n    try {\n      // prop is potentially JSON parsable string, e.g. \"{ base: 'block', l: 'inline' }\" or \"true\" or \"false\"\n      return JSON.parse(\n        prop\n          .replace(/'/g, '\"') // convert single quotes to double quotes\n          .replace(/[\\s\"]?([a-z]+)[\\s\"]?:([^//])/g, '\"$1\":$2') // wrap keys in double quotes if they don't have them but ignore potential urls\n      );\n    } catch {\n      // prop is string, e.g. \"block\" or \"inline\"\n      return prop;\n    }\n  } else {\n    // prop is object, e.g. { base: 'block', l: 'inline' } or number, e.g. 123 or boolean, e.g. true\n    return prop;\n  }\n};\n","const breakpoint = {\n    xxs: '0px',\n    xs: '480px',\n    s: '760px',\n    m: '1000px',\n    l: '1300px',\n    xl: '1760px',\n    xxl: '1920px', // TODO: xxl missing in breakpoint customizable\n};\n\nexport { breakpoint };\n","import { breakpoint } from '@porsche-design-system/utilities-v2';\nimport type { Breakpoint } from '@porsche-design-system/utilities-v2';\nimport { hasWindow } from './has-window';\n\nexport const mediaQueries = Object.entries(breakpoint)\n  .filter(([key]: [Breakpoint, string]) => key !== 'xxl')\n  .map(([, val]) => `(min-width:${val})`);\n\nexport let mediaQueryLists = hasWindow && window.matchMedia ? mediaQueries.map(window.matchMedia) : [];\n\n// for unit tests\nexport const overrideMediaQueryLists = (override: MediaQueryList[]): void => {\n  mediaQueryLists = override;\n};\n\nexport const breakpointChangeCallbackMap: Map<HTMLElement, () => void> = new Map();\n\nexport const observeBreakpointChange = (node: HTMLElement, callback: () => void): void => {\n  // node might not be defined in connectedCallback\n  if (node) {\n    if (breakpointChangeCallbackMap.size === 0) {\n      mediaQueryLists.forEach((mediaQueryList) => {\n        mediaQueryList.addEventListener('change', handleBreakpointChange);\n      });\n    }\n    breakpointChangeCallbackMap.set(node, callback);\n  }\n};\n\nexport const unobserveBreakpointChange = (node: HTMLElement): void => {\n  breakpointChangeCallbackMap.delete(node);\n  if (breakpointChangeCallbackMap.size === 0) {\n    mediaQueryLists.forEach((mediaQueryList) => {\n      // matchmedia-polyfill only implements removeListener\n      mediaQueryList.removeEventListener?.('change', handleBreakpointChange);\n    });\n  }\n};\n\nexport const handleBreakpointChange = (): void => {\n  breakpointChangeCallbackMap.forEach((breakpointChangeCallback) => {\n    breakpointChangeCallback();\n  });\n};\n","import type { Breakpoint } from '@porsche-design-system/utilities-v2';\nimport { breakpoint } from '@porsche-design-system/utilities-v2';\nimport { mediaQueryLists } from './breakpoint-observer';\nimport type { BreakpointCustomizable, BreakpointKey } from './breakpoint-customizable';\nimport { BREAKPOINTS } from './breakpoint-customizable';\n\nexport const flippedBreakpoint = Object.entries(breakpoint).reduce(\n  (result, [key, val]) => ({ ...result, [val]: key }),\n  {} as Record<string, Breakpoint>\n);\n\nexport const getCurrentBreakpointKey = (): BreakpointKey => {\n  const lastMatchingMediaQuery = mediaQueryLists\n    .filter((item) => item.matches)\n    .map((item) => item.media)\n    .pop();\n\n  const matchingBreakpoint = flippedBreakpoint[/\\d+px/.exec(lastMatchingMediaQuery)[0]];\n  return matchingBreakpoint === 'xxs' ? 'base' : (matchingBreakpoint as BreakpointKey);\n};\n\nexport const getCurrentMatchingBreakpointValue = <T>(data: BreakpointCustomizable<T>): T => {\n  if (typeof data === 'object') {\n    const currentBreakpoint = getCurrentBreakpointKey();\n\n    const result = data[currentBreakpoint];\n    if (result) {\n      return result;\n    } else {\n      const valuesArray = BREAKPOINTS.map((bp) => data[bp]);\n      // fill gaps with value from preceding breakpoint\n      valuesArray.forEach((val, i, arr) => {\n        if (val === undefined) {\n          arr[i] = arr[i - 1];\n        }\n      });\n      return valuesArray[BREAKPOINTS.indexOf(currentBreakpoint)];\n    }\n  } else {\n    return data as T;\n  }\n};\n","import { hasWindow } from './has-window';\n\nexport const childrenMutationMap: Map<Node, () => void> = new Map();\n\nconst getObservedNode = (mutatedNode: Node): Node =>\n  childrenMutationMap.has(mutatedNode) ? mutatedNode : getObservedNode(mutatedNode.parentNode);\n\nconst childrenObserver =\n  hasWindow &&\n  new MutationObserver((mutations) => {\n    mutations\n      // remove duplicates so we execute callback only once per node\n      .filter((mutation, idx, arr) => arr.findIndex((m) => m.target === mutation.target) === idx)\n      .map((mutation) => getObservedNode(mutation.target)) // recursively find root node that is initially observed\n      .forEach((node) => childrenMutationMap.get(node)());\n  });\n\nexport const observeChildren = <T extends HTMLElement, K = keyof T>(\n  node: T,\n  callback: () => void,\n  attributes?: Lowercase<K extends string ? K : string>[]\n): void => {\n  // node might not be defined in connectedCallback\n  if (node) {\n    childrenMutationMap.set(node, callback);\n    childrenObserver.observe(node, {\n      childList: true,\n      subtree: true,\n      characterData: true,\n      attributeFilter: attributes,\n    });\n  }\n};\n\nexport const unobserveChildren = <T extends HTMLElement>(node: T): void => {\n  childrenMutationMap.delete(node);\n};\n","/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)\n *                                            are most useful.\n * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,\n *                                            as-is, to `callback` when the throttled-function is executed.\n * @param {object} [options] -              An object to configure options.\n * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds\n *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed\n *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for\n *                                            `delay` milliseconds, the internal counter is reset).\n * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback\n *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that\n *                                            callback will never executed if both noLeading = true and noTrailing = true.\n * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is\n *                                            false (at end), schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function} A new, throttled, function.\n */\nfunction throttle (delay, callback, options) {\n  var _ref = options || {},\n      _ref$noTrailing = _ref.noTrailing,\n      noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing,\n      _ref$noLeading = _ref.noLeading,\n      noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading,\n      _ref$debounceMode = _ref.debounceMode,\n      debounceMode = _ref$debounceMode === void 0 ? undefined : _ref$debounceMode;\n  /*\n   * After wrapper has stopped being called, this timeout ensures that\n   * `callback` is executed at the proper times in `throttle` and `end`\n   * debounce modes.\n   */\n\n\n  var timeoutID;\n  var cancelled = false; // Keep track of the last time `callback` was executed.\n\n  var lastExec = 0; // Function to clear existing timeout\n\n  function clearExistingTimeout() {\n    if (timeoutID) {\n      clearTimeout(timeoutID);\n    }\n  } // Function to cancel next exec\n\n\n  function cancel(options) {\n    var _ref2 = options || {},\n        _ref2$upcomingOnly = _ref2.upcomingOnly,\n        upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;\n\n    clearExistingTimeout();\n    cancelled = !upcomingOnly;\n  }\n  /*\n   * The `wrapper` function encapsulates all of the throttling / debouncing\n   * functionality and when executed will limit the rate at which `callback`\n   * is executed.\n   */\n\n\n  function wrapper() {\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n      arguments_[_key] = arguments[_key];\n    }\n\n    var self = this;\n    var elapsed = Date.now() - lastExec;\n\n    if (cancelled) {\n      return;\n    } // Execute `callback` and update the `lastExec` timestamp.\n\n\n    function exec() {\n      lastExec = Date.now();\n      callback.apply(self, arguments_);\n    }\n    /*\n     * If `debounceMode` is true (at begin) this is used to clear the flag\n     * to allow future `callback` executions.\n     */\n\n\n    function clear() {\n      timeoutID = undefined;\n    }\n\n    if (!noLeading && debounceMode && !timeoutID) {\n      /*\n       * Since `wrapper` is being called for the first time and\n       * `debounceMode` is true (at begin), execute `callback`\n       * and noLeading != true.\n       */\n      exec();\n    }\n\n    clearExistingTimeout();\n\n    if (debounceMode === undefined && elapsed > delay) {\n      if (noLeading) {\n        /*\n         * In throttle mode with noLeading, if `delay` time has\n         * been exceeded, update `lastExec` and schedule `callback`\n         * to execute after `delay` ms.\n         */\n        lastExec = Date.now();\n\n        if (!noTrailing) {\n          timeoutID = setTimeout(debounceMode ? clear : exec, delay);\n        }\n      } else {\n        /*\n         * In throttle mode without noLeading, if `delay` time has been exceeded, execute\n         * `callback`.\n         */\n        exec();\n      }\n    } else if (noTrailing !== true) {\n      /*\n       * In trailing throttle mode, since `delay` time has not been\n       * exceeded, schedule `callback` to execute `delay` ms after most\n       * recent execution.\n       *\n       * If `debounceMode` is true (at begin), schedule `clear` to execute\n       * after `delay` ms.\n       *\n       * If `debounceMode` is false (at end), schedule `callback` to\n       * execute after `delay` ms.\n       */\n      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);\n    }\n  }\n\n  wrapper.cancel = cancel; // Return the wrapper function.\n\n  return wrapper;\n}\n\n/* eslint-disable no-undefined */\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                        to `callback` when the debounced-function is executed.\n * @param {object} [options] -           An object to configure options.\n * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n *\n * @returns {Function} A new, debounced function.\n */\n\nfunction debounce (delay, callback, options) {\n  var _ref = options || {},\n      _ref$atBegin = _ref.atBegin,\n      atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;\n\n  return throttle(delay, callback, {\n    debounceMode: atBegin !== false\n  });\n}\n\nexport { debounce, throttle };\n//# sourceMappingURL=index.js.map\n","import { debounce } from 'throttle-debounce';\n\nexport const hasCounter = (el: HTMLTextAreaElement | HTMLInputElement): boolean => el.maxLength >= 0;\n\nexport const setCounterInnerHtml = (el: HTMLTextAreaElement | HTMLInputElement, counterElement: HTMLElement): void => {\n  counterElement.innerText = `${el.value.length}/${el.maxLength}`;\n};\n\nexport const setAriaElementInnerHtml = debounce(\n  800,\n  (el: HTMLTextAreaElement | HTMLInputElement,\n   ariaElement: HTMLSpanElement): void => {\n    ariaElement.innerText = `You have ${el.maxLength - el.value.length} out of ${el.maxLength} characters left`;\n  }\n);\n\nexport const addInputEventListenerForCounter = (\n  input: HTMLTextAreaElement | HTMLInputElement,\n  characterCountElement: HTMLSpanElement,\n  counterElement?: HTMLSpanElement,\n  inputChangeCallback?: () => void\n): void => {\n  if (counterElement) {\n    setCounterInnerHtml(input, counterElement); // initial value\n  }\n  setAriaElementInnerHtml(input, characterCountElement); // initial value\n\n  input.addEventListener('input', (e: Event & { target: HTMLTextAreaElement | HTMLInputElement }) => {\n    if (counterElement) {\n      setCounterInnerHtml(e.target, counterElement);\n    }\n    setAriaElementInnerHtml(e.target, characterCountElement);\n    if (inputChangeCallback) {\n      inputChangeCallback();\n    }\n  });\n};\n","const FONT_FACE_CDN_URL = (typeof window !== 'undefined' && window.PORSCHE_DESIGN_SYSTEM_CDN === 'cn' ? 'https://cdn.ui.porsche.cn/porsche-design-system/styles/font-face.min.cn.dac5fec2a6a8e4d91888876cb67b5f70.css' : 'https://cdn.ui.porsche.com/porsche-design-system/styles/font-face.min.60af47c330a2eae4dc0f4129b2b2878e.css');\n\nexport { FONT_FACE_CDN_URL };\n","/* eslint-disable no-var, prefer-template */\nvar uppercasePattern = /[A-Z]/g\nvar msPattern = /^ms-/\nvar cache = {}\n\nfunction toHyphenLower(match) {\n  return '-' + match.toLowerCase()\n}\n\nfunction hyphenateStyleName(name) {\n  if (cache.hasOwnProperty(name)) {\n    return cache[name]\n  }\n\n  var hName = name.replace(uppercasePattern, toHyphenLower)\n  return (cache[name] = msPattern.test(hName) ? '-' + hName : hName)\n}\n\nexport default hyphenateStyleName\n","import hyphenate from 'hyphenate-style-name';\n\n/**\n * Convert camel cased property names to dash separated.\n */\n\nfunction convertCase(style) {\n  var converted = {};\n\n  for (var prop in style) {\n    var key = prop.indexOf('--') === 0 ? prop : hyphenate(prop);\n    converted[key] = style[prop];\n  }\n\n  if (style.fallbacks) {\n    if (Array.isArray(style.fallbacks)) converted.fallbacks = style.fallbacks.map(convertCase);else converted.fallbacks = convertCase(style.fallbacks);\n  }\n\n  return converted;\n}\n/**\n * Allow camel cased property names by converting them back to dasherized.\n */\n\n\nfunction camelCase() {\n  function onProcessStyle(style) {\n    if (Array.isArray(style)) {\n      // Handle rules like @font-face, which can have multiple styles in an array\n      for (var index = 0; index < style.length; index++) {\n        style[index] = convertCase(style[index]);\n      }\n\n      return style;\n    }\n\n    return convertCase(style);\n  }\n\n  function onChangeValue(value, prop, rule) {\n    if (prop.indexOf('--') === 0) {\n      return value;\n    }\n\n    var hyphenatedProp = hyphenate(prop); // There was no camel case in place\n\n    if (prop === hyphenatedProp) return value;\n    rule.prop(hyphenatedProp, value); // Core will ignore that property value we set the proper one above.\n\n    return null;\n  }\n\n  return {\n    onProcessStyle: onProcessStyle,\n    onChangeValue: onChangeValue\n  };\n}\n\nexport default camelCase;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport { RuleList } from 'jss';\n\nvar at = '@global';\nvar atPrefix = '@global ';\n\nvar GlobalContainerRule =\n/*#__PURE__*/\nfunction () {\n  function GlobalContainerRule(key, styles, options) {\n    this.type = 'global';\n    this.at = at;\n    this.isProcessed = false;\n    this.key = key;\n    this.options = options;\n    this.rules = new RuleList(_extends({}, options, {\n      parent: this\n    }));\n\n    for (var selector in styles) {\n      this.rules.add(selector, styles[selector]);\n    }\n\n    this.rules.process();\n  }\n  /**\n   * Get a rule.\n   */\n\n\n  var _proto = GlobalContainerRule.prototype;\n\n  _proto.getRule = function getRule(name) {\n    return this.rules.get(name);\n  }\n  /**\n   * Create and register rule, run plugins.\n   */\n  ;\n\n  _proto.addRule = function addRule(name, style, options) {\n    var rule = this.rules.add(name, style, options);\n    if (rule) this.options.jss.plugins.onProcessRule(rule);\n    return rule;\n  }\n  /**\n   * Replace rule, run plugins.\n   */\n  ;\n\n  _proto.replaceRule = function replaceRule(name, style, options) {\n    var newRule = this.rules.replace(name, style, options);\n    if (newRule) this.options.jss.plugins.onProcessRule(newRule);\n    return newRule;\n  }\n  /**\n   * Get index of a rule.\n   */\n  ;\n\n  _proto.indexOf = function indexOf(rule) {\n    return this.rules.indexOf(rule);\n  }\n  /**\n   * Generates a CSS string.\n   */\n  ;\n\n  _proto.toString = function toString(options) {\n    return this.rules.toString(options);\n  };\n\n  return GlobalContainerRule;\n}();\n\nvar GlobalPrefixedRule =\n/*#__PURE__*/\nfunction () {\n  function GlobalPrefixedRule(key, style, options) {\n    this.type = 'global';\n    this.at = at;\n    this.isProcessed = false;\n    this.key = key;\n    this.options = options;\n    var selector = key.substr(atPrefix.length);\n    this.rule = options.jss.createRule(selector, style, _extends({}, options, {\n      parent: this\n    }));\n  }\n\n  var _proto2 = GlobalPrefixedRule.prototype;\n\n  _proto2.toString = function toString(options) {\n    return this.rule ? this.rule.toString(options) : '';\n  };\n\n  return GlobalPrefixedRule;\n}();\n\nvar separatorRegExp = /\\s*,\\s*/g;\n\nfunction addScope(selector, scope) {\n  var parts = selector.split(separatorRegExp);\n  var scoped = '';\n\n  for (var i = 0; i < parts.length; i++) {\n    scoped += scope + \" \" + parts[i].trim();\n    if (parts[i + 1]) scoped += ', ';\n  }\n\n  return scoped;\n}\n\nfunction handleNestedGlobalContainerRule(rule, sheet) {\n  var options = rule.options,\n      style = rule.style;\n  var rules = style ? style[at] : null;\n  if (!rules) return;\n\n  for (var name in rules) {\n    sheet.addRule(name, rules[name], _extends({}, options, {\n      selector: addScope(name, rule.selector)\n    }));\n  }\n\n  delete style[at];\n}\n\nfunction handlePrefixedGlobalRule(rule, sheet) {\n  var options = rule.options,\n      style = rule.style;\n\n  for (var prop in style) {\n    if (prop[0] !== '@' || prop.substr(0, at.length) !== at) continue;\n    var selector = addScope(prop.substr(at.length), rule.selector);\n    sheet.addRule(selector, style[prop], _extends({}, options, {\n      selector: selector\n    }));\n    delete style[prop];\n  }\n}\n/**\n * Convert nested rules to separate, remove them from original styles.\n */\n\n\nfunction jssGlobal() {\n  function onCreateRule(name, styles, options) {\n    if (!name) return null;\n\n    if (name === at) {\n      return new GlobalContainerRule(name, styles, options);\n    }\n\n    if (name[0] === '@' && name.substr(0, atPrefix.length) === atPrefix) {\n      return new GlobalPrefixedRule(name, styles, options);\n    }\n\n    var parent = options.parent;\n\n    if (parent) {\n      if (parent.type === 'global' || parent.options.parent && parent.options.parent.type === 'global') {\n        options.scoped = false;\n      }\n    }\n\n    if (!options.selector && options.scoped === false) {\n      options.selector = name;\n    }\n\n    return null;\n  }\n\n  function onProcessRule(rule, sheet) {\n    if (rule.type !== 'style' || !sheet) return;\n    handleNestedGlobalContainerRule(rule, sheet);\n    handlePrefixedGlobalRule(rule, sheet);\n  }\n\n  return {\n    onCreateRule: onCreateRule,\n    onProcessRule: onProcessRule\n  };\n}\n\nexport default jssGlobal;\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport warning from 'tiny-warning';\n\nvar separatorRegExp = /\\s*,\\s*/g;\nvar parentRegExp = /&/g;\nvar refRegExp = /\\$([\\w-]+)/g;\n/**\n * Convert nested rules to separate, remove them from original styles.\n */\n\nfunction jssNested() {\n  // Get a function to be used for $ref replacement.\n  function getReplaceRef(container, sheet) {\n    return function (match, key) {\n      var rule = container.getRule(key) || sheet && sheet.getRule(key);\n\n      if (rule) {\n        return rule.selector;\n      }\n\n      process.env.NODE_ENV !== \"production\" ? warning(false, \"[JSS] Could not find the referenced rule \\\"\" + key + \"\\\" in \\\"\" + (container.options.meta || container.toString()) + \"\\\".\") : void 0;\n      return key;\n    };\n  }\n\n  function replaceParentRefs(nestedProp, parentProp) {\n    var parentSelectors = parentProp.split(separatorRegExp);\n    var nestedSelectors = nestedProp.split(separatorRegExp);\n    var result = '';\n\n    for (var i = 0; i < parentSelectors.length; i++) {\n      var parent = parentSelectors[i];\n\n      for (var j = 0; j < nestedSelectors.length; j++) {\n        var nested = nestedSelectors[j];\n        if (result) result += ', '; // Replace all & by the parent or prefix & with the parent.\n\n        result += nested.indexOf('&') !== -1 ? nested.replace(parentRegExp, parent) : parent + \" \" + nested;\n      }\n    }\n\n    return result;\n  }\n\n  function getOptions(rule, container, prevOptions) {\n    // Options has been already created, now we only increase index.\n    if (prevOptions) return _extends({}, prevOptions, {\n      index: prevOptions.index + 1\n    });\n    var nestingLevel = rule.options.nestingLevel;\n    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;\n\n    var options = _extends({}, rule.options, {\n      nestingLevel: nestingLevel,\n      index: container.indexOf(rule) + 1 // We don't need the parent name to be set options for chlid.\n\n    });\n\n    delete options.name;\n    return options;\n  }\n\n  function onProcessStyle(style, rule, sheet) {\n    if (rule.type !== 'style') return style;\n    var styleRule = rule;\n    var container = styleRule.options.parent;\n    var options;\n    var replaceRef;\n\n    for (var prop in style) {\n      var isNested = prop.indexOf('&') !== -1;\n      var isNestedConditional = prop[0] === '@';\n      if (!isNested && !isNestedConditional) continue;\n      options = getOptions(styleRule, container, options);\n\n      if (isNested) {\n        var selector = replaceParentRefs(prop, styleRule.selector); // Lazily create the ref replacer function just once for\n        // all nested rules within the sheet.\n\n        if (!replaceRef) replaceRef = getReplaceRef(container, sheet); // Replace all $refs.\n\n        selector = selector.replace(refRegExp, replaceRef);\n        var name = styleRule.key + \"-\" + prop;\n\n        if ('replaceRule' in container) {\n          // for backward compatibility\n          container.replaceRule(name, style[prop], _extends({}, options, {\n            selector: selector\n          }));\n        } else {\n          container.addRule(name, style[prop], _extends({}, options, {\n            selector: selector\n          }));\n        }\n      } else if (isNestedConditional) {\n        // Place conditional right after the parent rule to ensure right ordering.\n        container.addRule(prop, {}, options).addRule(styleRule.key, style[prop], {\n          selector: styleRule.selector\n        });\n      }\n\n      delete style[prop];\n    }\n\n    return style;\n  }\n\n  return {\n    onProcessStyle: onProcessStyle\n  };\n}\n\nexport default jssNested;\n","import type { TagName } from '@porsche-design-system/shared';\nimport type { BreakpointCustomizable } from './breakpoint-customizable';\nimport type { JssStyle, Styles } from 'jss';\nimport { create } from 'jss';\nimport jssPluginCamelCase from 'jss-plugin-camel-case';\nimport jssPluginGlobal from 'jss-plugin-global';\nimport jssPluginNested from 'jss-plugin-nested';\nimport jssPluginSortMediaQueries from 'jss-plugin-sort-css-media-queries';\nimport { mediaQueryMin } from '@porsche-design-system/utilities-v2';\nimport type { Breakpoint } from '@porsche-design-system/utilities-v2';\nimport { parseJSON } from './breakpoint-customizable';\nimport { getShadowRootHTMLElement } from './dom';\nimport { addImportantToEachRule } from '../styles';\nimport { getTagName, getTagNameWithoutPrefix } from '.';\n\n// NOTE: handpicked selection of plugins from jss-preset-default\nconst jss = create({\n  plugins: [\n    jssPluginGlobal(),\n    jssPluginNested(),\n    jssPluginCamelCase(),\n    jssPluginSortMediaQueries({ combineMediaQueries: true }),\n  ],\n});\n\nexport const getCss = (jssStyles: Styles): string =>\n  jss\n    .createStyleSheet(jssStyles, {\n      generateId: (rule) => rule.key,\n    })\n    .toString();\n\nexport const supportsConstructableStylesheets = (): boolean => {\n  try {\n    return typeof new CSSStyleSheet().replaceSync === 'function';\n  } catch {\n    return false;\n  }\n};\n\n// determine it once\nconst hasConstructableStylesheetSupport = supportsConstructableStylesheets();\n// getter for easy mocking\nexport const getHasConstructableStylesheetSupport = (): boolean => hasConstructableStylesheetSupport;\n\ntype CssCacheMap = Map<string, string>;\nexport const componentCssMap = new Map<TagName, CssCacheMap>();\n\nexport const getCachedComponentCss = <T extends (...p: any[]) => string>(\n  host: HTMLElement,\n  getComponentCss: T,\n  ...args: Parameters<T>\n): string => {\n  const tagName = getTagNameWithoutPrefix(host);\n\n  if (!componentCssMap.has(tagName)) {\n    componentCssMap.set(tagName, new Map());\n  }\n\n  const id = args.map((arg) => (typeof arg === 'object' ? JSON.stringify(arg) : arg)).join('|');\n  const cache = componentCssMap.get(tagName);\n\n  if (!cache.has(id)) {\n    cache.set(id, getComponentCss(...args));\n  }\n\n  return cache.get(id);\n};\n\nexport const attachComponentCss = <T extends (...p: any[]) => string>(\n  host: HTMLElement,\n  getComponentCss: T,\n  ...args: Parameters<T>\n): void => {\n  const css = getCachedComponentCss(host, getComponentCss, ...args);\n\n  if (getHasConstructableStylesheetSupport()) {\n    const [sheet] = host.shadowRoot.adoptedStyleSheets;\n    if (sheet) {\n      sheet.replaceSync(css);\n    } else {\n      const newSheet = new CSSStyleSheet();\n      newSheet.replaceSync(css);\n      host.shadowRoot.adoptedStyleSheets = [newSheet];\n    }\n  } else {\n    // NOTE: fallback for Safari\n    // old style needs to be removed and added again in safari to be recognized\n    getShadowRootHTMLElement(host, 'style[jss]')?.remove();\n\n    const styleEl = document.createElement('style');\n    styleEl.setAttribute('jss', '');\n    styleEl.innerHTML = css;\n    host.shadowRoot.prepend(styleEl);\n  }\n};\n\nexport const buildSlottedStyles = (host: HTMLElement, jssStyle: JssStyle): Styles<'@global'> => ({\n  '@global': {\n    [getTagName(host)]: addImportantToEachRule(jssStyle),\n  },\n});\n\nexport type GetJssStyleFunction = (value?: any) => JssStyle;\n\nexport const buildResponsiveStyles = <T>(\n  rawValue: BreakpointCustomizable<T>,\n  getJssStyle: GetJssStyleFunction\n): Styles => {\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n  const value = parseJSON(rawValue as any);\n\n  return typeof value === 'object'\n    ? Object.keys(value)\n        // base styles are applied on root object, responsive styles are nested within\n        // hence it is used as the initial object within reduce function\n        .filter((key) => key !== 'base')\n        .reduce(\n          (result, breakpointValue: Breakpoint) => ({\n            ...result,\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            [mediaQueryMin(breakpointValue as any)]: getJssStyle(value[breakpointValue]) as Styles,\n          }),\n          getJssStyle(value.base) as Styles\n        )\n    : (getJssStyle(value) as Styles);\n};\n\nexport const isObject = <T extends Record<string, any>>(obj: T): boolean =>\n  typeof obj === 'object' && !Array.isArray(obj);\n\n// NOTE: taken from https://stackoverflow.com/a/48218209\nexport const mergeDeep = <T extends Record<string, any>>(...objects: T[]): T => {\n  return objects.reduce((prev, obj) => {\n    Object.keys(obj).forEach((key: keyof T) => {\n      const pVal = prev[key];\n      const oVal = obj[key];\n\n      if (isObject(pVal) && isObject(oVal)) {\n        prev[key] = mergeDeep(pVal, oVal);\n      } else {\n        prev[key] = oVal;\n      }\n    });\n\n    return prev;\n  }, {} as T);\n};\n","export const paramCaseToCamelCase = (str: string): string => {\n  return str.replace(/-(\\w)/g, (_, group) => group.toUpperCase());\n};\n","export const hasDocument = typeof document !== 'undefined';\n","import type { ScrollerDirection } from '../components/scroller/scroller-utils';\nimport { getScrollerElements } from '../components/scroller/scroller-utils';\nimport { hasDocument } from './has-document';\n\nlet supportsScrollBehavior = hasDocument && 'scrollBehavior' in document.documentElement.style;\n\n// for unit tests\nexport const overrideSupportsScrollBehavior = (override: boolean): void => {\n  supportsScrollBehavior = override;\n};\n\nconst steps = 20;\n\nlet scrollInterval: NodeJS.Timeout;\nconst intervalScroll = (el: HTMLElement, scrollStep: number, initialScrollLeft: number, endAmount: number): void => {\n  let i = 0;\n  clearInterval(scrollInterval);\n  scrollInterval = setInterval(() => {\n    el.scrollLeft = Math.round(initialScrollLeft + i * scrollStep);\n    if (++i >= steps) {\n      el.scrollLeft = endAmount;\n      clearInterval(scrollInterval);\n    }\n  }, 10);\n};\n\nexport const scrollElementTo = (el: HTMLElement, amount: number): void => {\n  if (supportsScrollBehavior) {\n    el.scrollTo({\n      left: amount,\n      behavior: 'smooth',\n    });\n  } else {\n    // TODO: this fallback can be removed as soon as all browser support scrollTo option behavior smooth by default\n    // https://caniuse.com/?search=scroll-behavior\n    const initialScrollLeft = el.scrollLeft;\n    const scrollDistance = amount - initialScrollLeft;\n    const scrollStep = scrollDistance / steps;\n\n    intervalScroll(el, scrollStep, initialScrollLeft, amount);\n  }\n};\n\nexport const scrollElementBy = (el: HTMLElement, amount: number): void => {\n  if (supportsScrollBehavior) {\n    el.scrollBy({ left: amount, top: 0, behavior: 'smooth' });\n  } else {\n    // TODO: this fallback can be removed as soon as all browser support scrollTo option behavior smooth by default\n    // https://caniuse.com/?search=scroll-behavior\n    const initialScrollLeft = el.scrollLeft;\n    const endScrollLeft = initialScrollLeft + amount;\n    const scrollStep = amount / steps;\n\n    intervalScroll(el, scrollStep, initialScrollLeft, endScrollLeft);\n  }\n};\n\nexport const getScrollByX = (scrollAreaElement: HTMLElement): number => {\n  return Math.round(scrollAreaElement.offsetWidth * 0.2);\n};\n\nexport const FOCUS_PADDING_WIDTH = 4;\n\nexport const getScrollActivePosition = (\n  elements: HTMLElement[],\n  direction: ScrollerDirection,\n  activeElementIndex: number,\n  scrollerElement: HTMLPScrollerElement\n): number => {\n  const { offsetLeft: activeElementOffsetLeft, offsetWidth: activeElementOffsetWidth } =\n    elements[activeElementIndex <= 0 ? 0 : activeElementIndex] || {}; // empty object fallback for tabs without children\n  // offsetLeft: is the number of pixels that the upper left corner of the current element is offset to the left within the offsetParent node\n  // offsetParent: is a reference to the element which is the closest (nearest in the containment hierarchy) positioned ancestor element\n  // which usually is an element with a non-static position\n  // - in chrome this seems to respect shadow DOM and therefore is the div.scroll-wrapper element in p-scroller\n  // - in firefox and safari this is not the case and some other parent element (up to the body element) is used\n  // this obviously leads to completely wrong calculations which are being corrected\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetLeft\n  // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent\n  const correctedActiveElementOffsetLeft =\n    elements[0]?.offsetLeft === 0 ? activeElementOffsetLeft : activeElementOffsetLeft - scrollerElement.offsetLeft;\n\n  const [scrollAreaElement, prevGradientElement] = getScrollerElements(scrollerElement);\n\n  let scrollPosition: number;\n  if (direction === 'next') {\n    if (activeElementIndex === elements.length - 1) {\n      // go to last element\n      scrollPosition = correctedActiveElementOffsetLeft - FOCUS_PADDING_WIDTH;\n    } else {\n      // go to next element\n      scrollPosition = correctedActiveElementOffsetLeft - prevGradientElement.offsetWidth + FOCUS_PADDING_WIDTH * 2;\n    }\n  } else {\n    if (activeElementIndex === 0) {\n      // go to first element\n      scrollPosition = 0;\n    } else {\n      // go to prev element\n      scrollPosition =\n        correctedActiveElementOffsetLeft +\n        activeElementOffsetWidth +\n        prevGradientElement.offsetWidth -\n        scrollAreaElement.offsetWidth;\n    }\n  }\n  return scrollPosition;\n};\n","const BUILD = {\n    allRenderFn: false,\n    cmpDidLoad: true,\n    cmpDidUnload: false,\n    cmpDidUpdate: true,\n    cmpDidRender: true,\n    cmpWillLoad: true,\n    cmpWillUpdate: true,\n    cmpWillRender: true,\n    connectedCallback: true,\n    disconnectedCallback: true,\n    element: true,\n    event: true,\n    hasRenderFn: true,\n    lifecycle: true,\n    hostListener: true,\n    hostListenerTargetWindow: true,\n    hostListenerTargetDocument: true,\n    hostListenerTargetBody: true,\n    hostListenerTargetParent: false,\n    hostListenerTarget: true,\n    member: true,\n    method: true,\n    mode: true,\n    observeAttribute: true,\n    prop: true,\n    propMutable: true,\n    reflect: true,\n    scoped: true,\n    shadowDom: true,\n    slot: true,\n    cssAnnotations: true,\n    state: true,\n    style: true,\n    svg: true,\n    updatable: true,\n    vdomAttribute: true,\n    vdomXlink: true,\n    vdomClass: true,\n    vdomFunctional: true,\n    vdomKey: true,\n    vdomListener: true,\n    vdomRef: true,\n    vdomPropOrAttr: true,\n    vdomRender: true,\n    vdomStyle: true,\n    vdomText: true,\n    watchCallback: true,\n    taskQueue: true,\n    hotModuleReplacement: false,\n    isDebug: false,\n    isDev: false,\n    isTesting: false,\n    hydrateServerSide: false,\n    hydrateClientSide: false,\n    lifecycleDOMEvents: false,\n    lazyLoad: false,\n    profile: false,\n    slotRelocation: true,\n    appendChildSlotFix: false,\n    cloneNodeFix: false,\n    hydratedAttribute: false,\n    hydratedClass: true,\n    safari10: false,\n    scriptDataOpts: false,\n    scopedSlotTextContentFix: false,\n    shadowDomShim: false,\n    slotChildNodesFix: false,\n    invisiblePrehydration: true,\n    propBoolean: true,\n    propNumber: true,\n    propString: true,\n    cssVarShim: false,\n    constructableCSS: true,\n    cmpShouldUpdate: true,\n    devTools: false,\n    dynamicImportShim: false,\n    shadowDelegatesFocus: true,\n    initializeNextTick: false,\n    asyncLoading: false,\n    asyncQueue: false,\n    transformTagName: false,\n    attachStyles: true,\n};\nconst Env = {};\nconst NAMESPACE = /* default */ 'app';\n\nexport { BUILD, Env, NAMESPACE };\n","import { getTagName } from '.';\n\ntype HTMLElementOrDocument = HTMLElement | Document;\ntype ElementMap = Map<HTMLElementOrDocument, boolean>;\n\n// TODO: why nested maps?\nconst elementStyles = new Map<string, ElementMap>();\n\nexport const getElementMap = (element: HTMLElement): ElementMap => {\n  const { tagName } = element;\n  let map = elementStyles.get(tagName);\n  if (map === undefined) {\n    map = new Map();\n    elementStyles.set(tagName, map);\n  }\n  return map;\n};\n\nexport const getNodeToPrependTo = (rootNode: HTMLElementOrDocument): HTMLElement => {\n  return rootNode === document ? rootNode.head : (rootNode as HTMLElement);\n};\n\nexport const slottedCssMap = new Map<string, string>();\n\nexport const getCachedSlottedCss = (host: HTMLElement, getSlottedCss: (h: HTMLElement) => string): string => {\n  const tagName = getTagName(host);\n\n  if (!slottedCssMap.has(tagName)) {\n    slottedCssMap.set(tagName, getSlottedCss(host));\n  }\n\n  return slottedCssMap.get(tagName);\n};\n\n/**\n * Adds an inheritable style for slotted content.\n * @param host\n * @param getSlottedCss - Make sure that css function are always in context of element (make sure that\n * it's created dynamically by e.g. `element.tagName.toLowerCase()`), e.g. `a:focus p-link-pure {…}`. Something like\n * providing only `a {…}` would cause unscoped global styling.\n * @returns void\n */\nexport const attachSlottedCss = (host: HTMLElement, getSlottedCss: (h: HTMLElement) => string): void => {\n  const css = getCachedSlottedCss(host, getSlottedCss);\n  const rootNode = host.getRootNode() as HTMLElementOrDocument;\n  const elementMap = getElementMap(host);\n\n  // isConnected check is needed because component may be removed from DOM in \"parallel\" and therefore\n  // the style doesn't matter and could produce validation errors because it is appended as a child\n  if (rootNode.isConnected && elementMap.get(rootNode) === undefined) {\n    elementMap.set(rootNode, true);\n    const style = document.createElement('style');\n    style.appendChild(document.createTextNode(css));\n\n    const prependTo = getNodeToPrependTo(rootNode);\n    const charsetTag = prependTo.querySelector('meta[charset]');\n\n    if (charsetTag !== null) {\n      prependTo.insertBefore(style, charsetTag.nextSibling);\n    } else if (prependTo.childNodes.length > 0) {\n      prependTo.insertBefore(style, prependTo.firstChild);\n    } else {\n      prependTo.appendChild(style);\n    }\n  }\n};\n","/**\n * Virtual DOM patching algorithm based on Snabbdom by\n * Simon Friis Vindum (@paldepind)\n * Licensed under the MIT License\n * https://github.com/snabbdom/snabbdom/blob/master/LICENSE\n *\n * Modified for Stencil's renderer and slot projection\n */\nlet scopeId;\nlet contentRef;\nlet hostTagName;\nlet customError;\nlet i = 0;\nlet useNativeShadowDom = false;\nlet checkSlotFallbackVisibility = false;\nlet checkSlotRelocate = false;\nlet isSvgMode = false;\nlet renderingRef = null;\nlet queueCongestion = 0;\nlet queuePending = false;\n/*\n Stencil Client Platform v2.20.0 | MIT Licensed | https://stenciljs.com\n */\nimport { BUILD, NAMESPACE } from '@stencil/core/internal/app-data';\nconst Build = {\n    isDev: BUILD.isDev ? true : false,\n    isBrowser: true,\n    isServer: false,\n    isTesting: BUILD.isTesting ? true : false,\n};\nconst Context = {};\nconst getAssetPath = (path) => {\n    const assetUrl = new URL(path, plt.$resourcesUrl$);\n    return assetUrl.origin !== win.location.origin ? assetUrl.href : assetUrl.pathname;\n};\nconst setAssetPath = (path) => (plt.$resourcesUrl$ = path);\nconst createTime = (fnName, tagName = '') => {\n    if (BUILD.profile && performance.mark) {\n        const key = `st:${fnName}:${tagName}:${i++}`;\n        // Start\n        performance.mark(key);\n        // End\n        return () => performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst uniqueTime = (key, measureText) => {\n    if (BUILD.profile && performance.mark) {\n        if (performance.getEntriesByName(key).length === 0) {\n            performance.mark(key);\n        }\n        return () => {\n            if (performance.getEntriesByName(measureText).length === 0) {\n                performance.measure(measureText, key);\n            }\n        };\n    }\n    else {\n        return () => {\n            return;\n        };\n    }\n};\nconst inspect = (ref) => {\n    const hostRef = getHostRef(ref);\n    if (!hostRef) {\n        return undefined;\n    }\n    const flags = hostRef.$flags$;\n    const hostElement = hostRef.$hostElement$;\n    return {\n        renderCount: hostRef.$renderCount$,\n        flags: {\n            hasRendered: !!(flags & 2 /* HOST_FLAGS.hasRendered */),\n            hasConnected: !!(flags & 1 /* HOST_FLAGS.hasConnected */),\n            isWaitingForChildren: !!(flags & 4 /* HOST_FLAGS.isWaitingForChildren */),\n            isConstructingInstance: !!(flags & 8 /* HOST_FLAGS.isConstructingInstance */),\n            isQueuedForUpdate: !!(flags & 16 /* HOST_FLAGS.isQueuedForUpdate */),\n            hasInitializedComponent: !!(flags & 32 /* HOST_FLAGS.hasInitializedComponent */),\n            hasLoadedComponent: !!(flags & 64 /* HOST_FLAGS.hasLoadedComponent */),\n            isWatchReady: !!(flags & 128 /* HOST_FLAGS.isWatchReady */),\n            isListenReady: !!(flags & 256 /* HOST_FLAGS.isListenReady */),\n            needsRerender: !!(flags & 512 /* HOST_FLAGS.needsRerender */),\n        },\n        instanceValues: hostRef.$instanceValues$,\n        ancestorComponent: hostRef.$ancestorComponent$,\n        hostElement,\n        lazyInstance: hostRef.$lazyInstance$,\n        vnode: hostRef.$vnode$,\n        modeName: hostRef.$modeName$,\n        onReadyPromise: hostRef.$onReadyPromise$,\n        onReadyResolve: hostRef.$onReadyResolve$,\n        onInstancePromise: hostRef.$onInstancePromise$,\n        onInstanceResolve: hostRef.$onInstanceResolve$,\n        onRenderResolve: hostRef.$onRenderResolve$,\n        queuedListeners: hostRef.$queuedListeners$,\n        rmListeners: hostRef.$rmListeners$,\n        ['s-id']: hostElement['s-id'],\n        ['s-cr']: hostElement['s-cr'],\n        ['s-lr']: hostElement['s-lr'],\n        ['s-p']: hostElement['s-p'],\n        ['s-rc']: hostElement['s-rc'],\n        ['s-sc']: hostElement['s-sc'],\n    };\n};\nconst installDevTools = () => {\n    if (BUILD.devTools) {\n        const stencil = (win.stencil = win.stencil || {});\n        const originalInspect = stencil.inspect;\n        stencil.inspect = (ref) => {\n            let result = inspect(ref);\n            if (!result && typeof originalInspect === 'function') {\n                result = originalInspect(ref);\n            }\n            return result;\n        };\n    }\n};\nconst CONTENT_REF_ID = 'r';\nconst ORG_LOCATION_ID = 'o';\nconst SLOT_NODE_ID = 's';\nconst TEXT_NODE_ID = 't';\nconst HYDRATE_ID = 's-id';\nconst HYDRATED_STYLE_ID = 'sty-id';\nconst HYDRATE_CHILD_ID = 'c-id';\nconst HYDRATED_CSS = '{visibility:hidden}.hydrated{visibility:inherit}';\nconst XLINK_NS = 'http://www.w3.org/1999/xlink';\n/**\n * Default style mode id\n */\n/**\n * Reusable empty obj/array\n * Don't add values to these!!\n */\nconst EMPTY_OBJ = {};\n/**\n * Namespaces\n */\nconst SVG_NS = 'http://www.w3.org/2000/svg';\nconst HTML_NS = 'http://www.w3.org/1999/xhtml';\nconst isDef = (v) => v != null;\nconst isComplexType = (o) => {\n    // https://jsperf.com/typeof-fn-object/5\n    o = typeof o;\n    return o === 'object' || o === 'function';\n};\n/**\n * Production h() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\n// const stack: any[] = [];\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, child?: d.ChildType): d.VNode;\n// export function h(nodeName: string | d.FunctionalComponent, vnodeData: d.PropsType, ...children: d.ChildType[]): d.VNode;\nconst h = (nodeName, vnodeData, ...children) => {\n    let child = null;\n    let key = null;\n    let slotName = null;\n    let simple = false;\n    let lastSimple = false;\n    const vNodeChildren = [];\n    const walk = (c) => {\n        for (let i = 0; i < c.length; i++) {\n            child = c[i];\n            if (Array.isArray(child)) {\n                walk(child);\n            }\n            else if (child != null && typeof child !== 'boolean') {\n                if ((simple = typeof nodeName !== 'function' && !isComplexType(child))) {\n                    child = String(child);\n                }\n                else if (BUILD.isDev && typeof nodeName !== 'function' && child.$flags$ === undefined) {\n                    consoleDevError(`vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects.`);\n                }\n                if (simple && lastSimple) {\n                    // If the previous child was simple (string), we merge both\n                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;\n                }\n                else {\n                    // Append a new vNode, if it's text, we create a text vNode\n                    vNodeChildren.push(simple ? newVNode(null, child) : child);\n                }\n                lastSimple = simple;\n            }\n        }\n    };\n    walk(children);\n    if (vnodeData) {\n        if (BUILD.isDev && nodeName === 'input') {\n            validateInputProperties(vnodeData);\n        }\n        // normalize class / classname attributes\n        if (BUILD.vdomKey && vnodeData.key) {\n            key = vnodeData.key;\n        }\n        if (BUILD.slotRelocation && vnodeData.name) {\n            slotName = vnodeData.name;\n        }\n        if (BUILD.vdomClass) {\n            const classData = vnodeData.className || vnodeData.class;\n            if (classData) {\n                vnodeData.class =\n                    typeof classData !== 'object'\n                        ? classData\n                        : Object.keys(classData)\n                            .filter((k) => classData[k])\n                            .join(' ');\n            }\n        }\n    }\n    if (BUILD.isDev && vNodeChildren.some(isHost)) {\n        consoleDevError(`The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function.`);\n    }\n    if (BUILD.vdomFunctional && typeof nodeName === 'function') {\n        // nodeName is a functional component\n        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);\n    }\n    const vnode = newVNode(nodeName, null);\n    vnode.$attrs$ = vnodeData;\n    if (vNodeChildren.length > 0) {\n        vnode.$children$ = vNodeChildren;\n    }\n    if (BUILD.vdomKey) {\n        vnode.$key$ = key;\n    }\n    if (BUILD.slotRelocation) {\n        vnode.$name$ = slotName;\n    }\n    return vnode;\n};\nconst newVNode = (tag, text) => {\n    const vnode = {\n        $flags$: 0,\n        $tag$: tag,\n        $text$: text,\n        $elm$: null,\n        $children$: null,\n    };\n    if (BUILD.vdomAttribute) {\n        vnode.$attrs$ = null;\n    }\n    if (BUILD.vdomKey) {\n        vnode.$key$ = null;\n    }\n    if (BUILD.slotRelocation) {\n        vnode.$name$ = null;\n    }\n    return vnode;\n};\nconst Host = {};\nconst isHost = (node) => node && node.$tag$ === Host;\nconst vdomFnUtils = {\n    forEach: (children, cb) => children.map(convertToPublic).forEach(cb),\n    map: (children, cb) => children.map(convertToPublic).map(cb).map(convertToPrivate),\n};\nconst convertToPublic = (node) => ({\n    vattrs: node.$attrs$,\n    vchildren: node.$children$,\n    vkey: node.$key$,\n    vname: node.$name$,\n    vtag: node.$tag$,\n    vtext: node.$text$,\n});\nconst convertToPrivate = (node) => {\n    if (typeof node.vtag === 'function') {\n        const vnodeData = Object.assign({}, node.vattrs);\n        if (node.vkey) {\n            vnodeData.key = node.vkey;\n        }\n        if (node.vname) {\n            vnodeData.name = node.vname;\n        }\n        return h(node.vtag, vnodeData, ...(node.vchildren || []));\n    }\n    const vnode = newVNode(node.vtag, node.vtext);\n    vnode.$attrs$ = node.vattrs;\n    vnode.$children$ = node.vchildren;\n    vnode.$key$ = node.vkey;\n    vnode.$name$ = node.vname;\n    return vnode;\n};\n/**\n * Validates the ordering of attributes on an input element\n * @param inputElm the element to validate\n */\nconst validateInputProperties = (inputElm) => {\n    const props = Object.keys(inputElm);\n    const value = props.indexOf('value');\n    if (value === -1) {\n        return;\n    }\n    const typeIndex = props.indexOf('type');\n    const minIndex = props.indexOf('min');\n    const maxIndex = props.indexOf('max');\n    const stepIndex = props.indexOf('step');\n    if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {\n        consoleDevWarn(`The \"value\" prop of <input> should be set after \"min\", \"max\", \"type\" and \"step\"`);\n    }\n};\nconst initializeClientHydrate = (hostElm, tagName, hostId, hostRef) => {\n    const endHydrate = createTime('hydrateClient', tagName);\n    const shadowRoot = hostElm.shadowRoot;\n    const childRenderNodes = [];\n    const slotNodes = [];\n    const shadowRootNodes = BUILD.shadowDom && shadowRoot ? [] : null;\n    const vnode = (hostRef.$vnode$ = newVNode(tagName, null));\n    if (!plt.$orgLocNodes$) {\n        initializeDocumentHydrate(doc.body, (plt.$orgLocNodes$ = new Map()));\n    }\n    hostElm[HYDRATE_ID] = hostId;\n    hostElm.removeAttribute(HYDRATE_ID);\n    clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);\n    childRenderNodes.map((c) => {\n        const orgLocationId = c.$hostId$ + '.' + c.$nodeId$;\n        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);\n        const node = c.$elm$;\n        if (orgLocationNode && supportsShadow && orgLocationNode['s-en'] === '') {\n            orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);\n        }\n        if (!shadowRoot) {\n            node['s-hn'] = tagName;\n            if (orgLocationNode) {\n                node['s-ol'] = orgLocationNode;\n                node['s-ol']['s-nr'] = node;\n            }\n        }\n        plt.$orgLocNodes$.delete(orgLocationId);\n    });\n    if (BUILD.shadowDom && shadowRoot) {\n        shadowRootNodes.map((shadowRootNode) => {\n            if (shadowRootNode) {\n                shadowRoot.appendChild(shadowRootNode);\n            }\n        });\n    }\n    endHydrate();\n};\nconst clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId) => {\n    let childNodeType;\n    let childIdSplt;\n    let childVNode;\n    let i;\n    if (node.nodeType === 1 /* NODE_TYPE.ElementNode */) {\n        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);\n        if (childNodeType) {\n            // got the node data from the element's attribute\n            // `${hostId}.${nodeId}.${depth}.${index}`\n            childIdSplt = childNodeType.split('.');\n            if (childIdSplt[0] === hostId || childIdSplt[0] === '0') {\n                childVNode = {\n                    $flags$: 0,\n                    $hostId$: childIdSplt[0],\n                    $nodeId$: childIdSplt[1],\n                    $depth$: childIdSplt[2],\n                    $index$: childIdSplt[3],\n                    $tag$: node.tagName.toLowerCase(),\n                    $elm$: node,\n                    $attrs$: null,\n                    $children$: null,\n                    $key$: null,\n                    $name$: null,\n                    $text$: null,\n                };\n                childRenderNodes.push(childVNode);\n                node.removeAttribute(HYDRATE_CHILD_ID);\n                // this is a new child vnode\n                // so ensure its parent vnode has the vchildren array\n                if (!parentVNode.$children$) {\n                    parentVNode.$children$ = [];\n                }\n                // add our child vnode to a specific index of the vnode's children\n                parentVNode.$children$[childVNode.$index$] = childVNode;\n                // this is now the new parent vnode for all the next child checks\n                parentVNode = childVNode;\n                if (shadowRootNodes && childVNode.$depth$ === '0') {\n                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                }\n            }\n        }\n        // recursively drill down, end to start so we can remove nodes\n        for (i = node.childNodes.length - 1; i >= 0; i--) {\n            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i], hostId);\n        }\n        if (node.shadowRoot) {\n            // keep drilling down through the shadow root nodes\n            for (i = node.shadowRoot.childNodes.length - 1; i >= 0; i--) {\n                clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i], hostId);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* NODE_TYPE.CommentNode */) {\n        // `${COMMENT_TYPE}.${hostId}.${nodeId}.${depth}.${index}`\n        childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[1] === hostId || childIdSplt[1] === '0') {\n            // comment node for either the host id or a 0 host id\n            childNodeType = childIdSplt[0];\n            childVNode = {\n                $flags$: 0,\n                $hostId$: childIdSplt[1],\n                $nodeId$: childIdSplt[2],\n                $depth$: childIdSplt[3],\n                $index$: childIdSplt[4],\n                $elm$: node,\n                $attrs$: null,\n                $children$: null,\n                $key$: null,\n                $name$: null,\n                $tag$: null,\n                $text$: null,\n            };\n            if (childNodeType === TEXT_NODE_ID) {\n                childVNode.$elm$ = node.nextSibling;\n                if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3 /* NODE_TYPE.TextNode */) {\n                    childVNode.$text$ = childVNode.$elm$.textContent;\n                    childRenderNodes.push(childVNode);\n                    // remove the text comment since it's no longer needed\n                    node.remove();\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                    if (shadowRootNodes && childVNode.$depth$ === '0') {\n                        shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                    }\n                }\n            }\n            else if (childVNode.$hostId$ === hostId) {\n                // this comment node is specifcally for this host id\n                if (childNodeType === SLOT_NODE_ID) {\n                    // `${SLOT_NODE_ID}.${hostId}.${nodeId}.${depth}.${index}.${slotName}`;\n                    childVNode.$tag$ = 'slot';\n                    if (childIdSplt[5]) {\n                        node['s-sn'] = childVNode.$name$ = childIdSplt[5];\n                    }\n                    else {\n                        node['s-sn'] = '';\n                    }\n                    node['s-sr'] = true;\n                    if (BUILD.shadowDom && shadowRootNodes) {\n                        // browser support shadowRoot and this is a shadow dom component\n                        // create an actual slot element\n                        childVNode.$elm$ = doc.createElement(childVNode.$tag$);\n                        if (childVNode.$name$) {\n                            // add the slot name attribute\n                            childVNode.$elm$.setAttribute('name', childVNode.$name$);\n                        }\n                        // insert the new slot element before the slot comment\n                        node.parentNode.insertBefore(childVNode.$elm$, node);\n                        // remove the slot comment since it's not needed for shadow\n                        node.remove();\n                        if (childVNode.$depth$ === '0') {\n                            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;\n                        }\n                    }\n                    slotNodes.push(childVNode);\n                    if (!parentVNode.$children$) {\n                        parentVNode.$children$ = [];\n                    }\n                    parentVNode.$children$[childVNode.$index$] = childVNode;\n                }\n                else if (childNodeType === CONTENT_REF_ID) {\n                    // `${CONTENT_REF_ID}.${hostId}`;\n                    if (BUILD.shadowDom && shadowRootNodes) {\n                        // remove the content ref comment since it's not needed for shadow\n                        node.remove();\n                    }\n                    else if (BUILD.slotRelocation) {\n                        hostElm['s-cr'] = node;\n                        node['s-cn'] = true;\n                    }\n                }\n            }\n        }\n    }\n    else if (parentVNode && parentVNode.$tag$ === 'style') {\n        const vnode = newVNode(null, node.textContent);\n        vnode.$elm$ = node;\n        vnode.$index$ = '0';\n        parentVNode.$children$ = [vnode];\n    }\n};\nconst initializeDocumentHydrate = (node, orgLocNodes) => {\n    if (node.nodeType === 1 /* NODE_TYPE.ElementNode */) {\n        let i = 0;\n        for (; i < node.childNodes.length; i++) {\n            initializeDocumentHydrate(node.childNodes[i], orgLocNodes);\n        }\n        if (node.shadowRoot) {\n            for (i = 0; i < node.shadowRoot.childNodes.length; i++) {\n                initializeDocumentHydrate(node.shadowRoot.childNodes[i], orgLocNodes);\n            }\n        }\n    }\n    else if (node.nodeType === 8 /* NODE_TYPE.CommentNode */) {\n        const childIdSplt = node.nodeValue.split('.');\n        if (childIdSplt[0] === ORG_LOCATION_ID) {\n            orgLocNodes.set(childIdSplt[1] + '.' + childIdSplt[2], node);\n            node.nodeValue = '';\n            // useful to know if the original location is\n            // the root light-dom of a shadow dom component\n            node['s-en'] = childIdSplt[3];\n        }\n    }\n};\n// Private\nconst computeMode = (elm) => modeResolutionChain.map((h) => h(elm)).find((m) => !!m);\n// Public\nconst setMode = (handler) => modeResolutionChain.push(handler);\nconst getMode = (ref) => getHostRef(ref).$modeName$;\n/**\n * Parse a new property value for a given property type.\n *\n * While the prop value can reasonably be expected to be of `any` type as far as TypeScript's type checker is concerned,\n * it is not safe to assume that the string returned by evaluating `typeof propValue` matches:\n *   1. `any`, the type given to `propValue` in the function signature\n *   2. the type stored from `propType`.\n *\n * This function provides the capability to parse/coerce a property's value to potentially any other JavaScript type.\n *\n * Property values represented in TSX preserve their type information. In the example below, the number 0 is passed to\n * a component. This `propValue` will preserve its type information (`typeof propValue === 'number'`). Note that is\n * based on the type of the value being passed in, not the type declared of the class member decorated with `@Prop`.\n * ```tsx\n * <my-cmp prop-val={0}></my-cmp>\n * ```\n *\n * HTML prop values on the other hand, will always a string\n *\n * @param propValue the new value to coerce to some type\n * @param propType the type of the prop, expressed as a binary number\n * @returns the parsed/coerced value\n */\nconst parsePropertyValue = (propValue, propType) => {\n    // ensure this value is of the correct prop type\n    if (propValue != null && !isComplexType(propValue)) {\n        if (BUILD.propBoolean && propType & 4 /* MEMBER_FLAGS.Boolean */) {\n            // per the HTML spec, any string value means it is a boolean true value\n            // but we'll cheat here and say that the string \"false\" is the boolean false\n            return propValue === 'false' ? false : propValue === '' || !!propValue;\n        }\n        if (BUILD.propNumber && propType & 2 /* MEMBER_FLAGS.Number */) {\n            // force it to be a number\n            return parseFloat(propValue);\n        }\n        if (BUILD.propString && propType & 1 /* MEMBER_FLAGS.String */) {\n            // could have been passed as a number or boolean\n            // but we still want it as a string\n            return String(propValue);\n        }\n        // redundant return here for better minification\n        return propValue;\n    }\n    // not sure exactly what type we want\n    // so no need to change to a different type\n    return propValue;\n};\nconst getElement = (ref) => (BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref);\nconst createEvent = (ref, name, flags) => {\n    const elm = getElement(ref);\n    return {\n        emit: (detail) => {\n            if (BUILD.isDev && !elm.isConnected) {\n                consoleDevWarn(`The \"${name}\" event was emitted, but the dispatcher node is no longer connected to the dom.`);\n            }\n            return emitEvent(elm, name, {\n                bubbles: !!(flags & 4 /* EVENT_FLAGS.Bubbles */),\n                composed: !!(flags & 2 /* EVENT_FLAGS.Composed */),\n                cancelable: !!(flags & 1 /* EVENT_FLAGS.Cancellable */),\n                detail,\n            });\n        },\n    };\n};\n/**\n * Helper function to create & dispatch a custom Event on a provided target\n * @param elm the target of the Event\n * @param name the name to give the custom Event\n * @param opts options for configuring a custom Event\n * @returns the custom Event\n */\nconst emitEvent = (elm, name, opts) => {\n    const ev = plt.ce(name, opts);\n    elm.dispatchEvent(ev);\n    return ev;\n};\nconst rootAppliedStyles = /*@__PURE__*/ new WeakMap();\nconst registerStyle = (scopeId, cssText, allowCS) => {\n    let style = styles.get(scopeId);\n    if (supportsConstructableStylesheets && allowCS) {\n        style = (style || new CSSStyleSheet());\n        if (typeof style === 'string') {\n            style = cssText;\n        }\n        else {\n            style.replaceSync(cssText);\n        }\n    }\n    else {\n        style = cssText;\n    }\n    styles.set(scopeId, style);\n};\nconst addStyle = (styleContainerNode, cmpMeta, mode, hostElm) => {\n    let scopeId = getScopeId(cmpMeta, mode);\n    const style = styles.get(scopeId);\n    if (!BUILD.attachStyles) {\n        return scopeId;\n    }\n    // if an element is NOT connected then getRootNode() will return the wrong root node\n    // so the fallback is to always use the document for the root node in those cases\n    styleContainerNode = styleContainerNode.nodeType === 11 /* NODE_TYPE.DocumentFragment */ ? styleContainerNode : doc;\n    if (style) {\n        if (typeof style === 'string') {\n            styleContainerNode = styleContainerNode.head || styleContainerNode;\n            let appliedStyles = rootAppliedStyles.get(styleContainerNode);\n            let styleElm;\n            if (!appliedStyles) {\n                rootAppliedStyles.set(styleContainerNode, (appliedStyles = new Set()));\n            }\n            if (!appliedStyles.has(scopeId)) {\n                if (BUILD.hydrateClientSide &&\n                    styleContainerNode.host &&\n                    (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}=\"${scopeId}\"]`))) {\n                    // This is only happening on native shadow-dom, do not needs CSS var shim\n                    styleElm.innerHTML = style;\n                }\n                else {\n                    if (BUILD.cssVarShim && plt.$cssShim$) {\n                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId, style, !!(cmpMeta.$flags$ & 10 /* CMP_FLAGS.needsScopedEncapsulation */));\n                        const newScopeId = styleElm['s-sc'];\n                        if (newScopeId) {\n                            scopeId = newScopeId;\n                            // we don't want to add this styleID to the appliedStyles Set\n                            // since the cssVarShim might need to apply several different\n                            // stylesheets for the same component\n                            appliedStyles = null;\n                        }\n                    }\n                    else {\n                        styleElm = doc.createElement('style');\n                        styleElm.innerHTML = style;\n                    }\n                    if (BUILD.hydrateServerSide || BUILD.hotModuleReplacement) {\n                        styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId);\n                    }\n                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector('link'));\n                }\n                if (appliedStyles) {\n                    appliedStyles.add(scopeId);\n                }\n            }\n        }\n        else if (BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {\n            styleContainerNode.adoptedStyleSheets = [...styleContainerNode.adoptedStyleSheets, style];\n        }\n    }\n    return scopeId;\n};\nconst attachStyles = (hostRef) => {\n    const cmpMeta = hostRef.$cmpMeta$;\n    const elm = hostRef.$hostElement$;\n    const flags = cmpMeta.$flags$;\n    const endAttachStyles = createTime('attachStyles', cmpMeta.$tagName$);\n    const scopeId = addStyle(BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);\n    if ((BUILD.shadowDom || BUILD.scoped) && BUILD.cssAnnotations && flags & 10 /* CMP_FLAGS.needsScopedEncapsulation */) {\n        // only required when we're NOT using native shadow dom (slot)\n        // or this browser doesn't support native shadow dom\n        // and this host element was NOT created with SSR\n        // let's pick out the inner content for slot projection\n        // create a node to represent where the original\n        // content was first placed, which is useful later on\n        // DOM WRITE!!\n        elm['s-sc'] = scopeId;\n        elm.classList.add(scopeId + '-h');\n        if (BUILD.scoped && flags & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {\n            elm.classList.add(scopeId + '-s');\n        }\n    }\n    endAttachStyles();\n};\nconst getScopeId = (cmp, mode) => 'sc-' + (BUILD.mode && mode && cmp.$flags$ & 32 /* CMP_FLAGS.hasMode */ ? cmp.$tagName$ + '-' + mode : cmp.$tagName$);\nconst convertScopedToShadow = (css) => css.replace(/\\/\\*!@([^\\/]+)\\*\\/[^\\{]+\\{/g, '$1{');\n/**\n * Production setAccessor() function based on Preact by\n * Jason Miller (@developit)\n * Licensed under the MIT License\n * https://github.com/developit/preact/blob/master/LICENSE\n *\n * Modified for Stencil's compiler and vdom\n */\nconst setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags) => {\n    if (oldValue !== newValue) {\n        let isProp = isMemberInElement(elm, memberName);\n        let ln = memberName.toLowerCase();\n        if (BUILD.vdomClass && memberName === 'class') {\n            const classList = elm.classList;\n            const oldClasses = parseClassList(oldValue);\n            const newClasses = parseClassList(newValue);\n            classList.remove(...oldClasses.filter((c) => c && !newClasses.includes(c)));\n            classList.add(...newClasses.filter((c) => c && !oldClasses.includes(c)));\n        }\n        else if (BUILD.vdomStyle && memberName === 'style') {\n            // update style attribute, css properties and values\n            if (BUILD.updatable) {\n                for (const prop in oldValue) {\n                    if (!newValue || newValue[prop] == null) {\n                        if (!BUILD.hydrateServerSide && prop.includes('-')) {\n                            elm.style.removeProperty(prop);\n                        }\n                        else {\n                            elm.style[prop] = '';\n                        }\n                    }\n                }\n            }\n            for (const prop in newValue) {\n                if (!oldValue || newValue[prop] !== oldValue[prop]) {\n                    if (!BUILD.hydrateServerSide && prop.includes('-')) {\n                        elm.style.setProperty(prop, newValue[prop]);\n                    }\n                    else {\n                        elm.style[prop] = newValue[prop];\n                    }\n                }\n            }\n        }\n        else if (BUILD.vdomKey && memberName === 'key')\n            ;\n        else if (BUILD.vdomRef && memberName === 'ref') {\n            // minifier will clean this up\n            if (newValue) {\n                newValue(elm);\n            }\n        }\n        else if (BUILD.vdomListener &&\n            (BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) &&\n            memberName[0] === 'o' &&\n            memberName[1] === 'n') {\n            // Event Handlers\n            // so if the member name starts with \"on\" and the 3rd characters is\n            // a capital letter, and it's not already a member on the element,\n            // then we're assuming it's an event listener\n            if (memberName[2] === '-') {\n                // on- prefixed events\n                // allows to be explicit about the dom event to listen without any magic\n                // under the hood:\n                // <my-cmp on-click> // listens for \"click\"\n                // <my-cmp on-Click> // listens for \"Click\"\n                // <my-cmp on-ionChange> // listens for \"ionChange\"\n                // <my-cmp on-EVENTS> // listens for \"EVENTS\"\n                memberName = memberName.slice(3);\n            }\n            else if (isMemberInElement(win, ln)) {\n                // standard event\n                // the JSX attribute could have been \"onMouseOver\" and the\n                // member name \"onmouseover\" is on the window's prototype\n                // so let's add the listener \"mouseover\", which is all lowercased\n                memberName = ln.slice(2);\n            }\n            else {\n                // custom event\n                // the JSX attribute could have been \"onMyCustomEvent\"\n                // so let's trim off the \"on\" prefix and lowercase the first character\n                // and add the listener \"myCustomEvent\"\n                // except for the first character, we keep the event name case\n                memberName = ln[2] + memberName.slice(3);\n            }\n            if (oldValue) {\n                plt.rel(elm, memberName, oldValue, false);\n            }\n            if (newValue) {\n                plt.ael(elm, memberName, newValue, false);\n            }\n        }\n        else if (BUILD.vdomPropOrAttr) {\n            // Set property if it exists and it's not a SVG\n            const isComplex = isComplexType(newValue);\n            if ((isProp || (isComplex && newValue !== null)) && !isSvg) {\n                try {\n                    if (!elm.tagName.includes('-')) {\n                        const n = newValue == null ? '' : newValue;\n                        // Workaround for Safari, moving the <input> caret when re-assigning the same valued\n                        if (memberName === 'list') {\n                            isProp = false;\n                        }\n                        else if (oldValue == null || elm[memberName] != n) {\n                            elm[memberName] = n;\n                        }\n                    }\n                    else {\n                        elm[memberName] = newValue;\n                    }\n                }\n                catch (e) { }\n            }\n            /**\n             * Need to manually update attribute if:\n             * - memberName is not an attribute\n             * - if we are rendering the host element in order to reflect attribute\n             * - if it's a SVG, since properties might not work in <svg>\n             * - if the newValue is null/undefined or 'false'.\n             */\n            let xlink = false;\n            if (BUILD.vdomXlink) {\n                if (ln !== (ln = ln.replace(/^xlink\\:?/, ''))) {\n                    memberName = ln;\n                    xlink = true;\n                }\n            }\n            if (newValue == null || newValue === false) {\n                if (newValue !== false || elm.getAttribute(memberName) === '') {\n                    if (BUILD.vdomXlink && xlink) {\n                        elm.removeAttributeNS(XLINK_NS, memberName);\n                    }\n                    else {\n                        elm.removeAttribute(memberName);\n                    }\n                }\n            }\n            else if ((!isProp || flags & 4 /* VNODE_FLAGS.isHost */ || isSvg) && !isComplex) {\n                newValue = newValue === true ? '' : newValue;\n                if (BUILD.vdomXlink && xlink) {\n                    elm.setAttributeNS(XLINK_NS, memberName, newValue);\n                }\n                else {\n                    elm.setAttribute(memberName, newValue);\n                }\n            }\n        }\n    }\n};\nconst parseClassListRegex = /\\s/;\nconst parseClassList = (value) => (!value ? [] : value.split(parseClassListRegex));\nconst updateElement = (oldVnode, newVnode, isSvgMode, memberName) => {\n    // if the element passed in is a shadow root, which is a document fragment\n    // then we want to be adding attrs/props to the shadow root's \"host\" element\n    // if it's not a shadow root, then we add attrs/props to the same element\n    const elm = newVnode.$elm$.nodeType === 11 /* NODE_TYPE.DocumentFragment */ && newVnode.$elm$.host\n        ? newVnode.$elm$.host\n        : newVnode.$elm$;\n    const oldVnodeAttrs = (oldVnode && oldVnode.$attrs$) || EMPTY_OBJ;\n    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;\n    if (BUILD.updatable) {\n        // remove attributes no longer present on the vnode by setting them to undefined\n        for (memberName in oldVnodeAttrs) {\n            if (!(memberName in newVnodeAttrs)) {\n                setAccessor(elm, memberName, oldVnodeAttrs[memberName], undefined, isSvgMode, newVnode.$flags$);\n            }\n        }\n    }\n    // add new & update changed attributes\n    for (memberName in newVnodeAttrs) {\n        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode, newVnode.$flags$);\n    }\n};\n/**\n * Create a DOM Node corresponding to one of the children of a given VNode.\n *\n * @param oldParentVNode the parent VNode from the previous render\n * @param newParentVNode the parent VNode from the current render\n * @param childIndex the index of the VNode, in the _new_ parent node's\n * children, for which we will create a new DOM node\n * @param parentElm the parent DOM node which our new node will be a child of\n * @returns the newly created node\n */\nconst createElm = (oldParentVNode, newParentVNode, childIndex, parentElm) => {\n    // tslint:disable-next-line: prefer-const\n    const newVNode = newParentVNode.$children$[childIndex];\n    let i = 0;\n    let elm;\n    let childNode;\n    let oldVNode;\n    if (BUILD.slotRelocation && !useNativeShadowDom) {\n        // remember for later we need to check to relocate nodes\n        checkSlotRelocate = true;\n        if (newVNode.$tag$ === 'slot') {\n            if (scopeId) {\n                // scoped css needs to add its scoped id to the parent element\n                parentElm.classList.add(scopeId + '-s');\n            }\n            newVNode.$flags$ |= newVNode.$children$\n                ? // slot element has fallback content\n                    2 /* VNODE_FLAGS.isSlotFallback */\n                : // slot element does not have fallback content\n                    1 /* VNODE_FLAGS.isSlotReference */;\n        }\n    }\n    if (BUILD.isDev && newVNode.$elm$) {\n        consoleDevError(`The JSX ${newVNode.$text$ !== null ? `\"${newVNode.$text$}\" text` : `\"${newVNode.$tag$}\" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);\n    }\n    if (BUILD.vdomText && newVNode.$text$ !== null) {\n        // create text node\n        elm = newVNode.$elm$ = doc.createTextNode(newVNode.$text$);\n    }\n    else if (BUILD.slotRelocation && newVNode.$flags$ & 1 /* VNODE_FLAGS.isSlotReference */) {\n        // create a slot reference node\n        elm = newVNode.$elm$ =\n            BUILD.isDebug || BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode) : doc.createTextNode('');\n    }\n    else {\n        if (BUILD.svg && !isSvgMode) {\n            isSvgMode = newVNode.$tag$ === 'svg';\n        }\n        // create element\n        elm = newVNode.$elm$ = (BUILD.svg\n            ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, BUILD.slotRelocation && newVNode.$flags$ & 2 /* VNODE_FLAGS.isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$)\n            : doc.createElement(BUILD.slotRelocation && newVNode.$flags$ & 2 /* VNODE_FLAGS.isSlotFallback */\n                ? 'slot-fb'\n                : newVNode.$tag$));\n        if (BUILD.svg && isSvgMode && newVNode.$tag$ === 'foreignObject') {\n            isSvgMode = false;\n        }\n        // add css classes, attrs, props, listeners, etc.\n        if (BUILD.vdomAttribute) {\n            updateElement(null, newVNode, isSvgMode);\n        }\n        if ((BUILD.shadowDom || BUILD.scoped) && isDef(scopeId) && elm['s-si'] !== scopeId) {\n            // if there is a scopeId and this is the initial render\n            // then let's add the scopeId as a css class\n            elm.classList.add((elm['s-si'] = scopeId));\n        }\n        if (newVNode.$children$) {\n            for (i = 0; i < newVNode.$children$.length; ++i) {\n                // create the node\n                childNode = createElm(oldParentVNode, newVNode, i, elm);\n                // return node could have been null\n                if (childNode) {\n                    // append our new node\n                    elm.appendChild(childNode);\n                }\n            }\n        }\n        if (BUILD.svg) {\n            if (newVNode.$tag$ === 'svg') {\n                // Only reset the SVG context when we're exiting <svg> element\n                isSvgMode = false;\n            }\n            else if (elm.tagName === 'foreignObject') {\n                // Reenter SVG context when we're exiting <foreignObject> element\n                isSvgMode = true;\n            }\n        }\n    }\n    if (BUILD.slotRelocation) {\n        elm['s-hn'] = hostTagName;\n        if (newVNode.$flags$ & (2 /* VNODE_FLAGS.isSlotFallback */ | 1 /* VNODE_FLAGS.isSlotReference */)) {\n            // remember the content reference comment\n            elm['s-sr'] = true;\n            // remember the content reference comment\n            elm['s-cr'] = contentRef;\n            // remember the slot name, or empty string for default slot\n            elm['s-sn'] = newVNode.$name$ || '';\n            // check if we've got an old vnode for this slot\n            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];\n            if (oldVNode && oldVNode.$tag$ === newVNode.$tag$ && oldParentVNode.$elm$) {\n                // we've got an old slot vnode and the wrapper is being replaced\n                // so let's move the old slot content back to it's original location\n                putBackInOriginalLocation(oldParentVNode.$elm$, false);\n            }\n        }\n    }\n    return elm;\n};\nconst putBackInOriginalLocation = (parentElm, recursive) => {\n    plt.$flags$ |= 1 /* PLATFORM_FLAGS.isTmpDisconnected */;\n    const oldSlotChildNodes = parentElm.childNodes;\n    for (let i = oldSlotChildNodes.length - 1; i >= 0; i--) {\n        const childNode = oldSlotChildNodes[i];\n        if (childNode['s-hn'] !== hostTagName && childNode['s-ol']) {\n            // // this child node in the old element is from another component\n            // // remove this node from the old slot's parent\n            // childNode.remove();\n            // and relocate it back to it's original location\n            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));\n            // remove the old original location comment entirely\n            // later on the patch function will know what to do\n            // and move this to the correct spot in need be\n            childNode['s-ol'].remove();\n            childNode['s-ol'] = undefined;\n            checkSlotRelocate = true;\n        }\n        if (recursive) {\n            putBackInOriginalLocation(childNode, recursive);\n        }\n    }\n    plt.$flags$ &= ~1 /* PLATFORM_FLAGS.isTmpDisconnected */;\n};\nconst addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx) => {\n    let containerElm = ((BUILD.slotRelocation && parentElm['s-cr'] && parentElm['s-cr'].parentNode) || parentElm);\n    let childNode;\n    if (BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {\n        containerElm = containerElm.shadowRoot;\n    }\n    for (; startIdx <= endIdx; ++startIdx) {\n        if (vnodes[startIdx]) {\n            childNode = createElm(null, parentVNode, startIdx, parentElm);\n            if (childNode) {\n                vnodes[startIdx].$elm$ = childNode;\n                containerElm.insertBefore(childNode, BUILD.slotRelocation ? referenceNode(before) : before);\n            }\n        }\n    }\n};\nconst removeVnodes = (vnodes, startIdx, endIdx, vnode, elm) => {\n    for (; startIdx <= endIdx; ++startIdx) {\n        if ((vnode = vnodes[startIdx])) {\n            elm = vnode.$elm$;\n            callNodeRefs(vnode);\n            if (BUILD.slotRelocation) {\n                // we're removing this element\n                // so it's possible we need to show slot fallback content now\n                checkSlotFallbackVisibility = true;\n                if (elm['s-ol']) {\n                    // remove the original location comment\n                    elm['s-ol'].remove();\n                }\n                else {\n                    // it's possible that child nodes of the node\n                    // that's being removed are slot nodes\n                    putBackInOriginalLocation(elm, true);\n                }\n            }\n            // remove the vnode's element from the dom\n            elm.remove();\n        }\n    }\n};\n/**\n * Reconcile the children of a new VNode with the children of an old VNode by\n * traversing the two collections of children, identifying nodes that are\n * conserved or changed, calling out to `patch` to make any necessary\n * updates to the DOM, and rearranging DOM nodes as needed.\n *\n * The algorithm for reconciling children works by analyzing two 'windows' onto\n * the two arrays of children (`oldCh` and `newCh`). We keep track of the\n * 'windows' by storing start and end indices and references to the\n * corresponding array entries. Initially the two 'windows' are basically equal\n * to the entire array, but we progressively narrow the windows until there are\n * no children left to update by doing the following:\n *\n * 1. Skip any `null` entries at the beginning or end of the two arrays, so\n *    that if we have an initial array like the following we'll end up dealing\n *    only with a window bounded by the highlighted elements:\n *\n *    [null, null, VNode1 , ... , VNode2, null, null]\n *                 ^^^^^^         ^^^^^^\n *\n * 2. Check to see if the elements at the head and tail positions are equal\n *    across the windows. This will basically detect elements which haven't\n *    been added, removed, or changed position, i.e. if you had the following\n *    VNode elements (represented as HTML):\n *\n *    oldVNode: `<div><p><span>HEY</span></p></div>`\n *    newVNode: `<div><p><span>THERE</span></p></div>`\n *\n *    Then when comparing the children of the `<div>` tag we check the equality\n *    of the VNodes corresponding to the `<p>` tags and, since they are the\n *    same tag in the same position, we'd be able to avoid completely\n *    re-rendering the subtree under them with a new DOM element and would just\n *    call out to `patch` to handle reconciling their children and so on.\n *\n * 3. Check, for both windows, to see if the element at the beginning of the\n *    window corresponds to the element at the end of the other window. This is\n *    a heuristic which will let us identify _some_ situations in which\n *    elements have changed position, for instance it _should_ detect that the\n *    children nodes themselves have not changed but merely moved in the\n *    following example:\n *\n *    oldVNode: `<div><element-one /><element-two /></div>`\n *    newVNode: `<div><element-two /><element-one /></div>`\n *\n *    If we find cases like this then we also need to move the concrete DOM\n *    elements corresponding to the moved children to write the re-order to the\n *    DOM.\n *\n * 4. Finally, if VNodes have the `key` attribute set on them we check for any\n *    nodes in the old children which have the same key as the first element in\n *    our window on the new children. If we find such a node we handle calling\n *    out to `patch`, moving relevant DOM nodes, and so on, in accordance with\n *    what we find.\n *\n * Finally, once we've narrowed our 'windows' to the point that either of them\n * collapse (i.e. they have length 0) we then handle any remaining VNode\n * insertion or deletion that needs to happen to get a DOM state that correctly\n * reflects the new child VNodes. If, for instance, after our window on the old\n * children has collapsed we still have more nodes on the new children that\n * we haven't dealt with yet then we need to add them, or if the new children\n * collapse but we still have unhandled _old_ children then we need to make\n * sure the corresponding DOM nodes are removed.\n *\n * @param parentElm the node into which the parent VNode is rendered\n * @param oldCh the old children of the parent node\n * @param newVNode the new VNode which will replace the parent\n * @param newCh the new children of the parent node\n */\nconst updateChildren = (parentElm, oldCh, newVNode, newCh) => {\n    let oldStartIdx = 0;\n    let newStartIdx = 0;\n    let idxInOld = 0;\n    let i = 0;\n    let oldEndIdx = oldCh.length - 1;\n    let oldStartVnode = oldCh[0];\n    let oldEndVnode = oldCh[oldEndIdx];\n    let newEndIdx = newCh.length - 1;\n    let newStartVnode = newCh[0];\n    let newEndVnode = newCh[newEndIdx];\n    let node;\n    let elmToMove;\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (oldStartVnode == null) {\n            // VNode might have been moved left\n            oldStartVnode = oldCh[++oldStartIdx];\n        }\n        else if (oldEndVnode == null) {\n            oldEndVnode = oldCh[--oldEndIdx];\n        }\n        else if (newStartVnode == null) {\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (newEndVnode == null) {\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newStartVnode)) {\n            // if the start nodes are the same then we should patch the new VNode\n            // onto the old one, and increment our `newStartIdx` and `oldStartIdx`\n            // indices to reflect that. We don't need to move any DOM Nodes around\n            // since things are matched up in order.\n            patch(oldStartVnode, newStartVnode);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newEndVnode)) {\n            // likewise, if the end nodes are the same we patch new onto old and\n            // decrement our end indices, and also likewise in this case we don't\n            // need to move any DOM Nodes.\n            patch(oldEndVnode, newEndVnode);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldStartVnode, newEndVnode)) {\n            // case: \"Vnode moved right\"\n            //\n            // We've found that the last node in our window on the new children is\n            // the same VNode as the _first_ node in our window on the old children\n            // we're dealing with now. Visually, this is the layout of these two\n            // nodes:\n            //\n            // newCh: [..., newStartVnode , ... , newEndVnode , ...]\n            //                                    ^^^^^^^^^^^\n            // oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]\n            //              ^^^^^^^^^^^^^\n            //\n            // In this situation we need to patch `newEndVnode` onto `oldStartVnode`\n            // and move the DOM element for `oldStartVnode`.\n            if (BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);\n            }\n            patch(oldStartVnode, newEndVnode);\n            // We need to move the element for `oldStartVnode` into a position which\n            // will be appropriate for `newEndVnode`. For this we can use\n            // `.insertBefore` and `oldEndVnode.$elm$.nextSibling`. If there is a\n            // sibling for `oldEndVnode.$elm$` then we want to move the DOM node for\n            // `oldStartVnode` between `oldEndVnode` and it's sibling, like so:\n            //\n            // <old-start-node />\n            // <some-intervening-node />\n            // <old-end-node />\n            // <!-- ->              <-- `oldStartVnode.$elm$` should be inserted here\n            // <next-sibling />\n            //\n            // If instead `oldEndVnode.$elm$` has no sibling then we just want to put\n            // the node for `oldStartVnode` at the end of the children of\n            // `parentElm`. Luckily, `Node.nextSibling` will return `null` if there\n            // aren't any siblings, and passing `null` to `Node.insertBefore` will\n            // append it to the children of the parent element.\n            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);\n            oldStartVnode = oldCh[++oldStartIdx];\n            newEndVnode = newCh[--newEndIdx];\n        }\n        else if (isSameVnode(oldEndVnode, newStartVnode)) {\n            // case: \"Vnode moved left\"\n            //\n            // We've found that the first node in our window on the new children is\n            // the same VNode as the _last_ node in our window on the old children.\n            // Visually, this is the layout of these two nodes:\n            //\n            // newCh: [..., newStartVnode , ... , newEndVnode , ...]\n            //              ^^^^^^^^^^^^^\n            // oldCh: [..., oldStartVnode , ... , oldEndVnode , ...]\n            //                                    ^^^^^^^^^^^\n            //\n            // In this situation we need to patch `newStartVnode` onto `oldEndVnode`\n            // (which will handle updating any changed attributes, reconciling their\n            // children etc) but we also need to move the DOM node to which\n            // `oldEndVnode` corresponds.\n            if (BUILD.slotRelocation && (oldStartVnode.$tag$ === 'slot' || newEndVnode.$tag$ === 'slot')) {\n                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);\n            }\n            patch(oldEndVnode, newStartVnode);\n            // We've already checked above if `oldStartVnode` and `newStartVnode` are\n            // the same node, so since we're here we know that they are not. Thus we\n            // can move the element for `oldEndVnode` _before_ the element for\n            // `oldStartVnode`, leaving `oldStartVnode` to be reconciled in the\n            // future.\n            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);\n            oldEndVnode = oldCh[--oldEndIdx];\n            newStartVnode = newCh[++newStartIdx];\n        }\n        else {\n            // Here we do some checks to match up old and new nodes based on the\n            // `$key$` attribute, which is set by putting a `key=\"my-key\"` attribute\n            // in the JSX for a DOM element in the implementation of a Stencil\n            // component.\n            //\n            // First we check to see if there are any nodes in the array of old\n            // children which have the same key as the first node in the new\n            // children.\n            idxInOld = -1;\n            if (BUILD.vdomKey) {\n                for (i = oldStartIdx; i <= oldEndIdx; ++i) {\n                    if (oldCh[i] && oldCh[i].$key$ !== null && oldCh[i].$key$ === newStartVnode.$key$) {\n                        idxInOld = i;\n                        break;\n                    }\n                }\n            }\n            if (BUILD.vdomKey && idxInOld >= 0) {\n                // We found a node in the old children which matches up with the first\n                // node in the new children! So let's deal with that\n                elmToMove = oldCh[idxInOld];\n                if (elmToMove.$tag$ !== newStartVnode.$tag$) {\n                    // the tag doesn't match so we'll need a new DOM element\n                    node = createElm(oldCh && oldCh[newStartIdx], newVNode, idxInOld, parentElm);\n                }\n                else {\n                    patch(elmToMove, newStartVnode);\n                    // invalidate the matching old node so that we won't try to update it\n                    // again later on\n                    oldCh[idxInOld] = undefined;\n                    node = elmToMove.$elm$;\n                }\n                newStartVnode = newCh[++newStartIdx];\n            }\n            else {\n                // We either didn't find an element in the old children that matches\n                // the key of the first new child OR the build is not using `key`\n                // attributes at all. In either case we need to create a new element\n                // for the new node.\n                node = createElm(oldCh && oldCh[newStartIdx], newVNode, newStartIdx, parentElm);\n                newStartVnode = newCh[++newStartIdx];\n            }\n            if (node) {\n                // if we created a new node then handle inserting it to the DOM\n                if (BUILD.slotRelocation) {\n                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));\n                }\n                else {\n                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);\n                }\n            }\n        }\n    }\n    if (oldStartIdx > oldEndIdx) {\n        // we have some more new nodes to add which don't match up with old nodes\n        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode, newCh, newStartIdx, newEndIdx);\n    }\n    else if (BUILD.updatable && newStartIdx > newEndIdx) {\n        // there are nodes in the `oldCh` array which no longer correspond to nodes\n        // in the new array, so lets remove them (which entails cleaning up the\n        // relevant DOM nodes)\n        removeVnodes(oldCh, oldStartIdx, oldEndIdx);\n    }\n};\n/**\n * Compare two VNodes to determine if they are the same\n *\n * **NB**: This function is an equality _heuristic_ based on the available\n * information set on the two VNodes and can be misleading under certain\n * circumstances. In particular, if the two nodes do not have `key` attrs\n * (available under `$key$` on VNodes) then the function falls back on merely\n * checking that they have the same tag.\n *\n * So, in other words, if `key` attrs are not set on VNodes which may be\n * changing order within a `children` array or something along those lines then\n * we could obtain a false positive and then have to do needless re-rendering.\n *\n * @param leftVNode the first VNode to check\n * @param rightVNode the second VNode to check\n * @returns whether they're equal or not\n */\nconst isSameVnode = (leftVNode, rightVNode) => {\n    // compare if two vnode to see if they're \"technically\" the same\n    // need to have the same element tag, and same key to be the same\n    if (leftVNode.$tag$ === rightVNode.$tag$) {\n        if (BUILD.slotRelocation && leftVNode.$tag$ === 'slot') {\n            return leftVNode.$name$ === rightVNode.$name$;\n        }\n        // this will be set if components in the build have `key` attrs set on them\n        if (BUILD.vdomKey) {\n            return leftVNode.$key$ === rightVNode.$key$;\n        }\n        return true;\n    }\n    return false;\n};\nconst referenceNode = (node) => {\n    // this node was relocated to a new location in the dom\n    // because of some other component's slot\n    // but we still have an html comment in place of where\n    // it's original location was according to it's original vdom\n    return (node && node['s-ol']) || node;\n};\nconst parentReferenceNode = (node) => (node['s-ol'] ? node['s-ol'] : node).parentNode;\n/**\n * Handle reconciling an outdated VNode with a new one which corresponds to\n * it. This function handles flushing updates to the DOM and reconciling the\n * children of the two nodes (if any).\n *\n * @param oldVNode an old VNode whose DOM element and children we want to update\n * @param newVNode a new VNode representing an updated version of the old one\n */\nconst patch = (oldVNode, newVNode) => {\n    const elm = (newVNode.$elm$ = oldVNode.$elm$);\n    const oldChildren = oldVNode.$children$;\n    const newChildren = newVNode.$children$;\n    const tag = newVNode.$tag$;\n    const text = newVNode.$text$;\n    let defaultHolder;\n    if (!BUILD.vdomText || text === null) {\n        if (BUILD.svg) {\n            // test if we're rendering an svg element, or still rendering nodes inside of one\n            // only add this to the when the compiler sees we're using an svg somewhere\n            isSvgMode = tag === 'svg' ? true : tag === 'foreignObject' ? false : isSvgMode;\n        }\n        if (BUILD.vdomAttribute || BUILD.reflect) {\n            if (BUILD.slot && tag === 'slot')\n                ;\n            else {\n                // either this is the first render of an element OR it's an update\n                // AND we already know it's possible it could have changed\n                // this updates the element's css classes, attrs, props, listeners, etc.\n                updateElement(oldVNode, newVNode, isSvgMode);\n            }\n        }\n        if (BUILD.updatable && oldChildren !== null && newChildren !== null) {\n            // looks like there's child vnodes for both the old and new vnodes\n            // so we need to call `updateChildren` to reconcile them\n            updateChildren(elm, oldChildren, newVNode, newChildren);\n        }\n        else if (newChildren !== null) {\n            // no old child vnodes, but there are new child vnodes to add\n            if (BUILD.updatable && BUILD.vdomText && oldVNode.$text$ !== null) {\n                // the old vnode was text, so be sure to clear it out\n                elm.textContent = '';\n            }\n            // add the new vnode children\n            addVnodes(elm, null, newVNode, newChildren, 0, newChildren.length - 1);\n        }\n        else if (BUILD.updatable && oldChildren !== null) {\n            // no new child vnodes, but there are old child vnodes to remove\n            removeVnodes(oldChildren, 0, oldChildren.length - 1);\n        }\n        if (BUILD.svg && isSvgMode && tag === 'svg') {\n            isSvgMode = false;\n        }\n    }\n    else if (BUILD.vdomText && BUILD.slotRelocation && (defaultHolder = elm['s-cr'])) {\n        // this element has slotted content\n        defaultHolder.parentNode.textContent = text;\n    }\n    else if (BUILD.vdomText && oldVNode.$text$ !== text) {\n        // update the text content for the text only vnode\n        // and also only if the text is different than before\n        elm.data = text;\n    }\n};\nconst updateFallbackSlotVisibility = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    const childNodes = elm.childNodes;\n    let childNode;\n    let i;\n    let ilen;\n    let j;\n    let slotNameAttr;\n    let nodeType;\n    for (i = 0, ilen = childNodes.length; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode.nodeType === 1 /* NODE_TYPE.ElementNode */) {\n            if (childNode['s-sr']) {\n                // this is a slot fallback node\n                // get the slot name for this slot reference node\n                slotNameAttr = childNode['s-sn'];\n                // by default always show a fallback slot node\n                // then hide it if there are other slots in the light dom\n                childNode.hidden = false;\n                for (j = 0; j < ilen; j++) {\n                    nodeType = childNodes[j].nodeType;\n                    if (childNodes[j]['s-hn'] !== childNode['s-hn'] || slotNameAttr !== '') {\n                        // this sibling node is from a different component OR is a named fallback slot node\n                        if (nodeType === 1 /* NODE_TYPE.ElementNode */ && slotNameAttr === childNodes[j].getAttribute('slot')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                    else {\n                        // this is a default fallback slot node\n                        // any element or text node (with content)\n                        // should hide the default fallback slot node\n                        if (nodeType === 1 /* NODE_TYPE.ElementNode */ ||\n                            (nodeType === 3 /* NODE_TYPE.TextNode */ && childNodes[j].textContent.trim() !== '')) {\n                            childNode.hidden = true;\n                            break;\n                        }\n                    }\n                }\n            }\n            // keep drilling down\n            updateFallbackSlotVisibility(childNode);\n        }\n    }\n};\nconst relocateNodes = [];\nconst relocateSlotContent = (elm) => {\n    // tslint:disable-next-line: prefer-const\n    let childNode;\n    let node;\n    let hostContentNodes;\n    let slotNameAttr;\n    let relocateNodeData;\n    let j;\n    let i = 0;\n    const childNodes = elm.childNodes;\n    const ilen = childNodes.length;\n    for (; i < ilen; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && (node = childNode['s-cr']) && node.parentNode) {\n            // first got the content reference comment node\n            // then we got it's parent, which is where all the host content is in now\n            hostContentNodes = node.parentNode.childNodes;\n            slotNameAttr = childNode['s-sn'];\n            for (j = hostContentNodes.length - 1; j >= 0; j--) {\n                node = hostContentNodes[j];\n                if (!node['s-cn'] && !node['s-nr'] && node['s-hn'] !== childNode['s-hn']) {\n                    // let's do some relocating to its new home\n                    // but never relocate a content reference node\n                    // that is suppose to always represent the original content location\n                    if (isNodeLocatedInSlot(node, slotNameAttr)) {\n                        // it's possible we've already decided to relocate this node\n                        relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                        // made some changes to slots\n                        // let's make sure we also double check\n                        // fallbacks are correctly hidden or shown\n                        checkSlotFallbackVisibility = true;\n                        node['s-sn'] = node['s-sn'] || slotNameAttr;\n                        if (relocateNodeData) {\n                            // previously we never found a slot home for this node\n                            // but turns out we did, so let's remember it now\n                            relocateNodeData.$slotRefNode$ = childNode;\n                        }\n                        else {\n                            // add to our list of nodes to relocate\n                            relocateNodes.push({\n                                $slotRefNode$: childNode,\n                                $nodeToRelocate$: node,\n                            });\n                        }\n                        if (node['s-sr']) {\n                            relocateNodes.map((relocateNode) => {\n                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node['s-sn'])) {\n                                    relocateNodeData = relocateNodes.find((r) => r.$nodeToRelocate$ === node);\n                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {\n                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;\n                                    }\n                                }\n                            });\n                        }\n                    }\n                    else if (!relocateNodes.some((r) => r.$nodeToRelocate$ === node)) {\n                        // so far this element does not have a slot home, not setting slotRefNode on purpose\n                        // if we never find a home for this element then we'll need to hide it\n                        relocateNodes.push({\n                            $nodeToRelocate$: node,\n                        });\n                    }\n                }\n            }\n        }\n        if (childNode.nodeType === 1 /* NODE_TYPE.ElementNode */) {\n            relocateSlotContent(childNode);\n        }\n    }\n};\nconst isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr) => {\n    if (nodeToRelocate.nodeType === 1 /* NODE_TYPE.ElementNode */) {\n        if (nodeToRelocate.getAttribute('slot') === null && slotNameAttr === '') {\n            return true;\n        }\n        if (nodeToRelocate.getAttribute('slot') === slotNameAttr) {\n            return true;\n        }\n        return false;\n    }\n    if (nodeToRelocate['s-sn'] === slotNameAttr) {\n        return true;\n    }\n    return slotNameAttr === '';\n};\nconst callNodeRefs = (vNode) => {\n    if (BUILD.vdomRef) {\n        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);\n        vNode.$children$ && vNode.$children$.map(callNodeRefs);\n    }\n};\nconst renderVdom = (hostRef, renderFnResults) => {\n    const hostElm = hostRef.$hostElement$;\n    const cmpMeta = hostRef.$cmpMeta$;\n    const oldVNode = hostRef.$vnode$ || newVNode(null, null);\n    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);\n    hostTagName = hostElm.tagName;\n    // <Host> runtime check\n    if (BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {\n        throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of \"${hostTagName.toLowerCase()}\" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `);\n    }\n    if (BUILD.reflect && cmpMeta.$attrsToReflect$) {\n        rootVnode.$attrs$ = rootVnode.$attrs$ || {};\n        cmpMeta.$attrsToReflect$.map(([propName, attribute]) => (rootVnode.$attrs$[attribute] = hostElm[propName]));\n    }\n    rootVnode.$tag$ = null;\n    rootVnode.$flags$ |= 4 /* VNODE_FLAGS.isHost */;\n    hostRef.$vnode$ = rootVnode;\n    rootVnode.$elm$ = oldVNode.$elm$ = (BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm);\n    if (BUILD.scoped || BUILD.shadowDom) {\n        scopeId = hostElm['s-sc'];\n    }\n    if (BUILD.slotRelocation) {\n        contentRef = hostElm['s-cr'];\n        useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) !== 0;\n        // always reset\n        checkSlotFallbackVisibility = false;\n    }\n    // synchronous patch\n    patch(oldVNode, rootVnode);\n    if (BUILD.slotRelocation) {\n        // while we're moving nodes around existing nodes, temporarily disable\n        // the disconnectCallback from working\n        plt.$flags$ |= 1 /* PLATFORM_FLAGS.isTmpDisconnected */;\n        if (checkSlotRelocate) {\n            relocateSlotContent(rootVnode.$elm$);\n            let relocateData;\n            let nodeToRelocate;\n            let orgLocationNode;\n            let parentNodeRef;\n            let insertBeforeNode;\n            let refNode;\n            let i = 0;\n            for (; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (!nodeToRelocate['s-ol']) {\n                    // add a reference node marking this node's original location\n                    // keep a reference to this node for later lookups\n                    orgLocationNode =\n                        BUILD.isDebug || BUILD.hydrateServerSide\n                            ? originalLocationDebugNode(nodeToRelocate)\n                            : doc.createTextNode('');\n                    orgLocationNode['s-nr'] = nodeToRelocate;\n                    nodeToRelocate.parentNode.insertBefore((nodeToRelocate['s-ol'] = orgLocationNode), nodeToRelocate);\n                }\n            }\n            for (i = 0; i < relocateNodes.length; i++) {\n                relocateData = relocateNodes[i];\n                nodeToRelocate = relocateData.$nodeToRelocate$;\n                if (relocateData.$slotRefNode$) {\n                    // by default we're just going to insert it directly\n                    // after the slot reference node\n                    parentNodeRef = relocateData.$slotRefNode$.parentNode;\n                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;\n                    orgLocationNode = nodeToRelocate['s-ol'];\n                    while ((orgLocationNode = orgLocationNode.previousSibling)) {\n                        refNode = orgLocationNode['s-nr'];\n                        if (refNode && refNode['s-sn'] === nodeToRelocate['s-sn'] && parentNodeRef === refNode.parentNode) {\n                            refNode = refNode.nextSibling;\n                            if (!refNode || !refNode['s-nr']) {\n                                insertBeforeNode = refNode;\n                                break;\n                            }\n                        }\n                    }\n                    if ((!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode) ||\n                        nodeToRelocate.nextSibling !== insertBeforeNode) {\n                        // we've checked that it's worth while to relocate\n                        // since that the node to relocate\n                        // has a different next sibling or parent relocated\n                        if (nodeToRelocate !== insertBeforeNode) {\n                            if (!nodeToRelocate['s-hn'] && nodeToRelocate['s-ol']) {\n                                // probably a component in the index.html that doesn't have it's hostname set\n                                nodeToRelocate['s-hn'] = nodeToRelocate['s-ol'].parentNode.nodeName;\n                            }\n                            // add it back to the dom but in its new home\n                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);\n                        }\n                    }\n                }\n                else {\n                    // this node doesn't have a slot home to go to, so let's hide it\n                    if (nodeToRelocate.nodeType === 1 /* NODE_TYPE.ElementNode */) {\n                        nodeToRelocate.hidden = true;\n                    }\n                }\n            }\n        }\n        if (checkSlotFallbackVisibility) {\n            updateFallbackSlotVisibility(rootVnode.$elm$);\n        }\n        // done moving nodes around\n        // allow the disconnect callback to work again\n        plt.$flags$ &= ~1 /* PLATFORM_FLAGS.isTmpDisconnected */;\n        // always reset\n        relocateNodes.length = 0;\n    }\n};\n// slot comment debug nodes only created with the `--debug` flag\n// otherwise these nodes are text nodes w/out content\nconst slotReferenceDebugNode = (slotVNode) => doc.createComment(`<slot${slotVNode.$name$ ? ' name=\"' + slotVNode.$name$ + '\"' : ''}> (host=${hostTagName.toLowerCase()})`);\nconst originalLocationDebugNode = (nodeToRelocate) => doc.createComment(`org-location for ` +\n    (nodeToRelocate.localName\n        ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate['s-hn']})`\n        : `[${nodeToRelocate.textContent}]`));\nconst attachToAncestor = (hostRef, ancestorComponent) => {\n    if (BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent['s-p']) {\n        ancestorComponent['s-p'].push(new Promise((r) => (hostRef.$onRenderResolve$ = r)));\n    }\n};\nconst scheduleUpdate = (hostRef, isInitialLoad) => {\n    if (BUILD.taskQueue && BUILD.updatable) {\n        hostRef.$flags$ |= 16 /* HOST_FLAGS.isQueuedForUpdate */;\n    }\n    if (BUILD.asyncLoading && hostRef.$flags$ & 4 /* HOST_FLAGS.isWaitingForChildren */) {\n        hostRef.$flags$ |= 512 /* HOST_FLAGS.needsRerender */;\n        return;\n    }\n    attachToAncestor(hostRef, hostRef.$ancestorComponent$);\n    // there is no ancestor component or the ancestor component\n    // has already fired off its lifecycle update then\n    // fire off the initial update\n    const dispatch = () => dispatchHooks(hostRef, isInitialLoad);\n    return BUILD.taskQueue ? writeTask(dispatch) : dispatch();\n};\nconst dispatchHooks = (hostRef, isInitialLoad) => {\n    const elm = hostRef.$hostElement$;\n    const endSchedule = createTime('scheduleUpdate', hostRef.$cmpMeta$.$tagName$);\n    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    let promise;\n    if (isInitialLoad) {\n        if (BUILD.lazyLoad && BUILD.hostListener) {\n            hostRef.$flags$ |= 256 /* HOST_FLAGS.isListenReady */;\n            if (hostRef.$queuedListeners$) {\n                hostRef.$queuedListeners$.map(([methodName, event]) => safeCall(instance, methodName, event));\n                hostRef.$queuedListeners$ = null;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentWillLoad');\n        if (BUILD.cmpWillLoad) {\n            promise = safeCall(instance, 'componentWillLoad');\n        }\n    }\n    else {\n        emitLifecycleEvent(elm, 'componentWillUpdate');\n        if (BUILD.cmpWillUpdate) {\n            promise = safeCall(instance, 'componentWillUpdate');\n        }\n    }\n    emitLifecycleEvent(elm, 'componentWillRender');\n    if (BUILD.cmpWillRender) {\n        promise = then(promise, () => safeCall(instance, 'componentWillRender'));\n    }\n    endSchedule();\n    return then(promise, () => updateComponent(hostRef, instance, isInitialLoad));\n};\nconst updateComponent = async (hostRef, instance, isInitialLoad) => {\n    // updateComponent\n    const elm = hostRef.$hostElement$;\n    const endUpdate = createTime('update', hostRef.$cmpMeta$.$tagName$);\n    const rc = elm['s-rc'];\n    if (BUILD.style && isInitialLoad) {\n        // DOM WRITE!\n        attachStyles(hostRef);\n    }\n    const endRender = createTime('render', hostRef.$cmpMeta$.$tagName$);\n    if (BUILD.isDev) {\n        hostRef.$flags$ |= 1024 /* HOST_FLAGS.devOnRender */;\n    }\n\n    //========= PDS PATCH START\n    if (elm.hasDSR) {\n        elm.shadowRoot.innerHTML = '';\n        delete elm.hasDSR;\n    }\n    //========= PDS PATCH END\n\n    if (BUILD.hydrateServerSide) {\n        await callRender(hostRef, instance, elm);\n    }\n    else {\n        callRender(hostRef, instance, elm);\n    }\n    if (BUILD.cssVarShim && plt.$cssShim$) {\n        plt.$cssShim$.updateHost(elm);\n    }\n    if (BUILD.isDev) {\n        hostRef.$renderCount$++;\n        hostRef.$flags$ &= ~1024 /* HOST_FLAGS.devOnRender */;\n    }\n    if (BUILD.hydrateServerSide) {\n        try {\n            // manually connected child components during server-side hydrate\n            serverSideConnected(elm);\n            if (isInitialLoad) {\n                // using only during server-side hydrate\n                if (hostRef.$cmpMeta$.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {\n                    elm['s-en'] = '';\n                }\n                else if (hostRef.$cmpMeta$.$flags$ & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {\n                    elm['s-en'] = 'c';\n                }\n            }\n        }\n        catch (e) {\n            consoleError(e, elm);\n        }\n    }\n    if (BUILD.asyncLoading && rc) {\n        // ok, so turns out there are some child host elements\n        // waiting on this parent element to load\n        // let's fire off all update callbacks waiting\n        rc.map((cb) => cb());\n        elm['s-rc'] = undefined;\n    }\n    endRender();\n    endUpdate();\n    if (BUILD.asyncLoading) {\n        const childrenPromises = elm['s-p'];\n        const postUpdate = () => postUpdateComponent(hostRef);\n        if (childrenPromises.length === 0) {\n            postUpdate();\n        }\n        else {\n            Promise.all(childrenPromises).then(postUpdate);\n            hostRef.$flags$ |= 4 /* HOST_FLAGS.isWaitingForChildren */;\n            childrenPromises.length = 0;\n        }\n    }\n    else {\n        postUpdateComponent(hostRef);\n    }\n};\nconst callRender = (hostRef, instance, elm) => {\n    // in order for bundlers to correctly treeshake the BUILD object\n    // we need to ensure BUILD is not deoptimized within a try/catch\n    // https://rollupjs.org/guide/en/#treeshake tryCatchDeoptimization\n    const allRenderFn = BUILD.allRenderFn ? true : false;\n    const lazyLoad = BUILD.lazyLoad ? true : false;\n    const taskQueue = BUILD.taskQueue ? true : false;\n    const updatable = BUILD.updatable ? true : false;\n    try {\n        renderingRef = instance;\n        instance = allRenderFn ? instance.render() : instance.render && instance.render();\n        if (updatable && taskQueue) {\n            hostRef.$flags$ &= ~16 /* HOST_FLAGS.isQueuedForUpdate */;\n        }\n        if (updatable || lazyLoad) {\n            hostRef.$flags$ |= 2 /* HOST_FLAGS.hasRendered */;\n        }\n        if (BUILD.hasRenderFn || BUILD.reflect) {\n            if (BUILD.vdomRender || BUILD.reflect) {\n                // looks like we've got child nodes to render into this host element\n                // or we need to update the css class/attrs on the host element\n                // DOM WRITE!\n                if (BUILD.hydrateServerSide) {\n                    return Promise.resolve(instance).then((value) => renderVdom(hostRef, value));\n                }\n                else {\n                    renderVdom(hostRef, instance);\n                }\n            }\n            else {\n                elm.textContent = instance;\n            }\n        }\n    }\n    catch (e) {\n        consoleError(e, hostRef.$hostElement$);\n    }\n    renderingRef = null;\n    return null;\n};\nconst getRenderingRef = () => renderingRef;\nconst postUpdateComponent = (hostRef) => {\n    const tagName = hostRef.$cmpMeta$.$tagName$;\n    const elm = hostRef.$hostElement$;\n    const endPostUpdate = createTime('postUpdate', tagName);\n    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    if (BUILD.cmpDidRender) {\n        if (BUILD.isDev) {\n            hostRef.$flags$ |= 1024 /* HOST_FLAGS.devOnRender */;\n        }\n        safeCall(instance, 'componentDidRender');\n        if (BUILD.isDev) {\n            hostRef.$flags$ &= ~1024 /* HOST_FLAGS.devOnRender */;\n        }\n    }\n    emitLifecycleEvent(elm, 'componentDidRender');\n    if (!(hostRef.$flags$ & 64 /* HOST_FLAGS.hasLoadedComponent */)) {\n        hostRef.$flags$ |= 64 /* HOST_FLAGS.hasLoadedComponent */;\n        if (BUILD.asyncLoading && BUILD.cssAnnotations) {\n            // DOM WRITE!\n            addHydratedFlag(elm);\n        }\n        if (BUILD.cmpDidLoad) {\n            if (BUILD.isDev) {\n                hostRef.$flags$ |= 2048 /* HOST_FLAGS.devOnDidLoad */;\n            }\n            safeCall(instance, 'componentDidLoad');\n            if (BUILD.isDev) {\n                hostRef.$flags$ &= ~2048 /* HOST_FLAGS.devOnDidLoad */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidLoad');\n        endPostUpdate();\n        if (BUILD.asyncLoading) {\n            hostRef.$onReadyResolve$(elm);\n            if (!ancestorComponent) {\n                appDidLoad(tagName);\n            }\n        }\n    }\n    else {\n        if (BUILD.cmpDidUpdate) {\n            // we've already loaded this component\n            // fire off the user's componentDidUpdate method (if one was provided)\n            // componentDidUpdate runs AFTER render() has been called\n            // and all child components have finished updating\n            if (BUILD.isDev) {\n                hostRef.$flags$ |= 1024 /* HOST_FLAGS.devOnRender */;\n            }\n            safeCall(instance, 'componentDidUpdate');\n            if (BUILD.isDev) {\n                hostRef.$flags$ &= ~1024 /* HOST_FLAGS.devOnRender */;\n            }\n        }\n        emitLifecycleEvent(elm, 'componentDidUpdate');\n        endPostUpdate();\n    }\n    if (BUILD.hotModuleReplacement) {\n        elm['s-hmr-load'] && elm['s-hmr-load']();\n    }\n    if (BUILD.method && BUILD.lazyLoad) {\n        hostRef.$onInstanceResolve$(elm);\n    }\n    // load events fire from bottom to top\n    // the deepest elements load first then bubbles up\n    if (BUILD.asyncLoading) {\n        if (hostRef.$onRenderResolve$) {\n            hostRef.$onRenderResolve$();\n            hostRef.$onRenderResolve$ = undefined;\n        }\n        if (hostRef.$flags$ & 512 /* HOST_FLAGS.needsRerender */) {\n            nextTick(() => scheduleUpdate(hostRef, false));\n        }\n        hostRef.$flags$ &= ~(4 /* HOST_FLAGS.isWaitingForChildren */ | 512 /* HOST_FLAGS.needsRerender */);\n    }\n    // ( •_•)\n    // ( •_•)>⌐■-■\n    // (⌐■_■)\n};\nconst forceUpdate = (ref) => {\n    if (BUILD.updatable) {\n        const hostRef = getHostRef(ref);\n        const isConnected = hostRef.$hostElement$.isConnected;\n        if (isConnected &&\n            (hostRef.$flags$ & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {\n            scheduleUpdate(hostRef, false);\n        }\n        // Returns \"true\" when the forced update was successfully scheduled\n        return isConnected;\n    }\n    return false;\n};\nconst appDidLoad = (who) => {\n    // on appload\n    // we have finish the first big initial render\n    if (BUILD.cssAnnotations) {\n        addHydratedFlag(doc.documentElement);\n    }\n    if (BUILD.asyncQueue) {\n        plt.$flags$ |= 2 /* PLATFORM_FLAGS.appLoaded */;\n    }\n    nextTick(() => emitEvent(win, 'appload', { detail: { namespace: NAMESPACE } }));\n    if (BUILD.profile && performance.measure) {\n        performance.measure(`[Stencil] ${NAMESPACE} initial load (by ${who})`, 'st:app:start');\n    }\n};\nconst safeCall = (instance, method, arg) => {\n    if (instance && instance[method]) {\n        try {\n            return instance[method](arg);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    return undefined;\n};\nconst then = (promise, thenFn) => {\n    return promise && promise.then ? promise.then(thenFn) : thenFn();\n};\nconst emitLifecycleEvent = (elm, lifecycleName) => {\n    if (BUILD.lifecycleDOMEvents) {\n        emitEvent(elm, 'stencil_' + lifecycleName, {\n            bubbles: true,\n            composed: true,\n            detail: {\n                namespace: NAMESPACE,\n            },\n        });\n    }\n};\nconst addHydratedFlag = (elm) => BUILD.hydratedClass\n    ? elm.classList.add('hydrated')\n    : BUILD.hydratedAttribute\n        ? elm.setAttribute('hydrated', '')\n        : undefined;\nconst serverSideConnected = (elm) => {\n    const children = elm.children;\n    if (children != null) {\n        for (let i = 0, ii = children.length; i < ii; i++) {\n            const childElm = children[i];\n            if (typeof childElm.connectedCallback === 'function') {\n                childElm.connectedCallback();\n            }\n            serverSideConnected(childElm);\n        }\n    }\n};\nconst getValue = (ref, propName) => getHostRef(ref).$instanceValues$.get(propName);\nconst setValue = (ref, propName, newVal, cmpMeta) => {\n    // check our new property value against our internal value\n    const hostRef = getHostRef(ref);\n    const elm = BUILD.lazyLoad ? hostRef.$hostElement$ : ref;\n    const oldVal = hostRef.$instanceValues$.get(propName);\n    const flags = hostRef.$flags$;\n    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);\n    // explicitly check for NaN on both sides, as `NaN === NaN` is always false\n    const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);\n    const didValueChange = newVal !== oldVal && !areBothNaN;\n    if ((!BUILD.lazyLoad || !(flags & 8 /* HOST_FLAGS.isConstructingInstance */) || oldVal === undefined) && didValueChange) {\n        // gadzooks! the property's value has changed!!\n        // set our new value!\n        hostRef.$instanceValues$.set(propName, newVal);\n        if (BUILD.isDev) {\n            if (hostRef.$flags$ & 1024 /* HOST_FLAGS.devOnRender */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n            else if (hostRef.$flags$ & 2048 /* HOST_FLAGS.devOnDidLoad */) {\n                consoleDevWarn(`The state/prop \"${propName}\" changed during \"componentDidLoad()\", this triggers extra re-renders, try to setup on \"componentWillLoad()\"`, '\\nElement', elm, '\\nNew value', newVal, '\\nOld value', oldVal);\n            }\n        }\n        if (!BUILD.lazyLoad || instance) {\n            // get an array of method names of watch functions to call\n            if (BUILD.watchCallback && cmpMeta.$watchers$ && flags & 128 /* HOST_FLAGS.isWatchReady */) {\n                const watchMethods = cmpMeta.$watchers$[propName];\n                if (watchMethods) {\n                    // this instance is watching for when this property changed\n                    watchMethods.map((watchMethodName) => {\n                        try {\n                            // fire off each of the watch methods that are watching this property\n                            instance[watchMethodName](newVal, oldVal, propName);\n                        }\n                        catch (e) {\n                            consoleError(e, elm);\n                        }\n                    });\n                }\n            }\n            if (BUILD.updatable &&\n                (flags & (2 /* HOST_FLAGS.hasRendered */ | 16 /* HOST_FLAGS.isQueuedForUpdate */)) === 2 /* HOST_FLAGS.hasRendered */) {\n                if (BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {\n                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {\n                        return;\n                    }\n                }\n                // looks like this value actually changed, so we've got work to do!\n                // but only if we've already rendered, otherwise just chill out\n                // queue that we need to do an update, but don't worry about queuing\n                // up millions cuz this function ensures it only runs once\n                scheduleUpdate(hostRef, false);\n            }\n        }\n    }\n};\n/**\n * Attach a series of runtime constructs to a compiled Stencil component\n * constructor, including getters and setters for the `@Prop` and `@State`\n * decorators, callbacks for when attributes change, and so on.\n *\n * @param Cstr the constructor for a component that we need to process\n * @param cmpMeta metadata collected previously about the component\n * @param flags a number used to store a series of bit flags\n * @returns a reference to the same constructor passed in (but now mutated)\n */\nconst proxyComponent = (Cstr, cmpMeta, flags) => {\n    if (BUILD.member && cmpMeta.$members$) {\n        if (BUILD.watchCallback && Cstr.watchers) {\n            cmpMeta.$watchers$ = Cstr.watchers;\n        }\n        // It's better to have a const than two Object.entries()\n        const members = Object.entries(cmpMeta.$members$);\n        const prototype = Cstr.prototype;\n        members.map(([memberName, [memberFlags]]) => {\n            if ((BUILD.prop || BUILD.state) &&\n                (memberFlags & 31 /* MEMBER_FLAGS.Prop */ ||\n                    ((!BUILD.lazyLoad || flags & 2 /* PROXY_FLAGS.proxyState */) && memberFlags & 32 /* MEMBER_FLAGS.State */))) {\n                // proxyComponent - prop\n                Object.defineProperty(prototype, memberName, {\n                    get() {\n                        // proxyComponent, get value\n                        return getValue(this, memberName);\n                    },\n                    set(newValue) {\n                        // only during dev time\n                        if (BUILD.isDev) {\n                            const ref = getHostRef(this);\n                            if (\n                            // we are proxying the instance (not element)\n                            (flags & 1 /* PROXY_FLAGS.isElementConstructor */) === 0 &&\n                                // the element is not constructing\n                                (ref.$flags$ & 8 /* HOST_FLAGS.isConstructingInstance */) === 0 &&\n                                // the member is a prop\n                                (memberFlags & 31 /* MEMBER_FLAGS.Prop */) !== 0 &&\n                                // the member is not mutable\n                                (memberFlags & 1024 /* MEMBER_FLAGS.Mutable */) === 0) {\n                                consoleDevWarn(`@Prop() \"${memberName}\" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.\\nMore information: https://stenciljs.com/docs/properties#prop-mutability`);\n                            }\n                        }\n                        // proxyComponent, set value\n                        setValue(this, memberName, newValue, cmpMeta);\n                    },\n                    configurable: true,\n                    enumerable: true,\n                });\n            }\n            else if (BUILD.lazyLoad &&\n                BUILD.method &&\n                flags & 1 /* PROXY_FLAGS.isElementConstructor */ &&\n                memberFlags & 64 /* MEMBER_FLAGS.Method */) {\n                // proxyComponent - method\n                Object.defineProperty(prototype, memberName, {\n                    value(...args) {\n                        const ref = getHostRef(this);\n                        return ref.$onInstancePromise$.then(() => ref.$lazyInstance$[memberName](...args));\n                    },\n                });\n            }\n        });\n        if (BUILD.observeAttribute && (!BUILD.lazyLoad || flags & 1 /* PROXY_FLAGS.isElementConstructor */)) {\n            const attrNameToPropName = new Map();\n            prototype.attributeChangedCallback = function (attrName, _oldValue, newValue) {\n                plt.jmp(() => {\n                    const propName = attrNameToPropName.get(attrName);\n                    //  In a web component lifecycle the attributeChangedCallback runs prior to connectedCallback\n                    //  in the case where an attribute was set inline.\n                    //  ```html\n                    //    <my-component some-attribute=\"some-value\"></my-component>\n                    //  ```\n                    //\n                    //  There is an edge case where a developer sets the attribute inline on a custom element and then\n                    //  programmatically changes it before it has been upgraded as shown below:\n                    //\n                    //  ```html\n                    //    <!-- this component has _not_ been upgraded yet -->\n                    //    <my-component id=\"test\" some-attribute=\"some-value\"></my-component>\n                    //    <script>\n                    //      // grab non-upgraded component\n                    //      el = document.querySelector(\"#test\");\n                    //      el.someAttribute = \"another-value\";\n                    //      // upgrade component\n                    //      customElements.define('my-component', MyComponent);\n                    //    </script>\n                    //  ```\n                    //  In this case if we do not unshadow here and use the value of the shadowing property, attributeChangedCallback\n                    //  will be called with `newValue = \"some-value\"` and will set the shadowed property (this.someAttribute = \"another-value\")\n                    //  to the value that was set inline i.e. \"some-value\" from above example. When\n                    //  the connectedCallback attempts to unshadow it will use \"some-value\" as the initial value rather than \"another-value\"\n                    //\n                    //  The case where the attribute was NOT set inline but was not set programmatically shall be handled/unshadowed\n                    //  by connectedCallback as this attributeChangedCallback will not fire.\n                    //\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n                    //\n                    //  TODO(STENCIL-16) we should think about whether or not we actually want to be reflecting the attributes to\n                    //  properties here given that this goes against best practices outlined here\n                    //  https://developers.google.com/web/fundamentals/web-components/best-practices#avoid-reentrancy\n                    if (this.hasOwnProperty(propName)) {\n                        newValue = this[propName];\n                        delete this[propName];\n                    }\n                    else if (prototype.hasOwnProperty(propName) &&\n                        typeof this[propName] === 'number' &&\n                        this[propName] == newValue) {\n                        // if the propName exists on the prototype of `Cstr`, this update may be a result of Stencil using native\n                        // APIs to reflect props as attributes. Calls to `setAttribute(someElement, propName)` will result in\n                        // `propName` to be converted to a `DOMString`, which may not be what we want for other primitive props.\n                        return;\n                    }\n                    this[propName] = newValue === null && typeof this[propName] === 'boolean' ? false : newValue;\n                });\n            };\n            // create an array of attributes to observe\n            // and also create a map of html attribute name to js property name\n            Cstr.observedAttributes = members\n                .filter(([_, m]) => m[0] & 15 /* MEMBER_FLAGS.HasAttribute */) // filter to only keep props that should match attributes\n                .map(([propName, m]) => {\n                const attrName = m[1] || propName;\n                attrNameToPropName.set(attrName, propName);\n                if (BUILD.reflect && m[0] & 512 /* MEMBER_FLAGS.ReflectAttr */) {\n                    cmpMeta.$attrsToReflect$.push([propName, attrName]);\n                }\n                return attrName;\n            });\n        }\n    }\n    return Cstr;\n};\nconst initializeComponent = async (elm, hostRef, cmpMeta, hmrVersionId, Cstr) => {\n    // initializeComponent\n    if ((BUILD.lazyLoad || BUILD.hydrateServerSide || BUILD.style) &&\n        (hostRef.$flags$ & 32 /* HOST_FLAGS.hasInitializedComponent */) === 0) {\n        if (BUILD.lazyLoad || BUILD.hydrateClientSide) {\n            // we haven't initialized this element yet\n            hostRef.$flags$ |= 32 /* HOST_FLAGS.hasInitializedComponent */;\n            // lazy loaded components\n            // request the component's implementation to be\n            // wired up with the host element\n            Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);\n            if (Cstr.then) {\n                // Await creates a micro-task avoid if possible\n                const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);\n                Cstr = await Cstr;\n                endLoad();\n            }\n            if ((BUILD.isDev || BUILD.isDebug) && !Cstr) {\n                throw new Error(`Constructor for \"${cmpMeta.$tagName$}#${hostRef.$modeName$}\" was not found`);\n            }\n            if (BUILD.member && !Cstr.isProxied) {\n                // we've never proxied this Constructor before\n                // let's add the getters/setters to its prototype before\n                // the first time we create an instance of the implementation\n                if (BUILD.watchCallback) {\n                    cmpMeta.$watchers$ = Cstr.watchers;\n                }\n                proxyComponent(Cstr, cmpMeta, 2 /* PROXY_FLAGS.proxyState */);\n                Cstr.isProxied = true;\n            }\n            const endNewInstance = createTime('createInstance', cmpMeta.$tagName$);\n            // ok, time to construct the instance\n            // but let's keep track of when we start and stop\n            // so that the getters/setters don't incorrectly step on data\n            if (BUILD.member) {\n                hostRef.$flags$ |= 8 /* HOST_FLAGS.isConstructingInstance */;\n            }\n            // construct the lazy-loaded component implementation\n            // passing the hostRef is very important during\n            // construction in order to directly wire together the\n            // host element and the lazy-loaded instance\n            try {\n                new Cstr(hostRef);\n            }\n            catch (e) {\n                consoleError(e);\n            }\n            if (BUILD.member) {\n                hostRef.$flags$ &= ~8 /* HOST_FLAGS.isConstructingInstance */;\n            }\n            if (BUILD.watchCallback) {\n                hostRef.$flags$ |= 128 /* HOST_FLAGS.isWatchReady */;\n            }\n            endNewInstance();\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        else {\n            // sync constructor component\n            Cstr = elm.constructor;\n            hostRef.$flags$ |= 32 /* HOST_FLAGS.hasInitializedComponent */;\n            // wait for the CustomElementRegistry to mark the component as ready before setting `isWatchReady`. Otherwise,\n            // watchers may fire prematurely if `customElements.get()`/`customElements.whenDefined()` resolves _before_\n            // Stencil has completed instantiating the component.\n            customElements.whenDefined(cmpMeta.$tagName$).then(() => (hostRef.$flags$ |= 128 /* HOST_FLAGS.isWatchReady */));\n        }\n        if (BUILD.style && Cstr.style) {\n            // this component has styles but we haven't registered them yet\n            let style = Cstr.style;\n            if (BUILD.mode && typeof style !== 'string') {\n                style = style[(hostRef.$modeName$ = computeMode(elm))];\n                if (BUILD.hydrateServerSide && hostRef.$modeName$) {\n                    elm.setAttribute('s-mode', hostRef.$modeName$);\n                }\n            }\n            const scopeId = getScopeId(cmpMeta, hostRef.$modeName$);\n            if (!styles.has(scopeId)) {\n                const endRegisterStyles = createTime('registerStyles', cmpMeta.$tagName$);\n                if (!BUILD.hydrateServerSide &&\n                    BUILD.shadowDom &&\n                    BUILD.shadowDomShim &&\n                    cmpMeta.$flags$ & 8 /* CMP_FLAGS.needsShadowDomShim */) {\n                    style = await import('./shadow-css.js').then((m) => m.scopeCss(style, scopeId, false));\n                }\n                registerStyle(scopeId, style, !!(cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */));\n                endRegisterStyles();\n            }\n        }\n    }\n    // we've successfully created a lazy instance\n    const ancestorComponent = hostRef.$ancestorComponent$;\n    const schedule = () => scheduleUpdate(hostRef, true);\n    if (BUILD.asyncLoading && ancestorComponent && ancestorComponent['s-rc']) {\n        // this is the initial load and this component it has an ancestor component\n        // but the ancestor component has NOT fired its will update lifecycle yet\n        // so let's just cool our jets and wait for the ancestor to continue first\n        // this will get fired off when the ancestor component\n        // finally gets around to rendering its lazy self\n        // fire off the initial update\n        ancestorComponent['s-rc'].push(schedule);\n    }\n    else {\n        schedule();\n    }\n};\nconst fireConnectedCallback = (instance) => {\n    if (BUILD.lazyLoad && BUILD.connectedCallback) {\n        safeCall(instance, 'connectedCallback');\n    }\n};\nconst connectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const cmpMeta = hostRef.$cmpMeta$;\n        const endConnected = createTime('connectedCallback', cmpMeta.$tagName$);\n        if (BUILD.hostListenerTargetParent) {\n            // only run if we have listeners being attached to a parent\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);\n        }\n        if (!(hostRef.$flags$ & 1 /* HOST_FLAGS.hasConnected */)) {\n            // first time this component has connected\n            hostRef.$flags$ |= 1 /* HOST_FLAGS.hasConnected */;\n            let hostId;\n            if (BUILD.hydrateClientSide) {\n                hostId = elm.getAttribute(HYDRATE_ID);\n                if (hostId) {\n                    if (BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {\n                        const scopeId = BUILD.mode\n                            ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute('s-mode'))\n                            : addStyle(elm.shadowRoot, cmpMeta);\n                        elm.classList.remove(scopeId + '-h', scopeId + '-s');\n                    }\n                    initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);\n                }\n            }\n            if (BUILD.slotRelocation && !hostId) {\n                // initUpdate\n                // if the slot polyfill is required we'll need to put some nodes\n                // in here to act as original content anchors as we move nodes around\n                // host element has been connected to the DOM\n                if (BUILD.hydrateServerSide ||\n                    ((BUILD.slot || BUILD.shadowDom) &&\n                        cmpMeta.$flags$ & (4 /* CMP_FLAGS.hasSlotRelocation */ | 8 /* CMP_FLAGS.needsShadowDomShim */))) {\n                    setContentReference(elm);\n                }\n            }\n            if (BUILD.asyncLoading) {\n                // find the first ancestor component (if there is one) and register\n                // this component as one of the actively loading child components for its ancestor\n                let ancestorComponent = elm;\n                while ((ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host)) {\n                    // climb up the ancestors looking for the first\n                    // component that hasn't finished its lifecycle update yet\n                    if ((BUILD.hydrateClientSide &&\n                        ancestorComponent.nodeType === 1 /* NODE_TYPE.ElementNode */ &&\n                        ancestorComponent.hasAttribute('s-id') &&\n                        ancestorComponent['s-p']) ||\n                        ancestorComponent['s-p']) {\n                        // we found this components first ancestor component\n                        // keep a reference to this component's ancestor component\n                        attachToAncestor(hostRef, (hostRef.$ancestorComponent$ = ancestorComponent));\n                        break;\n                    }\n                }\n            }\n            // Lazy properties\n            // https://developers.google.com/web/fundamentals/web-components/best-practices#lazy-properties\n            if (BUILD.prop && !BUILD.hydrateServerSide && cmpMeta.$members$) {\n                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]]) => {\n                    if (memberFlags & 31 /* MEMBER_FLAGS.Prop */ && elm.hasOwnProperty(memberName)) {\n                        const value = elm[memberName];\n                        delete elm[memberName];\n                        elm[memberName] = value;\n                    }\n                });\n            }\n            if (BUILD.initializeNextTick) {\n                // connectedCallback, taskQueue, initialLoad\n                // angular sets attribute AFTER connectCallback\n                // https://github.com/angular/angular/issues/18909\n                // https://github.com/angular/angular/issues/19940\n                nextTick(() => initializeComponent(elm, hostRef, cmpMeta));\n            }\n            else {\n                initializeComponent(elm, hostRef, cmpMeta);\n            }\n        }\n        else {\n            // not the first time this has connected\n            // reattach any event listeners to the host\n            // since they would have been removed when disconnected\n            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n            // fire off connectedCallback() on component instance\n            fireConnectedCallback(hostRef.$lazyInstance$);\n        }\n        endConnected();\n    }\n};\nconst setContentReference = (elm) => {\n    // only required when we're NOT using native shadow dom (slot)\n    // or this browser doesn't support native shadow dom\n    // and this host element was NOT created with SSR\n    // let's pick out the inner content for slot projection\n    // create a node to represent where the original\n    // content was first placed, which is useful later on\n    const contentRefElm = (elm['s-cr'] = doc.createComment(BUILD.isDebug ? `content-ref (host=${elm.localName})` : ''));\n    contentRefElm['s-cn'] = true;\n    elm.insertBefore(contentRefElm, elm.firstChild);\n};\nconst disconnectedCallback = (elm) => {\n    if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0) {\n        const hostRef = getHostRef(elm);\n        const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;\n        if (BUILD.hostListener) {\n            if (hostRef.$rmListeners$) {\n                hostRef.$rmListeners$.map((rmListener) => rmListener());\n                hostRef.$rmListeners$ = undefined;\n            }\n        }\n        // clear CSS var-shim tracking\n        if (BUILD.cssVarShim && plt.$cssShim$) {\n            plt.$cssShim$.removeHost(elm);\n        }\n        if (BUILD.lazyLoad && BUILD.disconnectedCallback) {\n            safeCall(instance, 'disconnectedCallback');\n        }\n        if (BUILD.cmpDidUnload) {\n            safeCall(instance, 'componentDidUnload');\n        }\n    }\n};\nconst defineCustomElement = (Cstr, compactMeta) => {\n    customElements.define(compactMeta[1], proxyCustomElement(Cstr, compactMeta));\n};\nconst proxyCustomElement = (Cstr, compactMeta) => {\n    const cmpMeta = {\n        $flags$: compactMeta[0],\n        $tagName$: compactMeta[1],\n    };\n    if (BUILD.member) {\n        cmpMeta.$members$ = compactMeta[2];\n    }\n    if (BUILD.hostListener) {\n        cmpMeta.$listeners$ = compactMeta[3];\n    }\n    if (BUILD.watchCallback) {\n        cmpMeta.$watchers$ = Cstr.$watchers$;\n    }\n    if (BUILD.reflect) {\n        cmpMeta.$attrsToReflect$ = [];\n    }\n    if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {\n        cmpMeta.$flags$ |= 8 /* CMP_FLAGS.needsShadowDomShim */;\n    }\n    const originalConnectedCallback = Cstr.prototype.connectedCallback;\n    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;\n    Object.assign(Cstr.prototype, {\n        __registerHost() {\n            registerHost(this, cmpMeta);\n        },\n        connectedCallback() {\n            connectedCallback(this);\n            if (BUILD.connectedCallback && originalConnectedCallback) {\n                originalConnectedCallback.call(this);\n            }\n        },\n        disconnectedCallback() {\n            disconnectedCallback(this);\n            if (BUILD.disconnectedCallback && originalDisconnectedCallback) {\n                originalDisconnectedCallback.call(this);\n            }\n        },\n        __attachShadow() {\n            if (supportsShadow) {\n                if (BUILD.shadowDelegatesFocus) {\n                    this.attachShadow({\n                        mode: 'open',\n                        delegatesFocus: !!(cmpMeta.$flags$ & 16 /* CMP_FLAGS.shadowDelegatesFocus */),\n                    });\n                }\n                else {\n                    this.attachShadow({ mode: 'open' });\n                }\n            }\n            else {\n                this.shadowRoot = this;\n            }\n        },\n    });\n    Cstr.is = cmpMeta.$tagName$;\n    return proxyComponent(Cstr, cmpMeta, 1 /* PROXY_FLAGS.isElementConstructor */ | 2 /* PROXY_FLAGS.proxyState */);\n};\nconst forceModeUpdate = (elm) => {\n    if (BUILD.style && BUILD.mode && !BUILD.lazyLoad) {\n        const mode = computeMode(elm);\n        const hostRef = getHostRef(elm);\n        if (hostRef.$modeName$ !== mode) {\n            const cmpMeta = hostRef.$cmpMeta$;\n            const oldScopeId = elm['s-sc'];\n            const scopeId = getScopeId(cmpMeta, mode);\n            const style = elm.constructor.style[mode];\n            const flags = cmpMeta.$flags$;\n            if (style) {\n                if (!styles.has(scopeId)) {\n                    registerStyle(scopeId, style, !!(flags & 1 /* CMP_FLAGS.shadowDomEncapsulation */));\n                }\n                hostRef.$modeName$ = mode;\n                elm.classList.remove(oldScopeId + '-h', oldScopeId + '-s');\n                attachStyles(hostRef);\n                forceUpdate(elm);\n            }\n        }\n    }\n};\nconst patchCloneNode = (HostElementPrototype) => {\n    const orgCloneNode = HostElementPrototype.cloneNode;\n    HostElementPrototype.cloneNode = function (deep) {\n        const srcNode = this;\n        const isShadowDom = BUILD.shadowDom ? srcNode.shadowRoot && supportsShadow : false;\n        const clonedNode = orgCloneNode.call(srcNode, isShadowDom ? deep : false);\n        if (BUILD.slot && !isShadowDom && deep) {\n            let i = 0;\n            let slotted, nonStencilNode;\n            const stencilPrivates = [\n                's-id',\n                's-cr',\n                's-lr',\n                's-rc',\n                's-sc',\n                's-p',\n                's-cn',\n                's-sr',\n                's-sn',\n                's-hn',\n                's-ol',\n                's-nr',\n                's-si',\n            ];\n            for (; i < srcNode.childNodes.length; i++) {\n                slotted = srcNode.childNodes[i]['s-nr'];\n                nonStencilNode = stencilPrivates.every((privateField) => !srcNode.childNodes[i][privateField]);\n                if (slotted) {\n                    if (BUILD.appendChildSlotFix && clonedNode.__appendChild) {\n                        clonedNode.__appendChild(slotted.cloneNode(true));\n                    }\n                    else {\n                        clonedNode.appendChild(slotted.cloneNode(true));\n                    }\n                }\n                if (nonStencilNode) {\n                    clonedNode.appendChild(srcNode.childNodes[i].cloneNode(true));\n                }\n            }\n        }\n        return clonedNode;\n    };\n};\nconst patchSlotAppendChild = (HostElementPrototype) => {\n    HostElementPrototype.__appendChild = HostElementPrototype.appendChild;\n    HostElementPrototype.appendChild = function (newChild) {\n        const slotName = (newChild['s-sn'] = getSlotName(newChild));\n        const slotNode = getHostSlotNode(this.childNodes, slotName);\n        if (slotNode) {\n            const slotChildNodes = getHostSlotChildNodes(slotNode, slotName);\n            const appendAfter = slotChildNodes[slotChildNodes.length - 1];\n            return appendAfter.parentNode.insertBefore(newChild, appendAfter.nextSibling);\n        }\n        return this.__appendChild(newChild);\n    };\n};\n/**\n * Patches the text content of an unnamed slotted node inside a scoped component\n * @param hostElementPrototype the `Element` to be patched\n * @param cmpMeta component runtime metadata used to determine if the component should be patched or not\n */\nconst patchTextContent = (hostElementPrototype, cmpMeta) => {\n    if (BUILD.scoped && cmpMeta.$flags$ & 2 /* CMP_FLAGS.scopedCssEncapsulation */) {\n        const descriptor = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent');\n        Object.defineProperty(hostElementPrototype, '__textContent', descriptor);\n        Object.defineProperty(hostElementPrototype, 'textContent', {\n            get() {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ be found in the next sibling (text) node, depending on how\n                // nodes were reordered during the vdom render. first try to get the text content from the sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* NODE_TYPES.TEXT_NODE */) {\n                    return slotNode.nextSibling.textContent;\n                }\n                else if (slotNode) {\n                    return slotNode.textContent;\n                }\n                else {\n                    // fallback to the original implementation\n                    return this.__textContent;\n                }\n            },\n            set(value) {\n                var _a;\n                // get the 'default slot', which would be the first slot in a shadow tree (if we were using one), whose name is\n                // the empty string\n                const slotNode = getHostSlotNode(this.childNodes, '');\n                // when a slot node is found, the textContent _may_ need to be placed in the next sibling (text) node,\n                // depending on how nodes were reordered during the vdom render. first try to set the text content on the\n                // sibling.\n                if (((_a = slotNode === null || slotNode === void 0 ? void 0 : slotNode.nextSibling) === null || _a === void 0 ? void 0 : _a.nodeType) === 3 /* NODE_TYPES.TEXT_NODE */) {\n                    slotNode.nextSibling.textContent = value;\n                }\n                else if (slotNode) {\n                    slotNode.textContent = value;\n                }\n                else {\n                    // we couldn't find a slot, but that doesn't mean that there isn't one. if this check ran before the DOM\n                    // loaded, we could have missed it. check for a content reference element on the scoped component and insert\n                    // it there\n                    this.__textContent = value;\n                    const contentRefElm = this['s-cr'];\n                    if (contentRefElm) {\n                        this.insertBefore(contentRefElm, this.firstChild);\n                    }\n                }\n            },\n        });\n    }\n};\nconst patchChildSlotNodes = (elm, cmpMeta) => {\n    class FakeNodeList extends Array {\n        item(n) {\n            return this[n];\n        }\n    }\n    if (cmpMeta.$flags$ & 8 /* CMP_FLAGS.needsShadowDomShim */) {\n        const childNodesFn = elm.__lookupGetter__('childNodes');\n        Object.defineProperty(elm, 'children', {\n            get() {\n                return this.childNodes.map((n) => n.nodeType === 1);\n            },\n        });\n        Object.defineProperty(elm, 'childElementCount', {\n            get() {\n                return elm.children.length;\n            },\n        });\n        Object.defineProperty(elm, 'childNodes', {\n            get() {\n                const childNodes = childNodesFn.call(this);\n                if ((plt.$flags$ & 1 /* PLATFORM_FLAGS.isTmpDisconnected */) === 0 &&\n                    getHostRef(this).$flags$ & 2 /* HOST_FLAGS.hasRendered */) {\n                    const result = new FakeNodeList();\n                    for (let i = 0; i < childNodes.length; i++) {\n                        const slot = childNodes[i]['s-nr'];\n                        if (slot) {\n                            result.push(slot);\n                        }\n                    }\n                    return result;\n                }\n                return FakeNodeList.from(childNodes);\n            },\n        });\n    }\n};\nconst getSlotName = (node) => node['s-sn'] || (node.nodeType === 1 && node.getAttribute('slot')) || '';\n/**\n * Recursively searches a series of child nodes for a slot with the provided name.\n * @param childNodes the nodes to search for a slot with a specific name.\n * @param slotName the name of the slot to match on.\n * @returns a reference to the slot node that matches the provided name, `null` otherwise\n */\nconst getHostSlotNode = (childNodes, slotName) => {\n    let i = 0;\n    let childNode;\n    for (; i < childNodes.length; i++) {\n        childNode = childNodes[i];\n        if (childNode['s-sr'] && childNode['s-sn'] === slotName) {\n            return childNode;\n        }\n        childNode = getHostSlotNode(childNode.childNodes, slotName);\n        if (childNode) {\n            return childNode;\n        }\n    }\n    return null;\n};\nconst getHostSlotChildNodes = (n, slotName) => {\n    const childNodes = [n];\n    while ((n = n.nextSibling) && n['s-sn'] === slotName) {\n        childNodes.push(n);\n    }\n    return childNodes;\n};\nconst hmrStart = (elm, cmpMeta, hmrVersionId) => {\n    // ¯\\_(ツ)_/¯\n    const hostRef = getHostRef(elm);\n    // reset state flags to only have been connected\n    hostRef.$flags$ = 1 /* HOST_FLAGS.hasConnected */;\n    // TODO\n    // detatch any event listeners that may have been added\n    // because we're not passing an exact event name it'll\n    // remove all of this element's event, which is good\n    // create a callback for when this component finishes hmr\n    elm['s-hmr-load'] = () => {\n        // finished hmr for this element\n        delete elm['s-hmr-load'];\n    };\n    // re-initialize the component\n    initializeComponent(elm, hostRef, cmpMeta, hmrVersionId);\n};\nconst bootstrapLazy = (lazyBundles, options = {}) => {\n    if (BUILD.profile && performance.mark) {\n        performance.mark('st:app:start');\n    }\n    installDevTools();\n    const endBootstrap = createTime('bootstrapLazy');\n    const cmpTags = [];\n    const exclude = options.exclude || [];\n    const customElements = win.customElements;\n    const head = doc.head;\n    const metaCharset = /*@__PURE__*/ head.querySelector('meta[charset]');\n    const visibilityStyle = /*@__PURE__*/ doc.createElement('style');\n    const deferredConnectedCallbacks = [];\n    const styles = /*@__PURE__*/ doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);\n    let appLoadFallback;\n    let isBootstrapping = true;\n    let i = 0;\n    Object.assign(plt, options);\n    plt.$resourcesUrl$ = new URL(options.resourcesUrl || './', doc.baseURI).href;\n    if (BUILD.asyncQueue) {\n        if (options.syncQueue) {\n            plt.$flags$ |= 4 /* PLATFORM_FLAGS.queueSync */;\n        }\n    }\n    if (BUILD.hydrateClientSide) {\n        // If the app is already hydrated there is not point to disable the\n        // async queue. This will improve the first input delay\n        plt.$flags$ |= 2 /* PLATFORM_FLAGS.appLoaded */;\n    }\n    if (BUILD.hydrateClientSide && BUILD.shadowDom) {\n        for (; i < styles.length; i++) {\n            registerStyle(styles[i].getAttribute(HYDRATED_STYLE_ID), convertScopedToShadow(styles[i].innerHTML), true);\n        }\n    }\n    lazyBundles.map((lazyBundle) => {\n        lazyBundle[1].map((compactMeta) => {\n            const cmpMeta = {\n                $flags$: compactMeta[0],\n                $tagName$: compactMeta[1],\n                $members$: compactMeta[2],\n                $listeners$: compactMeta[3],\n            };\n            if (BUILD.member) {\n                cmpMeta.$members$ = compactMeta[2];\n            }\n            if (BUILD.hostListener) {\n                cmpMeta.$listeners$ = compactMeta[3];\n            }\n            if (BUILD.reflect) {\n                cmpMeta.$attrsToReflect$ = [];\n            }\n            if (BUILD.watchCallback) {\n                cmpMeta.$watchers$ = {};\n            }\n            if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {\n                cmpMeta.$flags$ |= 8 /* CMP_FLAGS.needsShadowDomShim */;\n            }\n            const tagName = BUILD.transformTagName && options.transformTagName\n                ? options.transformTagName(cmpMeta.$tagName$)\n                : cmpMeta.$tagName$;\n            const HostElement = class extends HTMLElement {\n                // StencilLazyHost\n                constructor(self) {\n                    // @ts-ignore\n                    super(self);\n                    self = this;\n                    registerHost(self, cmpMeta);\n                    if (BUILD.shadowDom && cmpMeta.$flags$ & 1 /* CMP_FLAGS.shadowDomEncapsulation */) {\n                        // this component is using shadow dom\n                        // and this browser supports shadow dom\n                        // add the read-only property \"shadowRoot\" to the host element\n                        // adding the shadow root build conditionals to minimize runtime\n                        if (supportsShadow) {\n                            //========= PDS PATCH START\n                            let ssrInnerHTML = '';\n                            if (self.shadowRoot) {\n                              ssrInnerHTML = self.shadowRoot.innerHTML;\n                              self.hasDSR = true;\n                            }\n                            //========= PDS PATCH END\n\n                            if (BUILD.shadowDelegatesFocus) {\n                                //========= PDS PATCH START\n                                // in dsr ponyfilled browsers (e.g. Safari), the shadowRoot is already attached\n                                // and a 2nd attempt fails, therefore this needs to always run without SSR\n                                // and only with SSR for browsers that are not ponyfilled\n                                if (!self.hasDSR || HTMLTemplateElement.prototype.hasOwnProperty('shadowRoot')) {\n                                //========= PDS PATCH END\n\n                                self.attachShadow({\n                                    mode: 'open',\n                                    delegatesFocus: !!(cmpMeta.$flags$ & 16 /* CMP_FLAGS.shadowDelegatesFocus */),\n                                });\n\n                                //========= PDS PATCH START\n                                    self.shadowRoot.innerHTML = ssrInnerHTML;\n                                }\n                                //========= PDS PATCH END\n\n                            }\n                            else {\n                                self.attachShadow({ mode: 'open' });\n                            }\n                        }\n                        else if (!BUILD.hydrateServerSide && !('shadowRoot' in self)) {\n                            self.shadowRoot = self;\n                        }\n                    }\n                    if (BUILD.slotChildNodesFix) {\n                        patchChildSlotNodes(self, cmpMeta);\n                    }\n                }\n                connectedCallback() {\n                    if (appLoadFallback) {\n                        clearTimeout(appLoadFallback);\n                        appLoadFallback = null;\n                    }\n                    if (isBootstrapping) {\n                        // connectedCallback will be processed once all components have been registered\n                        deferredConnectedCallbacks.push(this);\n                    }\n                    else {\n                        plt.jmp(() => connectedCallback(this));\n                    }\n                }\n                disconnectedCallback() {\n                    plt.jmp(() => disconnectedCallback(this));\n                }\n                componentOnReady() {\n                    return getHostRef(this).$onReadyPromise$;\n                }\n            };\n            if (BUILD.cloneNodeFix) {\n                patchCloneNode(HostElement.prototype);\n            }\n            if (BUILD.appendChildSlotFix) {\n                patchSlotAppendChild(HostElement.prototype);\n            }\n            if (BUILD.hotModuleReplacement) {\n                HostElement.prototype['s-hmr'] = function (hmrVersionId) {\n                    hmrStart(this, cmpMeta, hmrVersionId);\n                };\n            }\n            if (BUILD.scopedSlotTextContentFix) {\n                patchTextContent(HostElement.prototype, cmpMeta);\n            }\n            cmpMeta.$lazyBundleId$ = lazyBundle[0];\n            if (!exclude.includes(tagName) && !customElements.get(tagName)) {\n                cmpTags.push(tagName);\n                customElements.define(tagName, proxyComponent(HostElement, cmpMeta, 1 /* PROXY_FLAGS.isElementConstructor */));\n            }\n        });\n    });\n    if (BUILD.invisiblePrehydration && (BUILD.hydratedClass || BUILD.hydratedAttribute)) {\n        visibilityStyle.innerHTML = cmpTags + HYDRATED_CSS;\n        visibilityStyle.setAttribute('data-styles', '');\n        head.insertBefore(visibilityStyle, metaCharset ? metaCharset.nextSibling : head.firstChild);\n    }\n    // Process deferred connectedCallbacks now all components have been registered\n    isBootstrapping = false;\n    if (deferredConnectedCallbacks.length) {\n        deferredConnectedCallbacks.map((host) => host.connectedCallback());\n    }\n    else {\n        if (BUILD.profile) {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30, 'timeout')));\n        }\n        else {\n            plt.jmp(() => (appLoadFallback = setTimeout(appDidLoad, 30)));\n        }\n    }\n    // Fallback appLoad event\n    endBootstrap();\n};\nconst getConnect = (_ref, tagName) => {\n    const componentOnReady = () => {\n        let elm = doc.querySelector(tagName);\n        if (!elm) {\n            elm = doc.createElement(tagName);\n            doc.body.appendChild(elm);\n        }\n        return typeof elm.componentOnReady === 'function' ? elm.componentOnReady() : Promise.resolve(elm);\n    };\n    const create = (...args) => {\n        return componentOnReady().then((el) => el.create(...args));\n    };\n    return {\n        create,\n        componentOnReady,\n    };\n};\nconst getContext = (_elm, context) => {\n    if (context in Context) {\n        return Context[context];\n    }\n    else if (context === 'window') {\n        return win;\n    }\n    else if (context === 'document') {\n        return doc;\n    }\n    else if (context === 'isServer' || context === 'isPrerender') {\n        return BUILD.hydrateServerSide ? true : false;\n    }\n    else if (context === 'isClient') {\n        return BUILD.hydrateServerSide ? false : true;\n    }\n    else if (context === 'resourcesUrl' || context === 'publicPath') {\n        return getAssetPath('.');\n    }\n    else if (context === 'queue') {\n        return {\n            write: writeTask,\n            read: readTask,\n            tick: {\n                then(cb) {\n                    return nextTick(cb);\n                },\n            },\n        };\n    }\n    return undefined;\n};\nconst Fragment = (_, children) => children;\nconst addHostEventListeners = (elm, hostRef, listeners, attachParentListeners) => {\n    if (BUILD.hostListener && listeners) {\n        // this is called immediately within the element's constructor\n        // initialize our event listeners on the host element\n        // we do this now so that we can listen to events that may\n        // have fired even before the instance is ready\n        if (BUILD.hostListenerTargetParent) {\n            // this component may have event listeners that should be attached to the parent\n            if (attachParentListeners) {\n                // this is being ran from within the connectedCallback\n                // which is important so that we know the host element actually has a parent element\n                // filter out the listeners to only have the ones that ARE being attached to the parent\n                listeners = listeners.filter(([flags]) => flags & 32 /* LISTENER_FLAGS.TargetParent */);\n            }\n            else {\n                // this is being ran from within the component constructor\n                // everything BUT the parent element listeners should be attached at this time\n                // filter out the listeners that are NOT being attached to the parent\n                listeners = listeners.filter(([flags]) => !(flags & 32 /* LISTENER_FLAGS.TargetParent */));\n            }\n        }\n        listeners.map(([flags, name, method]) => {\n            const target = BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags) : elm;\n            const handler = hostListenerProxy(hostRef, method);\n            const opts = hostListenerOpts(flags);\n            plt.ael(target, name, handler, opts);\n            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(() => plt.rel(target, name, handler, opts));\n        });\n    }\n};\nconst hostListenerProxy = (hostRef, methodName) => (ev) => {\n    try {\n        if (BUILD.lazyLoad) {\n            if (hostRef.$flags$ & 256 /* HOST_FLAGS.isListenReady */) {\n                // instance is ready, let's call it's member method for this event\n                hostRef.$lazyInstance$[methodName](ev);\n            }\n            else {\n                (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([methodName, ev]);\n            }\n        }\n        else {\n            hostRef.$hostElement$[methodName](ev);\n        }\n    }\n    catch (e) {\n        consoleError(e);\n    }\n};\nconst getHostListenerTarget = (elm, flags) => {\n    if (BUILD.hostListenerTargetDocument && flags & 4 /* LISTENER_FLAGS.TargetDocument */)\n        return doc;\n    if (BUILD.hostListenerTargetWindow && flags & 8 /* LISTENER_FLAGS.TargetWindow */)\n        return win;\n    if (BUILD.hostListenerTargetBody && flags & 16 /* LISTENER_FLAGS.TargetBody */)\n        return doc.body;\n    if (BUILD.hostListenerTargetParent && flags & 32 /* LISTENER_FLAGS.TargetParent */)\n        return elm.parentElement;\n    return elm;\n};\n// prettier-ignore\nconst hostListenerOpts = (flags) => supportsListenerOptions\n    ? ({\n        passive: (flags & 1 /* LISTENER_FLAGS.Passive */) !== 0,\n        capture: (flags & 2 /* LISTENER_FLAGS.Capture */) !== 0,\n    })\n    : (flags & 2 /* LISTENER_FLAGS.Capture */) !== 0;\nconst setPlatformOptions = (opts) => Object.assign(plt, opts);\nconst insertVdomAnnotations = (doc, staticComponents) => {\n    if (doc != null) {\n        const docData = {\n            hostIds: 0,\n            rootLevelIds: 0,\n            staticComponents: new Set(staticComponents),\n        };\n        const orgLocationNodes = [];\n        parseVNodeAnnotations(doc, doc.body, docData, orgLocationNodes);\n        orgLocationNodes.forEach((orgLocationNode) => {\n            if (orgLocationNode != null) {\n                const nodeRef = orgLocationNode['s-nr'];\n                let hostId = nodeRef['s-host-id'];\n                let nodeId = nodeRef['s-node-id'];\n                let childId = `${hostId}.${nodeId}`;\n                if (hostId == null) {\n                    hostId = 0;\n                    docData.rootLevelIds++;\n                    nodeId = docData.rootLevelIds;\n                    childId = `${hostId}.${nodeId}`;\n                    if (nodeRef.nodeType === 1 /* NODE_TYPE.ElementNode */) {\n                        nodeRef.setAttribute(HYDRATE_CHILD_ID, childId);\n                    }\n                    else if (nodeRef.nodeType === 3 /* NODE_TYPE.TextNode */) {\n                        if (hostId === 0) {\n                            const textContent = nodeRef.nodeValue.trim();\n                            if (textContent === '') {\n                                // useless whitespace node at the document root\n                                orgLocationNode.remove();\n                                return;\n                            }\n                        }\n                        const commentBeforeTextNode = doc.createComment(childId);\n                        commentBeforeTextNode.nodeValue = `${TEXT_NODE_ID}.${childId}`;\n                        nodeRef.parentNode.insertBefore(commentBeforeTextNode, nodeRef);\n                    }\n                }\n                let orgLocationNodeId = `${ORG_LOCATION_ID}.${childId}`;\n                const orgLocationParentNode = orgLocationNode.parentElement;\n                if (orgLocationParentNode) {\n                    if (orgLocationParentNode['s-en'] === '') {\n                        // ending with a \".\" means that the parent element\n                        // of this node's original location is a SHADOW dom element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.`;\n                    }\n                    else if (orgLocationParentNode['s-en'] === 'c') {\n                        // ending with a \".c\" means that the parent element\n                        // of this node's original location is a SCOPED element\n                        // and this node is apart of the root level light dom\n                        orgLocationNodeId += `.c`;\n                    }\n                }\n                orgLocationNode.nodeValue = orgLocationNodeId;\n            }\n        });\n    }\n};\nconst parseVNodeAnnotations = (doc, node, docData, orgLocationNodes) => {\n    if (node == null) {\n        return;\n    }\n    if (node['s-nr'] != null) {\n        orgLocationNodes.push(node);\n    }\n    if (node.nodeType === 1 /* NODE_TYPE.ElementNode */) {\n        node.childNodes.forEach((childNode) => {\n            const hostRef = getHostRef(childNode);\n            if (hostRef != null && !docData.staticComponents.has(childNode.nodeName.toLowerCase())) {\n                const cmpData = {\n                    nodeIds: 0,\n                };\n                insertVNodeAnnotations(doc, childNode, hostRef.$vnode$, docData, cmpData);\n            }\n            parseVNodeAnnotations(doc, childNode, docData, orgLocationNodes);\n        });\n    }\n};\nconst insertVNodeAnnotations = (doc, hostElm, vnode, docData, cmpData) => {\n    if (vnode != null) {\n        const hostId = ++docData.hostIds;\n        hostElm.setAttribute(HYDRATE_ID, hostId);\n        if (hostElm['s-cr'] != null) {\n            hostElm['s-cr'].nodeValue = `${CONTENT_REF_ID}.${hostId}`;\n        }\n        if (vnode.$children$ != null) {\n            const depth = 0;\n            vnode.$children$.forEach((vnodeChild, index) => {\n                insertChildVNodeAnnotations(doc, vnodeChild, cmpData, hostId, depth, index);\n            });\n        }\n        if (hostElm && vnode && vnode.$elm$ && !hostElm.hasAttribute('c-id')) {\n            const parent = hostElm.parentElement;\n            if (parent && parent.childNodes) {\n                const parentChildNodes = Array.from(parent.childNodes);\n                const comment = parentChildNodes.find((node) => node.nodeType === 8 /* NODE_TYPE.CommentNode */ && node['s-sr']);\n                if (comment) {\n                    const index = parentChildNodes.indexOf(hostElm) - 1;\n                    vnode.$elm$.setAttribute(HYDRATE_CHILD_ID, `${comment['s-host-id']}.${comment['s-node-id']}.0.${index}`);\n                }\n            }\n        }\n    }\n};\nconst insertChildVNodeAnnotations = (doc, vnodeChild, cmpData, hostId, depth, index) => {\n    const childElm = vnodeChild.$elm$;\n    if (childElm == null) {\n        return;\n    }\n    const nodeId = cmpData.nodeIds++;\n    const childId = `${hostId}.${nodeId}.${depth}.${index}`;\n    childElm['s-host-id'] = hostId;\n    childElm['s-node-id'] = nodeId;\n    if (childElm.nodeType === 1 /* NODE_TYPE.ElementNode */) {\n        childElm.setAttribute(HYDRATE_CHILD_ID, childId);\n    }\n    else if (childElm.nodeType === 3 /* NODE_TYPE.TextNode */) {\n        const parentNode = childElm.parentNode;\n        const nodeName = parentNode.nodeName;\n        if (nodeName !== 'STYLE' && nodeName !== 'SCRIPT') {\n            const textNodeId = `${TEXT_NODE_ID}.${childId}`;\n            const commentBeforeTextNode = doc.createComment(textNodeId);\n            parentNode.insertBefore(commentBeforeTextNode, childElm);\n        }\n    }\n    else if (childElm.nodeType === 8 /* NODE_TYPE.CommentNode */) {\n        if (childElm['s-sr']) {\n            const slotName = childElm['s-sn'] || '';\n            const slotNodeId = `${SLOT_NODE_ID}.${childId}.${slotName}`;\n            childElm.nodeValue = slotNodeId;\n        }\n    }\n    if (vnodeChild.$children$ != null) {\n        const childDepth = depth + 1;\n        vnodeChild.$children$.forEach((vnode, index) => {\n            insertChildVNodeAnnotations(doc, vnode, cmpData, hostId, childDepth, index);\n        });\n    }\n};\nconst hostRefs = /*@__PURE__*/ new WeakMap();\nconst getHostRef = (ref) => hostRefs.get(ref);\nconst registerInstance = (lazyInstance, hostRef) => hostRefs.set((hostRef.$lazyInstance$ = lazyInstance), hostRef);\nconst registerHost = (elm, cmpMeta) => {\n    const hostRef = {\n        $flags$: 0,\n        $hostElement$: elm,\n        $cmpMeta$: cmpMeta,\n        $instanceValues$: new Map(),\n    };\n    if (BUILD.isDev) {\n        hostRef.$renderCount$ = 0;\n    }\n    if (BUILD.method && BUILD.lazyLoad) {\n        hostRef.$onInstancePromise$ = new Promise((r) => (hostRef.$onInstanceResolve$ = r));\n    }\n    if (BUILD.asyncLoading) {\n        hostRef.$onReadyPromise$ = new Promise((r) => (hostRef.$onReadyResolve$ = r));\n        elm['s-p'] = [];\n        elm['s-rc'] = [];\n    }\n    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);\n    return hostRefs.set(elm, hostRef);\n};\nconst isMemberInElement = (elm, memberName) => memberName in elm;\nconst consoleError = (e, el) => (customError || console.error)(e, el);\nconst STENCIL_DEV_MODE = BUILD.isTesting\n    ? ['STENCIL:'] // E2E testing\n    : [\n        '%cstencil',\n        'color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px',\n    ];\nconst consoleDevError = (...m) => console.error(...STENCIL_DEV_MODE, ...m);\nconst consoleDevWarn = (...m) => console.warn(...STENCIL_DEV_MODE, ...m);\nconst consoleDevInfo = (...m) => console.info(...STENCIL_DEV_MODE, ...m);\nconst setErrorHandler = (handler) => (customError = handler);\nconst cmpModules = /*@__PURE__*/ new Map();\nconst loadModule = (cmpMeta, hostRef, hmrVersionId) => {\n    // loadModuleImport\n    const exportName = cmpMeta.$tagName$.replace(/-/g, '_');\n    const bundleId = cmpMeta.$lazyBundleId$;\n    if (BUILD.isDev && typeof bundleId !== 'string') {\n        consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode \"${hostRef.$modeName$}\", but it does not exist.`);\n        return undefined;\n    }\n    const module = !BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;\n    if (module) {\n        return module[exportName];\n    }\n    /*!__STENCIL_STATIC_IMPORT_SWITCH__*/\n    return import(\n    /* @vite-ignore */\n    /* webpackInclude: /\\.entry\\.js$/ */\n    /* webpackExclude: /\\.system\\.entry\\.js$/ */\n    /* webpackMode: \"lazy\" */\n    `./${bundleId}.entry.js${BUILD.hotModuleReplacement && hmrVersionId ? '?s-hmr=' + hmrVersionId : ''}`).then((importedModule) => {\n        if (!BUILD.hotModuleReplacement) {\n            cmpModules.set(bundleId, importedModule);\n        }\n        return importedModule[exportName];\n    }, consoleError);\n};\nconst styles = /*@__PURE__*/ new Map();\nconst modeResolutionChain = [];\nconst win = typeof window !== 'undefined' ? window : {};\nconst CSS = BUILD.cssVarShim ? win.CSS : null;\nconst doc = win.document || { head: {} };\nconst H = (win.HTMLElement || class {\n});\nconst plt = {\n    $flags$: 0,\n    $resourcesUrl$: '',\n    jmp: (h) => h(),\n    raf: (h) => requestAnimationFrame(h),\n    ael: (el, eventName, listener, opts) => el.addEventListener(eventName, listener, opts),\n    rel: (el, eventName, listener, opts) => el.removeEventListener(eventName, listener, opts),\n    ce: (eventName, opts) => new CustomEvent(eventName, opts),\n};\nconst setPlatformHelpers = (helpers) => {\n    Object.assign(plt, helpers);\n};\nconst supportsShadow = BUILD.shadowDomShim && BUILD.shadowDom\n    ? /*@__PURE__*/ (() => (doc.head.attachShadow + '').indexOf('[native') > -1)()\n    : true;\nconst supportsListenerOptions = /*@__PURE__*/ (() => {\n    let supportsListenerOptions = false;\n    try {\n        doc.addEventListener('e', null, Object.defineProperty({}, 'passive', {\n            get() {\n                supportsListenerOptions = true;\n            },\n        }));\n    }\n    catch (e) { }\n    return supportsListenerOptions;\n})();\nconst promiseResolve = (v) => Promise.resolve(v);\nconst supportsConstructableStylesheets = BUILD.constructableCSS\n    ? /*@__PURE__*/ (() => {\n        try {\n            new CSSStyleSheet();\n            return typeof new CSSStyleSheet().replaceSync === 'function';\n        }\n        catch (e) { }\n        return false;\n    })()\n    : false;\nconst queueDomReads = [];\nconst queueDomWrites = [];\nconst queueDomWritesLow = [];\nconst queueTask = (queue, write) => (cb) => {\n    queue.push(cb);\n    if (!queuePending) {\n        queuePending = true;\n        if (write && plt.$flags$ & 4 /* PLATFORM_FLAGS.queueSync */) {\n            nextTick(flush);\n        }\n        else {\n            plt.raf(flush);\n        }\n    }\n};\nconst consume = (queue) => {\n    for (let i = 0; i < queue.length; i++) {\n        try {\n            queue[i](performance.now());\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    queue.length = 0;\n};\nconst consumeTimeout = (queue, timeout) => {\n    let i = 0;\n    let ts = 0;\n    while (i < queue.length && (ts = performance.now()) < timeout) {\n        try {\n            queue[i++](ts);\n        }\n        catch (e) {\n            consoleError(e);\n        }\n    }\n    if (i === queue.length) {\n        queue.length = 0;\n    }\n    else if (i !== 0) {\n        queue.splice(0, i);\n    }\n};\nconst flush = () => {\n    if (BUILD.asyncQueue) {\n        queueCongestion++;\n    }\n    // always force a bunch of medium callbacks to run, but still have\n    // a throttle on how many can run in a certain time\n    // DOM READS!!!\n    consume(queueDomReads);\n    // DOM WRITES!!!\n    if (BUILD.asyncQueue) {\n        const timeout = (plt.$flags$ & 6 /* PLATFORM_FLAGS.queueMask */) === 2 /* PLATFORM_FLAGS.appLoaded */\n            ? performance.now() + 14 * Math.ceil(queueCongestion * (1.0 / 10.0))\n            : Infinity;\n        consumeTimeout(queueDomWrites, timeout);\n        consumeTimeout(queueDomWritesLow, timeout);\n        if (queueDomWrites.length > 0) {\n            queueDomWritesLow.push(...queueDomWrites);\n            queueDomWrites.length = 0;\n        }\n        if ((queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n        else {\n            queueCongestion = 0;\n        }\n    }\n    else {\n        consume(queueDomWrites);\n        if ((queuePending = queueDomReads.length > 0)) {\n            // still more to do yet, but we've run out of time\n            // let's let this thing cool off and try again in the next tick\n            plt.raf(flush);\n        }\n    }\n};\nconst nextTick = /*@__PURE__*/ (cb) => promiseResolve().then(cb);\nconst readTask = /*@__PURE__*/ queueTask(queueDomReads, false);\nconst writeTask = /*@__PURE__*/ queueTask(queueDomWrites, true);\nexport { BUILD, Env, NAMESPACE } from '@stencil/core/internal/app-data';\nexport { Build, CSS, Context, Fragment, H, H as HTMLElement, Host, STENCIL_DEV_MODE, addHostEventListeners, bootstrapLazy, cmpModules, connectedCallback, consoleDevError, consoleDevInfo, consoleDevWarn, consoleError, createEvent, defineCustomElement, disconnectedCallback, doc, forceModeUpdate, forceUpdate, getAssetPath, getConnect, getContext, getElement, getHostRef, getMode, getRenderingRef, getValue, h, insertVdomAnnotations, isMemberInElement, loadModule, modeResolutionChain, nextTick, parsePropertyValue, plt, postUpdateComponent, promiseResolve, proxyComponent, proxyCustomElement, readTask, registerHost, registerInstance, renderVdom, setAssetPath, setErrorHandler, setMode, setPlatformHelpers, setPlatformOptions, setValue, styles, supportsConstructableStylesheets, supportsListenerOptions, supportsShadow, win, writeTask };\n","import type { TagName, TagNameCamelCase } from '@porsche-design-system/shared';\nimport { TAG_NAMES } from '@porsche-design-system/shared';\nimport { paramCaseToCamelCase } from './paramCaseToCamelCase';\n\n// NOTE: these utils are in the same file on purpose\n// to force them being bundled into our core chunk\n\nexport const getTagName = (el: HTMLElement): string => el.tagName.toLowerCase();\n\nexport const getTagNameWithoutPrefix = (host: HTMLElement): TagName => {\n  const tagName = getTagName(host);\n  const [, tagNameWithoutPrefix = ''] = /^(?:[a-z-]+-)?(p-[a-z-]+)$/.exec(tagName) || [];\n  return (tagNameWithoutPrefix || tagName) as TagName; // return tagName as fallback for default tags\n};\n\n// prevent internal usage of p-headline and p-text\ntype AllowedTagNameCamelCase = Exclude<TagNameCamelCase, 'pHeadline' | 'pText'>;\ntype PrefixedTagNames = Record<AllowedTagNameCamelCase, string>;\nconst tagNamesWithoutTextAndHeadline = TAG_NAMES.filter((item) => item !== 'p-text' && item !== 'p-headline');\n\nexport const PREFIXED_TAG_NAMES_CACHE = new Map<string, PrefixedTagNames>();\n\nexport const getPrefixedTagNames = (host: HTMLElement): PrefixedTagNames => {\n  const [, prefix = ''] = /^([a-z-]+)-p-[a-z-]+$/.exec(getTagName(host)) || [];\n\n  if (!PREFIXED_TAG_NAMES_CACHE.has(prefix)) {\n    const tagNames: PrefixedTagNames = tagNamesWithoutTextAndHeadline.reduce(\n      prefix\n        ? (result, tag) => ({\n            ...result,\n            [paramCaseToCamelCase(tag)]: `${prefix}-${tag}`,\n          })\n        : (result, tag) => ({\n            ...result,\n            [paramCaseToCamelCase(tag)]: tag,\n          }),\n      {} as PrefixedTagNames\n    );\n\n    PREFIXED_TAG_NAMES_CACHE.set(prefix, tagNames);\n  }\n\n  return PREFIXED_TAG_NAMES_CACHE.get(prefix);\n};\n","import { isThemeDark } from './isThemeDark';\nimport type { Theme } from './theme';\n\nexport const getDataThemeDarkAttribute = (theme: Theme): { 'data-theme': Extract<Theme, 'dark'> } | null => {\n  return isThemeDark(theme) ? { 'data-theme': 'dark' } : null;\n};\n","export const THEMES = ['light', 'dark'] as const;\nexport type Theme = typeof THEMES[number];\n","import { THEMES } from './theme';\n\nexport const THEMES_EXTENDED_ELECTRIC = [...THEMES, 'light-electric'] as const;\nexport type ThemeExtendedElectric = typeof THEMES_EXTENDED_ELECTRIC[number];\n","import { fontBehavior } from '../../font/font-behavior.js';\nimport { fontFamily } from '../../font/font-family.js';\nimport { fontHyphenation } from '../../font/font-hyphenation.js';\nimport { fontLineHeight } from '../../font/font-line-height.js';\nimport { fontWeight } from '../../font/font-weight.js';\nimport { fontStyle } from '../../font/font-style.js';\nimport { fontVariant } from '../../font/font-variant.js';\n\nconst textXSmall = {\n    font: `${fontStyle} ${fontVariant} ${fontWeight.regular} 0.75rem/${fontLineHeight} ${fontFamily}`,\n    ...fontBehavior,\n    ...fontHyphenation,\n};\n\nexport { textXSmall };\n","import { fontBehavior } from '../../font/font-behavior.js';\nimport { fontFamily } from '../../font/font-family.js';\nimport { fontHyphenation } from '../../font/font-hyphenation.js';\nimport { fontLineHeight } from '../../font/font-line-height.js';\nimport { fontWeight } from '../../font/font-weight.js';\nimport { fontStyle } from '../../font/font-style.js';\nimport { fontVariant } from '../../font/font-variant.js';\n\nconst textSmall = {\n    font: `${fontStyle} ${fontVariant} ${fontWeight.regular} 1rem/${fontLineHeight} ${fontFamily}`,\n    ...fontBehavior,\n    ...fontHyphenation,\n};\n\nexport { textSmall };\n","import { fontBehavior } from '../../font/font-behavior.js';\nimport { fontFamily } from '../../font/font-family.js';\nimport { fontHyphenation } from '../../font/font-hyphenation.js';\nimport { fontLineHeight } from '../../font/font-line-height.js';\nimport { fontWeight } from '../../font/font-weight.js';\nimport { fontStyle } from '../../font/font-style.js';\nimport { fontVariant } from '../../font/font-variant.js';\n\nconst textXLarge = {\n    font: `${fontStyle} ${fontVariant} ${fontWeight.regular} 3.25rem/${fontLineHeight} ${fontFamily}`,\n    ...fontBehavior,\n    ...fontHyphenation,\n};\n\nexport { textXLarge };\n","import type { TextSize } from '../../types';\nimport { textLarge, textMedium, textSmall, textXLarge, textXSmall } from '@porsche-design-system/utilities-v2';\n\nexport const textMap: { [key in Exclude<TextSize, 'inherit'>]: any } = {\n  'x-small': textXSmall,\n  small: textSmall,\n  medium: textMedium,\n  large: textLarge,\n  'x-large': textXLarge,\n};\n","/* eslint-disable prefer-arrow/prefer-arrow-functions */\nimport { getTagName } from '..';\nimport { getDirectChildHTMLElements } from '../dom/getDirectChildHTMLElements';\n\n// prettier-ignore\nexport function getOnlyChildOfKindHTMLElementOrThrow<K extends keyof HTMLElementTagNameMap>(element: HTMLElement, selector: K): HTMLElementTagNameMap[K] | null;\n// prettier-ignore\nexport function getOnlyChildOfKindHTMLElementOrThrow<E extends Element = Element>(element: HTMLElement, selector: string): E | null;\nexport function getOnlyChildOfKindHTMLElementOrThrow(element: HTMLElement, selector: string): any {\n  // we need to support named slots for label/description or message, hence we can't verify element.children.length\n  const directChildren = getDirectChildHTMLElements(element, selector);\n\n  if (directChildren.length !== 1) {\n    throw new Error(`${getTagName(element)} has to contain a single direct child of: ${selector}`);\n  }\n\n  return directChildren[0];\n}\n","import { getTagName } from '..';\n\nexport const throwIfChildCountIsExceeded = (element: HTMLElement, allowedAmount: number): void => {\n  const childCount = element.children.length;\n  if (childCount > allowedAmount) {\n    throw new Error(`Only ${allowedAmount} children are allowed in ${getTagName(element)} but got ${childCount}`);\n  }\n};\n","import { BREAKPOINTS, parseJSON } from '../breakpoint-customizable';\nimport type { BreakpointKey, BreakpointValues } from '../breakpoint-customizable';\nimport type { AriaAttributes } from '../../aria-types';\nimport { parseJSONAttribute } from '../json';\nimport type { EventEmitter } from '@stencil/core';\nimport { getTagName } from '..';\n\nexport type ValidatorFunction = (propName: string, propValue: any) => ValidationError;\ntype ValidatorFunctionOneOfCreator = <T>(allowedValues: T[] | readonly T[]) => ValidatorFunction;\ntype ValidatorFunctionBreakpointCustomizableCreator = <T>(\n  allowedValues: Exclude<AllowedTypeKey, 'string'> | T[] | readonly T[]\n) => ValidatorFunction;\ntype ValidatorFunctionShapeCreator = <T>(allowedValues: {\n  [key in keyof T]: ValidatorFunctionOrCreator;\n}) => ValidatorFunction;\ntype ValidatorFunctionOrCreator =\n  | ValidatorFunction\n  | ValidatorFunctionOneOfCreator\n  | ValidatorFunctionBreakpointCustomizableCreator\n  | ValidatorFunctionShapeCreator;\n\nexport type ValidationError = {\n  propName: string;\n  propValue: string;\n  propType: string;\n};\n\nexport const formatObjectOutput = (value: any): string => {\n  return JSON.stringify(value)\n    .replace(/\"([a-zA-Z?]+)\":/g, '$1:') // remove double quotes from keys\n    .replace(/([,:{])/g, '$1 ') // add space after following: ,:{\n    .replace(/(})/g, ' $1') // add space before following: }\n    .replace(/^\"(.+)\"$/, '$1'); // remove wrapping double quotes\n};\n\nexport const formatArrayOutput = <T>(value: T[] | readonly T[]): string => {\n  return (\n    JSON.stringify(value.map((x) => (x === undefined ? `${x}` : x))) // wrap undefined in quotes to not convert it to null\n      .replace(/'/g, '') // remove single quotes\n      // eslint-disable-next-line @typescript-eslint/quotes\n      .replace(/\"/g, \"'\") // replace double quotes with single quotes\n      .replace(/'(undefined)'/, '$1') // remove quotes around undefined\n      .replace(/,/g, ', ') // add space after comma\n  );\n};\n\nexport const printErrorMessage = ({\n  propName,\n  propValue, // TODO: might be nicer if this is always a string\n  propType,\n  componentName,\n}: ValidationError & { componentName: string }): void => {\n  console.error(\n    `Warning: Invalid property '${propName}' with value '${formatObjectOutput(\n      propValue\n    )}' supplied to '${componentName}', expected one of: ${propType}`\n  );\n};\n\nexport const isValueNotOfType = (propValue: any, propType: string): boolean => {\n  return propValue !== undefined && typeof propValue !== propType;\n};\n\nexport const validateValueOfType = (propName: string, propValue: any, propType: string): ValidationError => {\n  if (isValueNotOfType(propValue, propType)) {\n    return { propName, propValue, propType };\n  }\n};\n\nconst breakpointCustomizableTemplate =\n  'value, ' +\n  formatObjectOutput(\n    BREAKPOINTS.reduce((prev, key) => ({ ...prev, [key + (key !== 'base' ? '?' : '')]: 'value' }), {})\n  ).replace(/\"/g, '');\n\nexport const getBreakpointCustomizableStructure = <T>(\n  allowedValues: Exclude<AllowedTypeKey, 'string'> | T[] | readonly T[]\n): string => {\n  if (allowedValues !== 'boolean' && allowedValues !== 'number') {\n    allowedValues = formatArrayOutput(allowedValues)\n      .replace(/\\[/g, '(') // starting inline type literal array\n      .replace(/]/g, ')[]') // ending inline type literal array\n      .replace(/,/g, ' |') as any; // replace commas with a pipe\n  }\n  return breakpointCustomizableTemplate.replace(/value/g, allowedValues as string);\n};\n\nexport const getAriaStructure = <T>(allowedAriaAttributes: readonly T[]): string => {\n  return (\n    formatObjectOutput(\n      allowedAriaAttributes.reduce(\n        (prev, key) => ({\n          ...prev,\n          [key as any]: 'value',\n        }),\n        {}\n      )\n    )\n      .replace(/\":/g, '\"?:') // add optional modifier on keys before colon\n      // eslint-disable-next-line @typescript-eslint/quotes\n      .replace(/\"/g, \"'\") // replace double quotes with single quotes\n  );\n};\n\nexport const getShapeStructure = <T>(shapeStructure: { [key in keyof T]: ValidatorFunction }): string => {\n  return formatObjectOutput(\n    Object.keys(shapeStructure).reduce((prev, key) => ({ ...prev, [key]: shapeStructure[key].name }), {})\n  ).replace(/\"/g, ''); // remove double quotes\n};\n\nexport const isBreakpointCustomizableValueInvalid = <T>(\n  value: any,\n  allowedValues: Exclude<AllowedTypeKey, 'string'> | T[] | readonly T[]\n): boolean => {\n  return allowedValues === 'boolean' || allowedValues === 'number'\n    ? isValueNotOfType(value, allowedValues)\n    : !allowedValues.includes(value as T);\n};\n\ntype AllowedTypeKey = 'string' | 'number' | 'boolean';\n\n// TODO: maybe dissolve object structure and have standalone utils\nexport const AllowedTypes: {\n  [key in AllowedTypeKey]: ValidatorFunction;\n} & {\n  oneOf: ValidatorFunctionOneOfCreator;\n  aria: ValidatorFunctionOneOfCreator;\n  breakpoint: ValidatorFunctionBreakpointCustomizableCreator;\n  shape: ValidatorFunctionShapeCreator;\n} = {\n  // eslint-disable-next-line id-blacklist\n  string: (...args) => validateValueOfType(...args, 'string'),\n  // eslint-disable-next-line id-blacklist\n  number: (...args) => validateValueOfType(...args, 'number'),\n  // eslint-disable-next-line id-blacklist\n  boolean: (...args) => validateValueOfType(...args, 'boolean'),\n  oneOf: <T>(allowedValuesOrValidatorFunctions: T[]): ValidatorFunction =>\n    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions\n    function oneOf(propName, propValue) {\n      // use first item to determine if we've got primitive types or validator functions\n      if (typeof allowedValuesOrValidatorFunctions[0] !== 'function') {\n        if (!allowedValuesOrValidatorFunctions.includes(propValue as T)) {\n          return { propName, propValue, propType: formatArrayOutput(allowedValuesOrValidatorFunctions) };\n        }\n      } else if (\n        !allowedValuesOrValidatorFunctions.some(\n          (func) => (func as unknown as ValidatorFunction)(propName, propValue) === undefined\n        )\n      ) {\n        return {\n          propName,\n          propValue,\n          propType: allowedValuesOrValidatorFunctions.map((func) => (func as any).name).join(', '),\n        };\n      }\n    },\n  breakpoint: (allowedValues): ValidatorFunction =>\n    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions\n    function breakpoint(propName, propValue) {\n      // TODO: do parseJSON once in the component, currently it is happening multiple times in a single lifecycle\n      const value = parseJSON(propValue as BreakpointValues<any>);\n      let isInvalid = false;\n\n      if (typeof value === 'object') {\n        if (\n          // check structure keys: base, xs, s, m, l, xl\n          // TODO: check for base key\n          Object.keys(value).some((key) => !BREAKPOINTS.includes(key as BreakpointKey)) ||\n          // check actual values of keys, e.g. true, false, 'small' or 5\n          Object.values(value).some((val) => isBreakpointCustomizableValueInvalid(val, allowedValues))\n        ) {\n          isInvalid = true;\n        }\n      } else if (isBreakpointCustomizableValueInvalid(value, allowedValues)) {\n        // single flat value like true, false, 'small' or 5, not breakpoint customizable object\n        isInvalid = true;\n      }\n\n      if (isInvalid) {\n        return {\n          propName,\n          propValue: formatObjectOutput(value),\n          propType: getBreakpointCustomizableStructure(allowedValues),\n        };\n      }\n    },\n  aria: <T = keyof AriaAttributes>(allowedAriaAttributes: readonly T[]): ValidatorFunction =>\n    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions\n    function aria(propName, propValue) {\n      const ariaAttributes = parseJSONAttribute<AriaAttributes>(propValue as string);\n      if (\n        ariaAttributes &&\n        Object.keys(ariaAttributes).some((ariaKey) => !allowedAriaAttributes.includes(ariaKey as unknown as T))\n      ) {\n        return {\n          propName,\n          propValue: formatObjectOutput(ariaAttributes),\n          propType: getAriaStructure(allowedAriaAttributes),\n        };\n      }\n    },\n  shape: <T>(shapeStructure: { [key in keyof T]: ValidatorFunction }): ValidatorFunction =>\n    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions\n    function shape(propName, propValue) {\n      if (propValue) {\n        // const propValueKeys = Object.keys(propValue);\n        if (\n          // check structure, but propValue could contain additional keys\n          // but how to handle optional keys like in table-head-cell's sort property?\n          // Object.keys(shapeStructure).some((key) => !propValueKeys.includes(key)) ||\n          // check values\n          Object.entries(shapeStructure).some(([structureKey, validatorFunc]: [string, ValidatorFunction]) =>\n            validatorFunc(structureKey, propValue[structureKey])\n          )\n        ) {\n          // TODO: more precise inner errors from value validation could be output\n          return {\n            propName,\n            propValue, // TODO: convert to string?\n            propType: getShapeStructure(shapeStructure),\n          };\n        }\n      }\n    },\n};\n\n// utility type to return public properties of generic type that are not a function or EventEmitter\ntype FunctionPropertyNames<T> = {\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  [K in keyof T]: T[K] extends Function | EventEmitter ? K : never; // or make `@Event` decorators private maybe?\n}[keyof T];\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype Class<T> = Function & {\n  new (...args: any[]): T; // eslint-disable-line @typescript-eslint/prefer-function-type\n};\n\n// utility type to retrieve all props based on a class\nexport type PropTypes<T extends Class<any>> = Required<{\n  [Property in keyof Omit<\n    InstanceType<T>,\n    'host' | FunctionPropertyNames<InstanceType<T>>\n  >]: ValidatorFunctionOrCreator;\n}>;\n\nexport const validateProps = <T extends Class<any>>(instance: InstanceType<T>, propTypes: PropTypes<T>): void => {\n  Object.entries(propTypes)\n    .map(([propKey, validatorFunc]: [string, ValidatorFunction]) => validatorFunc(propKey, instance[propKey]))\n    .filter((x) => x)\n    .forEach((error) => printErrorMessage({ ...error, componentName: getTagName(instance.host as HTMLElement) }));\n};\n","const fontStyle = 'normal';\n\nexport { fontStyle };\n","export default function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}","const fontBehavior = {\n    textSizeAdjust: 'none',\n    WebkitTextSizeAdjust: 'none', // stop iOS safari from adjusting font size when screen rotation is changing\n};\n\nexport { fontBehavior };\n","const fontVariant = 'normal';\n\nexport { fontVariant };\n","'use strict';\nvar fails = require('../internals/fails');\n\nmodule.exports = function (METHOD_NAME, argument) {\n  var method = [][METHOD_NAME];\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call -- required for testing\n    method.call(null, argument || function () { return 1; }, 1);\n  });\n};\n","const fontWeight = {\n    thin: 100,\n    regular: 400,\n    semiBold: 600,\n    bold: 700,\n};\n\nexport { fontWeight };\n","const TAG_NAMES = ['p-accordion', 'p-banner', 'p-button', 'p-button-group', 'p-button-pure', 'p-carousel', 'p-checkbox-wrapper', 'p-content-wrapper', 'p-divider', 'p-fieldset-wrapper', 'p-flex', 'p-flex-item', 'p-grid', 'p-grid-item', 'p-headline', 'p-icon', 'p-inline-notification', 'p-link', 'p-link-pure', 'p-link-social', 'p-link-tile', 'p-marque', 'p-modal', 'p-pagination', 'p-popover', 'p-radio-button-wrapper', 'p-scroller', 'p-segmented-control', 'p-segmented-control-item', 'p-select-wrapper', 'p-select-wrapper-dropdown', 'p-spinner', 'p-stepper-horizontal', 'p-stepper-horizontal-item', 'p-switch', 'p-table', 'p-table-body', 'p-table-cell', 'p-table-head', 'p-table-head-cell', 'p-table-head-row', 'p-table-row', 'p-tabs', 'p-tabs-bar', 'p-tabs-item', 'p-tag', 'p-tag-dismissible', 'p-text', 'p-text-field-wrapper', 'p-text-list', 'p-text-list-item', 'p-textarea-wrapper', 'p-toast', 'p-toast-item'];\nconst INTERNAL_TAG_NAMES = ['p-select-wrapper-dropdown', 'p-toast-item'];\n\nexport { INTERNAL_TAG_NAMES, TAG_NAMES };\n","var aCallable = require('../internals/a-callable');\nvar toObject = require('../internals/to-object');\nvar IndexedObject = require('../internals/indexed-object');\nvar lengthOfArrayLike = require('../internals/length-of-array-like');\n\nvar $TypeError = TypeError;\n\n// `Array.prototype.{ reduce, reduceRight }` methods implementation\nvar createMethod = function (IS_RIGHT) {\n  return function (that, callbackfn, argumentsLength, memo) {\n    aCallable(callbackfn);\n    var O = toObject(that);\n    var self = IndexedObject(O);\n    var length = lengthOfArrayLike(O);\n    var index = IS_RIGHT ? length - 1 : 0;\n    var i = IS_RIGHT ? -1 : 1;\n    if (argumentsLength < 2) while (true) {\n      if (index in self) {\n        memo = self[index];\n        index += i;\n        break;\n      }\n      index += i;\n      if (IS_RIGHT ? index < 0 : length <= index) {\n        throw $TypeError('Reduce of empty array with no initial value');\n      }\n    }\n    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {\n      memo = callbackfn(memo, self[index], index, O);\n    }\n    return memo;\n  };\n};\n\nmodule.exports = {\n  // `Array.prototype.reduce` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduce\n  left: createMethod(false),\n  // `Array.prototype.reduceRight` method\n  // https://tc39.es/ecma262/#sec-array.prototype.reduceright\n  right: createMethod(true)\n};\n","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n\nexports.__assign = function () {\n\texports.__assign =\n\t\tObject.assign ||\n\t\tfunction __assign(t) {\n\t\t\tfor (var s, i = 1, n = arguments.length; i < n; i++) {\n\t\t\t\ts = arguments[i];\n\t\t\t\tfor (var p in s)\n\t\t\t\t\tif (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n\t\t\t}\n\t\t\treturn t;\n\t\t};\n\treturn exports.__assign.apply(this, arguments);\n};\n","const fontHyphenation = {\n    overflowWrap: 'break-word',\n    hyphens: 'auto',\n};\n\nexport { fontHyphenation };\n","var isProduction = process.env.NODE_ENV === 'production';\nfunction warning(condition, message) {\n  if (!isProduction) {\n    if (condition) {\n      return;\n    }\n\n    var text = \"Warning: \" + message;\n\n    if (typeof console !== 'undefined') {\n      console.warn(text);\n    }\n\n    try {\n      throw Error(text);\n    } catch (x) {}\n  }\n}\n\nexport default warning;\n","import { Theme } from '@porsche-design-system/utilities-v2';\n\nexport const isThemeDark = (theme: Theme): boolean => {\n  return theme === 'dark';\n};\n","import type { Theme } from '@porsche-design-system/utilities-v2';\nimport { isThemeDark } from '../utils';\n\ntype ThemedColor =\n  | 'baseColor'\n  | 'baseColorDarken'\n  | 'brandColor'\n  | 'backgroundColor'\n  | 'backgroundSurfaceColor'\n  | 'contrastLowColor'\n  | 'contrastMediumColor'\n  | 'contrastHighColor'\n  | 'contrastHighColorDarken'\n  | 'hoverColor'\n  | 'hoverColorDarken'\n  | 'activeColor'\n  | 'focusColor'\n  | 'disabledColor'\n  | 'errorColor'\n  | 'errorColorDarken'\n  | 'errorSoftColor'\n  | 'successColor'\n  | 'successColorDarken'\n  | 'successSoftColor'\n  | 'warningColor'\n  | 'warningSoftColor'\n  | 'neutralColor'\n  | 'neutralSoftColor';\n\nexport type ThemedColors = { [key in ThemedColor]: string };\n\n/* Auto Generated Start */\nconst themeLight = {\n  baseColor: '#000',\n  baseColorDarken: '#000000',\n  brandColor: '#d5001c',\n  backgroundColor: '#fff',\n  backgroundSurfaceColor: '#f2f2f2',\n  contrastLowColor: '#e3e4e5',\n  contrastMediumColor: '#626669',\n  contrastHighColor: '#323639',\n  contrastHighColorDarken: '#151718',\n  hoverColor: '#d5001c',\n  hoverColorDarken: '#980014',\n  activeColor: '#d5001c',\n  focusColor: 'currentColor',\n  disabledColor: '#96989a',\n  errorColor: '#e00000',\n  errorColorDarken: '#a30000',\n  errorSoftColor: '#fae6e6',\n  successColor: '#018a16',\n  successColorDarken: '#014d0c',\n  successSoftColor: '#e5f3e7',\n  warningColor: '#ff9b00',\n  warningSoftColor: '#fff5e5',\n  neutralColor: '#0061bd',\n  neutralSoftColor: '#e5eff8'\n};\n\nconst themeDark = {\n  baseColor: '#fff',\n  baseColorDarken: '#e0e0e0',\n  brandColor: '#d5001c',\n  backgroundColor: '#0e1418',\n  backgroundSurfaceColor: '#262b2e',\n  contrastLowColor: '#4a4e51',\n  contrastMediumColor: '#b0b1b2',\n  contrastHighColor: '#e3e4e5',\n  contrastHighColorDarken: '#c3c5c8',\n  hoverColor: '#ff0223',\n  hoverColorDarken: '#c4001a',\n  activeColor: '#ff0223',\n  focusColor: 'currentColor',\n  disabledColor: '#7c7f81',\n  errorColor: '#fc1717',\n  errorColorDarken: '#d30303',\n  errorSoftColor: '#fec5c5',\n  successColor: '#01ba1d',\n  successColorDarken: '#017d14',\n  successSoftColor: '#bfeec6',\n  warningColor: '#ff9b00',\n  warningSoftColor: '#ffe6bf',\n  neutralColor: '#2193ff',\n  neutralSoftColor: '#c7e4ff'\n};\n\nconst themeLightElectric = {\n  ...themeLight,\n  brandColor: '#00b0f4',\n  hoverColor: '#00b0f4',\n  hoverColorDarken: '#0084b7',\n  activeColor: '#00b0f4'\n};\n\nconst themeDarkElectric = {\n  ...themeDark,\n  brandColor: '#00b0f4',\n  hoverColor: '#00b0f4',\n  hoverColorDarken: '#0084b7',\n  activeColor: '#00b0f4'\n};\n\nconst themes = {\n  'light': themeLight,\n  'dark': themeDark,\n  'light-electric': themeLightElectric,\n  'dark-electric': themeDarkElectric\n};\n/* Auto Generated End */\n\nexport const getThemedColors = (theme: Theme): ThemedColors => {\n  return themes[theme];\n};\n\nexport const getInvertedThemedColors = (theme: Theme): ThemedColors => {\n  return getThemedColors(isThemeDark(theme) ? 'light' : 'dark');\n};\n","import type { JssStyle } from 'jss';\n\n/**\n * utility to wrap jss styles parameter in `@media (hover: hover)`\n * which is used to not have hover styles on touch devices\n */\nexport const hoverMediaQuery = (style: JssStyle): JssStyle =>\n  // puppeteer/chromium does not support `@media (hover: hover)` in headless mode\n  // see https://github.com/puppeteer/puppeteer/issues/5096 and https://github.com/puppeteer/puppeteer/issues/4820\n  ROLLUP_REPLACE_IS_STAGING === 'production' || // prod build\n  process.env.NODE_ENV === 'test' || // unit tests\n  (ROLLUP_REPLACE_IS_STAGING === 'staging' && process.env.NODE_ENV === 'development') // dev via yarn start\n    ? { '@media(hover:hover)': style } // used for prod build, yarn start and unit tests\n    : style; // used for staging build in e2e and vrt tests\n","import type { JssStyle, Styles } from 'jss';\nimport type { PropertiesHyphen } from 'csstype';\nimport { fontWeight } from '@porsche-design-system/utilities-v2';\nimport { getThemedColors } from './';\nimport { hoverMediaQuery } from './hover-media-query';\nimport type { Theme } from '../types';\n\nexport const transitionDuration = 'var(--p-transition-duration, .24s)';\nconst transitionTimingFunction = 'ease';\n\nexport const getTransition = (cssProperty: keyof PropertiesHyphen): string =>\n  `${cssProperty} ${transitionDuration} ${transitionTimingFunction}`;\n\nexport const pxToRemWithUnit = (px: number): string => `${px / 16}rem`;\n\nexport const addImportantToRule = (value: any): string => `${value} !important`;\n\nexport const addImportantToEachRule = (input: JssStyle): JssStyle => {\n  return Object.entries(input).reduce(\n    (result, [key, value]) =>\n      value === null\n        ? result\n        : ((result[key] =\n            typeof value === 'object' ? addImportantToEachRule(value as JssStyle) : addImportantToRule(value)),\n          result),\n    {} as JssStyle\n  );\n};\n\ntype GetHoverStylesOptions = {\n  theme?: Theme;\n};\n\nexport const getHoverJssStyle = ({ theme }: GetHoverStylesOptions = { theme: 'light' }): JssStyle => {\n  return {\n    transition: getTransition('color'),\n    '&:hover': {\n      color: getThemedColors(theme).hoverColor,\n    },\n  };\n};\n\nexport type GetFocusStylesOptions = {\n  color?: string;\n  offset?: number;\n  pseudo?: '::after' | '::before';\n};\n\nexport const getInsetJssStyle = (value: 'auto' | number = 0): JssStyle => {\n  value = value === 0 || value === 'auto' ? value : (`${value}px` as any);\n  return {\n    top: value,\n    left: value,\n    right: value,\n    bottom: value,\n  };\n};\n\nexport const getFocusJssStyle = (opts?: GetFocusStylesOptions): JssStyle => {\n  const {\n    pseudo,\n    offset: outlineOffset,\n    color: outlineColor,\n  }: GetFocusStylesOptions = {\n    color: 'currentColor',\n    offset: 2,\n    ...opts,\n  };\n\n  return pseudo\n    ? {\n        outline: 0,\n        '&::-moz-focus-inner': {\n          border: 0,\n        },\n        [`&${pseudo}`]: {\n          content: '\"\"',\n          position: 'absolute',\n          ...getInsetJssStyle(),\n          outline: '1px solid transparent',\n          outlineOffset: `${outlineOffset}px`,\n        },\n        [`&:focus${pseudo}`]: {\n          outlineColor,\n        },\n        [`&:focus:not(:focus-visible)${pseudo}`]: {\n          outlineColor: 'transparent',\n        },\n      }\n    : {\n        outline: '1px solid transparent',\n        outlineOffset: `${outlineOffset}px`,\n        '&::-moz-focus-inner': {\n          border: 0,\n        },\n        '&:focus': {\n          outlineColor,\n        },\n        '&:focus:not(:focus-visible)': {\n          outlineColor: 'transparent',\n        },\n      };\n};\n\nexport const getBaseSlottedStyles = (opts: { withDarkTheme?: boolean } = { withDarkTheme: false }): Styles => {\n  return {\n    '& a': {\n      color: 'inherit',\n      textDecoration: 'underline',\n      ...getFocusJssStyle({ offset: 1 }),\n      ...hoverMediaQuery(getHoverJssStyle()),\n    },\n    ...(opts.withDarkTheme &&\n      ({\n        '&[data-theme=\"dark\"] a:hover': hoverMediaQuery(getHoverJssStyle({ theme: 'dark' })['&:hover'] as JssStyle),\n      } as Styles)),\n    '& b, & strong': {\n      fontWeight: fontWeight.bold,\n    },\n    '& em, & i': {\n      fontStyle: 'normal',\n    },\n  };\n};\n\nexport const getTextHiddenJssStyle = (isHidden: boolean): JssStyle =>\n  isHidden\n    ? getScreenReaderOnlyJssStyle()\n    : {\n        position: 'static',\n        width: 'auto',\n        height: 'auto',\n        margin: 0,\n        overflow: 'visible',\n        clip: 'auto',\n        clipPath: 'none',\n        whiteSpace: 'normal',\n      };\n\nexport const getFormTextHiddenJssStyle = (isHidden: boolean): JssStyle => ({\n  ...getTextHiddenJssStyle(isHidden),\n  width: 'fit-content',\n  padding: `0 0 ${pxToRemWithUnit(4)}`,\n});\n\nexport const getFormCheckboxRadioHiddenJssStyle = (isHidden: boolean): JssStyle => ({\n  ...getTextHiddenJssStyle(isHidden),\n  width: 'auto',\n  padding: `0 0 0 ${pxToRemWithUnit(8)}`,\n});\n\n/**\n * Screen reader only styles to hide (text-)contents visually in the browser but grant access for screen readers\n */\nexport const getScreenReaderOnlyJssStyle = (): JssStyle => {\n  return {\n    position: 'absolute',\n    height: '1px',\n    width: '1px',\n    border: '0',\n    margin: '-1px',\n    overflow: 'hidden',\n    clip: 'rect(1px,1px,1px,1px)',\n    clipPath: 'inset(50%)',\n    whiteSpace: 'nowrap',\n  };\n};\n\nexport const getBackfaceVisibilityJssStyle = (): JssStyle => ({\n  backfaceVisibility: 'hidden',\n  WebkitBackfaceVisibility: 'hidden',\n});\n","var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexport var isBrowser = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\" && (typeof document === \"undefined\" ? \"undefined\" : _typeof(document)) === 'object' && document.nodeType === 9;\n\nexport default isBrowser;\n","function webpackEmptyAsyncContext(req) {\n\t// Here Promise.resolve().then() is used instead of new Promise() to prevent\n\t// uncaught exception popping up in devtools\n\treturn Promise.resolve().then(function() {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t});\n}\nwebpackEmptyAsyncContext.keys = function() { return []; };\nwebpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;\nmodule.exports = webpackEmptyAsyncContext;\nwebpackEmptyAsyncContext.id = \"eca6\";","var classof = require('../internals/classof-raw');\nvar global = require('../internals/global');\n\nmodule.exports = classof(global.process) == 'process';\n"],"sourceRoot":""}