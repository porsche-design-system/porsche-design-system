/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { AlignLabel, BreakpointCustomizable, ButtonType, ButtonVariant, FormState, IconName, IconSize, LinkButtonPureIconName, LinkTarget, LinkVariant, NumberOfPageLinks, PageChangeEvent, SelectedAriaAttributes, TextAlign, TextColor, TextSize, TextWeight, Theme, ThemeExtendedElectric, ThemeExtendedElectricDark } from "./types";
import { AccordionChangeEvent, AccordionSize } from "./components/content/accordion/accordion-utils";
import { HeadlineTag, HeadlineVariant } from "./components/basic/typography/headline/headline-utils";
import { BannerState } from "./components/feedback/banner/banner-utils";
import { ButtonAriaAttributes } from "./components/action/button/button-utils";
import { ButtonGroupDirection } from "./components/layout/button-group/button-group-utils";
import { ContentWrapperBackgroundColor, ContentWrapperWidth } from "./components/layout/content-wrapper/content-wrapper-utils";
import { DividerColor, DividerOrientation } from "./components/layout/divider/divider-utils";
import { FlexAlignContent, FlexAlignItems, FlexDirection, FlexInline, FlexJustifyContent, FlexWrap } from "./components/layout/flex/flex/flex-utils";
import { FlexItemAlignSelf, FlexItemFlex, FlexItemGrow, FlexItemOffset, FlexItemShrink, FlexItemWidth } from "./components/layout/flex/flex-item/flex-item-utils";
import { GridDirection, GridGutter, GridWrap } from "./components/layout/grid/grid/grid-utils";
import { GridItemOffset, GridItemSize } from "./components/layout/grid/grid-item/grid-item-utils";
import { IconAriaAttributes } from "./components/icon/icon/icon-utils";
import { InlineNotificationState } from "./components/feedback/inline-notification/inline-notification-utils";
import { LinkAriaAttributes } from "./components/navigation/link/link-utils";
import { SocialIconName } from "./components/navigation/link-social/link-social-utils";
import { MarqueAriaAttributes, MarqueSize } from "./components/basic/marque/marque-utils";
import { PopoverDirection } from "./components/feedback/popover/popover-utils";
import { DropdownDirection } from "./components/form/select-wrapper/select-wrapper/select-wrapper-utils";
import { SpinnerAriaAttributes, SpinnerSize } from "./components/feedback/spinner/spinner-utils";
import { SwitchChangeEvent } from "./components/action/switch/switch";
import { SortingChangeEvent, TableHeadCellSort } from "./components/content/table/table/table-utils";
import { TabChangeEvent, TabGradientColorTheme, TabSize, TabWeight } from "./components/navigation/tabs-bar/tabs-bar-utils";
import { TextFieldWrapperUnitPosition } from "./components/form/text-field-wrapper/text-field-wrapper-utils";
import { ListType, OrderType } from "./components/content/text-list/text-list/text-list-utils";
import { ToastMessage } from "./components/feedback/toast/toast/toast-manager";
import { ToastState } from "./components/feedback/toast/toast/toast-utils";
export namespace Components {
    interface PAccordion {
        /**
          * Displays the Accordion as compact version with thinner border and smaller paddings.
         */
        "compact"?: boolean;
        /**
          * Defines the heading used in accordion.
         */
        "heading"?: string;
        /**
          * Defines if accordion is open.
         */
        "open"?: boolean;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<AccordionSize>;
        /**
          * Sets a headline tag, so it fits correctly within the outline of the page.
         */
        "tag"?: HeadlineTag;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: ThemeExtendedElectric;
    }
    interface PBanner {
        /**
          * Defines if the banner can be closed/removed by the user.
         */
        "persistent"?: boolean;
        /**
          * State of the banner.
         */
        "state"?: BannerState;
        /**
          * Adapts the banner color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Defines the width of the banner corresponding to the `content-wrapper` dimensions
         */
        "width"?: 'basic' | 'extended' | 'fluid';
    }
    interface PButton {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonAriaAttributes>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown.
         */
        "icon"?: IconName;
        /**
          * A custom URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * To remove the element from tab order.
         */
        "tabbable"?: boolean;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: ThemeExtendedElectric;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonType;
        /**
          * The style variant of the button.
         */
        "variant"?: ButtonVariant;
    }
    interface PButtonGroup {
        /**
          * Defines the direction of the main and cross axis. The default is ’{base: ‘column’, xs: ‘row’}' showing buttons vertically stacked on mobile viewports and side-by-side in a horizontal row from breakpoint ‘xs’. You always need to provide a base value when using breakpoints.
         */
        "direction"?: ButtonGroupDirection;
    }
    interface PButtonPure {
        /**
          * Display button in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: AlignLabel;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonAriaAttributes>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown.
         */
        "icon"?: LinkButtonPureIconName;
        /**
          * A custom URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Size of the button.
         */
        "size"?: BreakpointCustomizable<TextSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * To remove the element from tab order.
         */
        "tabbable"?: boolean;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: ThemeExtendedElectricDark;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonType;
        /**
          * The weight of the text (only has effect with visible label).
         */
        "weight"?: TextWeight;
    }
    interface PCheckboxWrapper {
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: FormState;
    }
    interface PContentWrapper {
        /**
          * Defines the background color.
         */
        "backgroundColor"?: ContentWrapperBackgroundColor;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * Defines the outer spacings between the content area and the left and right screen sides, as well as centering its content and setting a max-width.
         */
        "width"?: ContentWrapperWidth;
    }
    interface PDivider {
        /**
          * Defines color depending on theme.
         */
        "color"?: DividerColor;
        /**
          * Defines orientation.
         */
        "orientation"?: DividerOrientation;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    interface PFieldsetWrapper {
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The size of the label text.
         */
        "labelSize"?: Extract<TextSize, 'small' | 'medium'>;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Marks the Fieldset as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: FormState;
    }
    interface PFlex {
        /**
          * This aligns a flex container's individual lines when there is extra space in the cross-axis, similar to how "justifyContent" aligns individual items along the main axis.
         */
        "alignContent"?: FlexAlignContent;
        /**
          * Defines how the flex items are aligned along the cross axis.
         */
        "alignItems"?: FlexAlignItems;
        /**
          * Defines the direction of the main and cross axis. The default "row" defines the main axis as horizontal left to right.
         */
        "direction"?: FlexDirection;
        /**
          * Defines the flex containers content flow if 2 or more containers are siblings of each other.
         */
        "inline"?: FlexInline;
        /**
          * Defines how the flex items are aligned along the main axis.
         */
        "justifyContent"?: FlexJustifyContent;
        /**
          * Handles wrapping behaviour of elements.
         */
        "wrap"?: FlexWrap;
    }
    interface PFlexItem {
        /**
          * Defines how this flex item is aligned along the cross axis. This overwrites the cross axis alignment set by the container. Corresponds to the "alignSelf" css property.
         */
        "alignSelf"?: FlexItemAlignSelf;
        /**
          * The shorthand property for the combined definition of "shrink", "grow" and "basis"
         */
        "flex"?: FlexItemFlex;
        /**
          * The ability to allow/disallow the flex child to grow.
         */
        "grow"?: FlexItemGrow;
        /**
          * The offset of the column. You can also supply values for specific breakpoints, like {base: "none", l: "one-quarter"}. You always need to provide a base value when doing this.
         */
        "offset"?: FlexItemOffset;
        /**
          * The ability to allow/disallow the flex child to shrink.
         */
        "shrink"?: FlexItemShrink;
        /**
          * The width of the flex item. You can also supply values for specific breakpoints, like {base: "full", l: "one-quarter"}. You always need to provide a base value when doing this.
         */
        "width"?: FlexItemWidth;
    }
    interface PGrid {
        /**
          * Defines the direction of the main and cross axis. The default "row" defines the main axis as horizontal left to right. Also defines the direction for specific breakpoints, like {base: "column", l: "row"}. You always need to provide a base value when doing this.
         */
        "direction"?: GridDirection;
        /**
          * Defines the gutter size for specific breakpoints. You always need to provide a base value when doing this.
         */
        "gutter"?: GridGutter;
        /**
          * Handles wrapping behaviour of elements.
         */
        "wrap"?: GridWrap;
    }
    interface PGridItem {
        /**
          * The offset of the column. Can be between 0 and 11. Also defines the offset of the column for specific breakpoints, like {base: 6, l: 3}. You always need to provide a base value when doing this.
         */
        "offset"?: GridItemOffset;
        /**
          * The size of the column. Can be between 1 and 12. Also defines the size of the column for specific breakpoints, like {base: 6, l: 3}. You always need to provide a base value when doing this.
         */
        "size"?: GridItemSize;
    }
    interface PHeadline {
        /**
          * Text alignment of the component.
         */
        "align"?: TextAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: Extract<TextColor, 'default' | 'inherit'>;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Sets a custom HTML tag depending of the usage of the headline component.
         */
        "tag"?: HeadlineTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
        /**
          * Predefined style of the headline.
         */
        "variant"?: HeadlineVariant;
    }
    interface PIcon {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<IconAriaAttributes>;
        /**
          * Basic color variations depending on theme property.
         */
        "color"?: TextColor;
        /**
          * If enabled, icon will be loaded lazily when it's visible in the viewport.
         */
        "lazy"?: boolean;
        /**
          * Specifies which icon to use.
         */
        "name"?: IconName;
        /**
          * The size of the icon.
         */
        "size"?: IconSize;
        /**
          * Specifies a whole icon path which can be used for custom icons.
         */
        "source"?: string;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: ThemeExtendedElectricDark;
    }
    interface PInlineNotification {
        /**
          * Action icon of the inline-notification.
         */
        "actionIcon"?: IconName;
        /**
          * Action label of the inline-notification.
         */
        "actionLabel"?: string;
        /**
          * Disables the action button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "actionLoading"?: boolean;
        /**
          * Description of the inline-notification.
         */
        "description"?: string;
        /**
          * Heading of the inline-notification.
         */
        "heading"?: string;
        /**
          * Defines if the inline-notification can be closed/removed by the user.
         */
        "persistent"?: boolean;
        /**
          * State of the inline-notification.
         */
        "state"?: InlineNotificationState;
        /**
          * Adapts the inline-notification color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PLink {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkAriaAttributes>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown.
         */
        "icon"?: IconName;
        /**
          * A custom URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTarget;
        /**
          * Adapts the link color when used on dark background.
         */
        "theme"?: ThemeExtendedElectric;
        /**
          * The style variant of the link.
         */
        "variant"?: LinkVariant;
    }
    interface PLinkPure {
        /**
          * Display link in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: AlignLabel;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkAriaAttributes>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed
         */
        "icon"?: LinkButtonPureIconName;
        /**
          * A custom URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Size of the link.
         */
        "size"?: BreakpointCustomizable<TextSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTarget;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: ThemeExtendedElectricDark;
        /**
          * The weight of the text (only has effect with visible label).
         */
        "weight"?: TextWeight;
    }
    interface PLinkSocial {
        /**
          * Show or hide label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown.
         */
        "icon"?: SocialIconName;
        /**
          * A custom URL path to a custom social icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTarget;
        /**
          * Adapts the link color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PMarque {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<MarqueAriaAttributes>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Adapts sizing of marque.
         */
        "size"?: MarqueSize;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTarget;
        /**
          * Show/hide trademark sign.
         */
        "trademark"?: boolean;
    }
    interface PModal {
        /**
          * If true, the modal will not be closable via backdrop click.
         */
        "disableBackdropClick"?: boolean;
        /**
          * If true, the modal will not have a close button.
         */
        "disableCloseButton"?: boolean;
        /**
          * If true the modal uses max viewport height and width. Should only be used for mobile.
         */
        "fullscreen"?: BreakpointCustomizable<boolean>;
        /**
          * The title of the modal
         */
        "heading"?: string;
        /**
          * If true, the modal is open.
         */
        "open": boolean;
    }
    interface PPagination {
        /**
          * Index of the currently active page.
         */
        "activePage"?: number;
        /**
          * Aria label what the pagination is used for.
         */
        "allyLabel"?: string;
        /**
          * Aria label for next page icon.
         */
        "allyLabelNext"?: string;
        /**
          * Aria label for page navigation.
         */
        "allyLabelPage"?: string;
        /**
          * Aria label for previous page icon.
         */
        "allyLabelPrev"?: string;
        /**
          * The total count of items which should be shown per page.
         */
        "itemsPerPage": number;
        /**
          * The maximum number of page links rendered
         */
        "maxNumberOfPageLinks"?: BreakpointCustomizable<NumberOfPageLinks>;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The total count of items.
         */
        "totalItemsCount": number;
    }
    interface PPopover {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<'aria-label'>;
        /**
          * Descriptive text to show additional information when popover is open
         */
        "description"?: string;
        /**
          * Preferred direction in which popover should open, given there is enough space in viewport. Otherwise it will be opened in the direction with most available space.
         */
        "direction": PopoverDirection;
    }
    interface PRadioButtonWrapper {
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: FormState;
    }
    interface PSelectWrapper {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Changes the direction to which the dropdown list appears.
         */
        "dropdownDirection"?: DropdownDirection;
        /**
          * Filters select options by typing a character
         */
        "filter"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Forces rendering of native browser select dropdown
         */
        "native"?: boolean;
        /**
          * The validation state.
         */
        "state"?: FormState;
        /**
          * Adapts the select color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PSelectWrapperDropdown {
        "description"?: string;
        "direction"?: DropdownDirection;
        "disabled"?: boolean;
        "filter"?: boolean;
        "isOpenOverride"?: boolean;
        "label"?: string;
        "message"?: string;
        "onOpenChange": (isOpen: boolean) => void;
        "required"?: boolean;
        "selectRef"?: HTMLSelectElement;
        "state"?: FormState;
        "theme"?: Theme;
    }
    interface PSpinner {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SpinnerAriaAttributes>;
        /**
          * Size of the spinner.
         */
        "size"?: SpinnerSize;
        /**
          * Adapts the spinner color depending on the theme.
         */
        "theme"?: ThemeExtendedElectricDark;
    }
    interface PSwitch {
        /**
          * Aligns the label.
         */
        "alignLabel"?: AlignLabel;
        /**
          * Visualize the switch with on/off status.
         */
        "checked"?: boolean;
        /**
          * Disables the switch. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Disables the switch and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Stretches the contents to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * To remove the element from tab order.
         */
        "tabbable"?: boolean;
        /**
          * Adapts the switch color depending on the theme.
         */
        "theme"?: ThemeExtendedElectric;
    }
    interface PTable {
        /**
          * A caption describing the contents of the table for accessibility only. This won't be visible in the browser. Use an element with an attribute of slot="name" for a visible caption.
         */
        "caption"?: string;
    }
    interface PTableBody {
    }
    interface PTableCell {
        /**
          * Displays slotted text multiline or forced into a single line.
         */
        "multiline"?: boolean;
    }
    interface PTableHead {
    }
    interface PTableHeadCell {
        /**
          * Hides the label but stays accessible for screen readers. This property only takes effect when sort property is not defined.
         */
        "hideLabel"?: boolean;
        /**
          * Defines sortability properties.
         */
        "sort"?: TableHeadCellSort;
    }
    interface PTableHeadRow {
    }
    interface PTableRow {
    }
    interface PTabs {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering).
         */
        "activeTabIndex"?: number;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: TabGradientColorTheme;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabSize>;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: ThemeExtendedElectric;
        /**
          * The text weight.
         */
        "weight"?: TabWeight;
    }
    interface PTabsBar {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering), undefined if none should be selected.
         */
        "activeTabIndex"?: number | undefined;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: TabGradientColorTheme;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabSize>;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: ThemeExtendedElectric;
        /**
          * The text weight.
         */
        "weight"?: TabWeight;
    }
    interface PTabsItem {
        /**
          * Defines the label used in tabs.
         */
        "label": string;
    }
    interface PText {
        /**
          * Text alignment of the component.
         */
        "align"?: TextAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: TextColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the text. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<TextSize>;
        /**
          * Sets a custom HTML tag depending of the usage of the text component.
         */
        "tag"?: 'p' | 'span' | 'div' | 'address' | 'blockquote' | 'figcaption' | 'cite' | 'time' | 'legend';
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
        /**
          * The weight of the text.
         */
        "weight"?: TextWeight;
    }
    interface PTextFieldWrapper {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Show or hide label and description text. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: FormState;
        /**
          * The unit text.
         */
        "unit"?: string;
        /**
          * The unit position.
         */
        "unitPosition"?: TextFieldWrapperUnitPosition;
    }
    interface PTextList {
        /**
          * The type of the text list.
         */
        "listType"?: ListType;
        /**
          * The list style type of an ordered list.
         */
        "orderType"?: OrderType;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
    }
    interface PTextListItem {
    }
    interface PTextareaWrapper {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: FormState;
    }
    interface PToast {
        "addMessage": (message: ToastMessage) => Promise<void>;
        /**
          * Adapts the toast color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PToastItem {
        /**
          * State of the toast-item.
         */
        "state"?: ToastState;
        /**
          * Text of the toast-item.
         */
        "text"?: string;
        /**
          * Adapts the toast-item color depending on the theme.
         */
        "theme"?: Theme;
    }
}
declare global {
    interface HTMLPAccordionElement extends Components.PAccordion, HTMLStencilElement {
    }
    var HTMLPAccordionElement: {
        prototype: HTMLPAccordionElement;
        new (): HTMLPAccordionElement;
    };
    interface HTMLPBannerElement extends Components.PBanner, HTMLStencilElement {
    }
    var HTMLPBannerElement: {
        prototype: HTMLPBannerElement;
        new (): HTMLPBannerElement;
    };
    interface HTMLPButtonElement extends Components.PButton, HTMLStencilElement {
    }
    var HTMLPButtonElement: {
        prototype: HTMLPButtonElement;
        new (): HTMLPButtonElement;
    };
    interface HTMLPButtonGroupElement extends Components.PButtonGroup, HTMLStencilElement {
    }
    var HTMLPButtonGroupElement: {
        prototype: HTMLPButtonGroupElement;
        new (): HTMLPButtonGroupElement;
    };
    interface HTMLPButtonPureElement extends Components.PButtonPure, HTMLStencilElement {
    }
    var HTMLPButtonPureElement: {
        prototype: HTMLPButtonPureElement;
        new (): HTMLPButtonPureElement;
    };
    interface HTMLPCheckboxWrapperElement extends Components.PCheckboxWrapper, HTMLStencilElement {
    }
    var HTMLPCheckboxWrapperElement: {
        prototype: HTMLPCheckboxWrapperElement;
        new (): HTMLPCheckboxWrapperElement;
    };
    interface HTMLPContentWrapperElement extends Components.PContentWrapper, HTMLStencilElement {
    }
    var HTMLPContentWrapperElement: {
        prototype: HTMLPContentWrapperElement;
        new (): HTMLPContentWrapperElement;
    };
    interface HTMLPDividerElement extends Components.PDivider, HTMLStencilElement {
    }
    var HTMLPDividerElement: {
        prototype: HTMLPDividerElement;
        new (): HTMLPDividerElement;
    };
    interface HTMLPFieldsetWrapperElement extends Components.PFieldsetWrapper, HTMLStencilElement {
    }
    var HTMLPFieldsetWrapperElement: {
        prototype: HTMLPFieldsetWrapperElement;
        new (): HTMLPFieldsetWrapperElement;
    };
    interface HTMLPFlexElement extends Components.PFlex, HTMLStencilElement {
    }
    var HTMLPFlexElement: {
        prototype: HTMLPFlexElement;
        new (): HTMLPFlexElement;
    };
    interface HTMLPFlexItemElement extends Components.PFlexItem, HTMLStencilElement {
    }
    var HTMLPFlexItemElement: {
        prototype: HTMLPFlexItemElement;
        new (): HTMLPFlexItemElement;
    };
    interface HTMLPGridElement extends Components.PGrid, HTMLStencilElement {
    }
    var HTMLPGridElement: {
        prototype: HTMLPGridElement;
        new (): HTMLPGridElement;
    };
    interface HTMLPGridItemElement extends Components.PGridItem, HTMLStencilElement {
    }
    var HTMLPGridItemElement: {
        prototype: HTMLPGridItemElement;
        new (): HTMLPGridItemElement;
    };
    interface HTMLPHeadlineElement extends Components.PHeadline, HTMLStencilElement {
    }
    var HTMLPHeadlineElement: {
        prototype: HTMLPHeadlineElement;
        new (): HTMLPHeadlineElement;
    };
    interface HTMLPIconElement extends Components.PIcon, HTMLStencilElement {
    }
    var HTMLPIconElement: {
        prototype: HTMLPIconElement;
        new (): HTMLPIconElement;
    };
    interface HTMLPInlineNotificationElement extends Components.PInlineNotification, HTMLStencilElement {
    }
    var HTMLPInlineNotificationElement: {
        prototype: HTMLPInlineNotificationElement;
        new (): HTMLPInlineNotificationElement;
    };
    interface HTMLPLinkElement extends Components.PLink, HTMLStencilElement {
    }
    var HTMLPLinkElement: {
        prototype: HTMLPLinkElement;
        new (): HTMLPLinkElement;
    };
    interface HTMLPLinkPureElement extends Components.PLinkPure, HTMLStencilElement {
    }
    var HTMLPLinkPureElement: {
        prototype: HTMLPLinkPureElement;
        new (): HTMLPLinkPureElement;
    };
    interface HTMLPLinkSocialElement extends Components.PLinkSocial, HTMLStencilElement {
    }
    var HTMLPLinkSocialElement: {
        prototype: HTMLPLinkSocialElement;
        new (): HTMLPLinkSocialElement;
    };
    interface HTMLPMarqueElement extends Components.PMarque, HTMLStencilElement {
    }
    var HTMLPMarqueElement: {
        prototype: HTMLPMarqueElement;
        new (): HTMLPMarqueElement;
    };
    interface HTMLPModalElement extends Components.PModal, HTMLStencilElement {
    }
    var HTMLPModalElement: {
        prototype: HTMLPModalElement;
        new (): HTMLPModalElement;
    };
    interface HTMLPPaginationElement extends Components.PPagination, HTMLStencilElement {
    }
    var HTMLPPaginationElement: {
        prototype: HTMLPPaginationElement;
        new (): HTMLPPaginationElement;
    };
    interface HTMLPPopoverElement extends Components.PPopover, HTMLStencilElement {
    }
    var HTMLPPopoverElement: {
        prototype: HTMLPPopoverElement;
        new (): HTMLPPopoverElement;
    };
    interface HTMLPRadioButtonWrapperElement extends Components.PRadioButtonWrapper, HTMLStencilElement {
    }
    var HTMLPRadioButtonWrapperElement: {
        prototype: HTMLPRadioButtonWrapperElement;
        new (): HTMLPRadioButtonWrapperElement;
    };
    interface HTMLPSelectWrapperElement extends Components.PSelectWrapper, HTMLStencilElement {
    }
    var HTMLPSelectWrapperElement: {
        prototype: HTMLPSelectWrapperElement;
        new (): HTMLPSelectWrapperElement;
    };
    interface HTMLPSelectWrapperDropdownElement extends Components.PSelectWrapperDropdown, HTMLStencilElement {
    }
    var HTMLPSelectWrapperDropdownElement: {
        prototype: HTMLPSelectWrapperDropdownElement;
        new (): HTMLPSelectWrapperDropdownElement;
    };
    interface HTMLPSpinnerElement extends Components.PSpinner, HTMLStencilElement {
    }
    var HTMLPSpinnerElement: {
        prototype: HTMLPSpinnerElement;
        new (): HTMLPSpinnerElement;
    };
    interface HTMLPSwitchElement extends Components.PSwitch, HTMLStencilElement {
    }
    var HTMLPSwitchElement: {
        prototype: HTMLPSwitchElement;
        new (): HTMLPSwitchElement;
    };
    interface HTMLPTableElement extends Components.PTable, HTMLStencilElement {
    }
    var HTMLPTableElement: {
        prototype: HTMLPTableElement;
        new (): HTMLPTableElement;
    };
    interface HTMLPTableBodyElement extends Components.PTableBody, HTMLStencilElement {
    }
    var HTMLPTableBodyElement: {
        prototype: HTMLPTableBodyElement;
        new (): HTMLPTableBodyElement;
    };
    interface HTMLPTableCellElement extends Components.PTableCell, HTMLStencilElement {
    }
    var HTMLPTableCellElement: {
        prototype: HTMLPTableCellElement;
        new (): HTMLPTableCellElement;
    };
    interface HTMLPTableHeadElement extends Components.PTableHead, HTMLStencilElement {
    }
    var HTMLPTableHeadElement: {
        prototype: HTMLPTableHeadElement;
        new (): HTMLPTableHeadElement;
    };
    interface HTMLPTableHeadCellElement extends Components.PTableHeadCell, HTMLStencilElement {
    }
    var HTMLPTableHeadCellElement: {
        prototype: HTMLPTableHeadCellElement;
        new (): HTMLPTableHeadCellElement;
    };
    interface HTMLPTableHeadRowElement extends Components.PTableHeadRow, HTMLStencilElement {
    }
    var HTMLPTableHeadRowElement: {
        prototype: HTMLPTableHeadRowElement;
        new (): HTMLPTableHeadRowElement;
    };
    interface HTMLPTableRowElement extends Components.PTableRow, HTMLStencilElement {
    }
    var HTMLPTableRowElement: {
        prototype: HTMLPTableRowElement;
        new (): HTMLPTableRowElement;
    };
    interface HTMLPTabsElement extends Components.PTabs, HTMLStencilElement {
    }
    var HTMLPTabsElement: {
        prototype: HTMLPTabsElement;
        new (): HTMLPTabsElement;
    };
    interface HTMLPTabsBarElement extends Components.PTabsBar, HTMLStencilElement {
    }
    var HTMLPTabsBarElement: {
        prototype: HTMLPTabsBarElement;
        new (): HTMLPTabsBarElement;
    };
    interface HTMLPTabsItemElement extends Components.PTabsItem, HTMLStencilElement {
    }
    var HTMLPTabsItemElement: {
        prototype: HTMLPTabsItemElement;
        new (): HTMLPTabsItemElement;
    };
    interface HTMLPTextElement extends Components.PText, HTMLStencilElement {
    }
    var HTMLPTextElement: {
        prototype: HTMLPTextElement;
        new (): HTMLPTextElement;
    };
    interface HTMLPTextFieldWrapperElement extends Components.PTextFieldWrapper, HTMLStencilElement {
    }
    var HTMLPTextFieldWrapperElement: {
        prototype: HTMLPTextFieldWrapperElement;
        new (): HTMLPTextFieldWrapperElement;
    };
    interface HTMLPTextListElement extends Components.PTextList, HTMLStencilElement {
    }
    var HTMLPTextListElement: {
        prototype: HTMLPTextListElement;
        new (): HTMLPTextListElement;
    };
    interface HTMLPTextListItemElement extends Components.PTextListItem, HTMLStencilElement {
    }
    var HTMLPTextListItemElement: {
        prototype: HTMLPTextListItemElement;
        new (): HTMLPTextListItemElement;
    };
    interface HTMLPTextareaWrapperElement extends Components.PTextareaWrapper, HTMLStencilElement {
    }
    var HTMLPTextareaWrapperElement: {
        prototype: HTMLPTextareaWrapperElement;
        new (): HTMLPTextareaWrapperElement;
    };
    interface HTMLPToastElement extends Components.PToast, HTMLStencilElement {
    }
    var HTMLPToastElement: {
        prototype: HTMLPToastElement;
        new (): HTMLPToastElement;
    };
    interface HTMLPToastItemElement extends Components.PToastItem, HTMLStencilElement {
    }
    var HTMLPToastItemElement: {
        prototype: HTMLPToastItemElement;
        new (): HTMLPToastItemElement;
    };
    interface HTMLElementTagNameMap {
        "p-accordion": HTMLPAccordionElement;
        "p-banner": HTMLPBannerElement;
        "p-button": HTMLPButtonElement;
        "p-button-group": HTMLPButtonGroupElement;
        "p-button-pure": HTMLPButtonPureElement;
        "p-checkbox-wrapper": HTMLPCheckboxWrapperElement;
        "p-content-wrapper": HTMLPContentWrapperElement;
        "p-divider": HTMLPDividerElement;
        "p-fieldset-wrapper": HTMLPFieldsetWrapperElement;
        "p-flex": HTMLPFlexElement;
        "p-flex-item": HTMLPFlexItemElement;
        "p-grid": HTMLPGridElement;
        "p-grid-item": HTMLPGridItemElement;
        "p-headline": HTMLPHeadlineElement;
        "p-icon": HTMLPIconElement;
        "p-inline-notification": HTMLPInlineNotificationElement;
        "p-link": HTMLPLinkElement;
        "p-link-pure": HTMLPLinkPureElement;
        "p-link-social": HTMLPLinkSocialElement;
        "p-marque": HTMLPMarqueElement;
        "p-modal": HTMLPModalElement;
        "p-pagination": HTMLPPaginationElement;
        "p-popover": HTMLPPopoverElement;
        "p-radio-button-wrapper": HTMLPRadioButtonWrapperElement;
        "p-select-wrapper": HTMLPSelectWrapperElement;
        "p-select-wrapper-dropdown": HTMLPSelectWrapperDropdownElement;
        "p-spinner": HTMLPSpinnerElement;
        "p-switch": HTMLPSwitchElement;
        "p-table": HTMLPTableElement;
        "p-table-body": HTMLPTableBodyElement;
        "p-table-cell": HTMLPTableCellElement;
        "p-table-head": HTMLPTableHeadElement;
        "p-table-head-cell": HTMLPTableHeadCellElement;
        "p-table-head-row": HTMLPTableHeadRowElement;
        "p-table-row": HTMLPTableRowElement;
        "p-tabs": HTMLPTabsElement;
        "p-tabs-bar": HTMLPTabsBarElement;
        "p-tabs-item": HTMLPTabsItemElement;
        "p-text": HTMLPTextElement;
        "p-text-field-wrapper": HTMLPTextFieldWrapperElement;
        "p-text-list": HTMLPTextListElement;
        "p-text-list-item": HTMLPTextListItemElement;
        "p-textarea-wrapper": HTMLPTextareaWrapperElement;
        "p-toast": HTMLPToastElement;
        "p-toast-item": HTMLPToastItemElement;
    }
}
declare namespace LocalJSX {
    interface PAccordion {
        /**
          * Displays the Accordion as compact version with thinner border and smaller paddings.
         */
        "compact"?: boolean;
        /**
          * Defines the heading used in accordion.
         */
        "heading"?: string;
        /**
          * Emitted when accordion state is changed.
         */
        "onAccordionChange"?: (event: CustomEvent<AccordionChangeEvent>) => void;
        /**
          * Defines if accordion is open.
         */
        "open"?: boolean;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<AccordionSize>;
        /**
          * Sets a headline tag, so it fits correctly within the outline of the page.
         */
        "tag"?: HeadlineTag;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: ThemeExtendedElectric;
    }
    interface PBanner {
        /**
          * Emitted when the close button is clicked.
         */
        "onDismiss"?: (event: CustomEvent<void>) => void;
        /**
          * Defines if the banner can be closed/removed by the user.
         */
        "persistent"?: boolean;
        /**
          * State of the banner.
         */
        "state"?: BannerState;
        /**
          * Adapts the banner color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Defines the width of the banner corresponding to the `content-wrapper` dimensions
         */
        "width"?: 'basic' | 'extended' | 'fluid';
    }
    interface PButton {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonAriaAttributes>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown.
         */
        "icon"?: IconName;
        /**
          * A custom URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * To remove the element from tab order.
         */
        "tabbable"?: boolean;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: ThemeExtendedElectric;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonType;
        /**
          * The style variant of the button.
         */
        "variant"?: ButtonVariant;
    }
    interface PButtonGroup {
        /**
          * Defines the direction of the main and cross axis. The default is ’{base: ‘column’, xs: ‘row’}' showing buttons vertically stacked on mobile viewports and side-by-side in a horizontal row from breakpoint ‘xs’. You always need to provide a base value when using breakpoints.
         */
        "direction"?: ButtonGroupDirection;
    }
    interface PButtonPure {
        /**
          * Display button in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: AlignLabel;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonAriaAttributes>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown.
         */
        "icon"?: LinkButtonPureIconName;
        /**
          * A custom URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Size of the button.
         */
        "size"?: BreakpointCustomizable<TextSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * To remove the element from tab order.
         */
        "tabbable"?: boolean;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: ThemeExtendedElectricDark;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonType;
        /**
          * The weight of the text (only has effect with visible label).
         */
        "weight"?: TextWeight;
    }
    interface PCheckboxWrapper {
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: FormState;
    }
    interface PContentWrapper {
        /**
          * Defines the background color.
         */
        "backgroundColor"?: ContentWrapperBackgroundColor;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * Defines the outer spacings between the content area and the left and right screen sides, as well as centering its content and setting a max-width.
         */
        "width"?: ContentWrapperWidth;
    }
    interface PDivider {
        /**
          * Defines color depending on theme.
         */
        "color"?: DividerColor;
        /**
          * Defines orientation.
         */
        "orientation"?: DividerOrientation;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    interface PFieldsetWrapper {
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The size of the label text.
         */
        "labelSize"?: Extract<TextSize, 'small' | 'medium'>;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Marks the Fieldset as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: FormState;
    }
    interface PFlex {
        /**
          * This aligns a flex container's individual lines when there is extra space in the cross-axis, similar to how "justifyContent" aligns individual items along the main axis.
         */
        "alignContent"?: FlexAlignContent;
        /**
          * Defines how the flex items are aligned along the cross axis.
         */
        "alignItems"?: FlexAlignItems;
        /**
          * Defines the direction of the main and cross axis. The default "row" defines the main axis as horizontal left to right.
         */
        "direction"?: FlexDirection;
        /**
          * Defines the flex containers content flow if 2 or more containers are siblings of each other.
         */
        "inline"?: FlexInline;
        /**
          * Defines how the flex items are aligned along the main axis.
         */
        "justifyContent"?: FlexJustifyContent;
        /**
          * Handles wrapping behaviour of elements.
         */
        "wrap"?: FlexWrap;
    }
    interface PFlexItem {
        /**
          * Defines how this flex item is aligned along the cross axis. This overwrites the cross axis alignment set by the container. Corresponds to the "alignSelf" css property.
         */
        "alignSelf"?: FlexItemAlignSelf;
        /**
          * The shorthand property for the combined definition of "shrink", "grow" and "basis"
         */
        "flex"?: FlexItemFlex;
        /**
          * The ability to allow/disallow the flex child to grow.
         */
        "grow"?: FlexItemGrow;
        /**
          * The offset of the column. You can also supply values for specific breakpoints, like {base: "none", l: "one-quarter"}. You always need to provide a base value when doing this.
         */
        "offset"?: FlexItemOffset;
        /**
          * The ability to allow/disallow the flex child to shrink.
         */
        "shrink"?: FlexItemShrink;
        /**
          * The width of the flex item. You can also supply values for specific breakpoints, like {base: "full", l: "one-quarter"}. You always need to provide a base value when doing this.
         */
        "width"?: FlexItemWidth;
    }
    interface PGrid {
        /**
          * Defines the direction of the main and cross axis. The default "row" defines the main axis as horizontal left to right. Also defines the direction for specific breakpoints, like {base: "column", l: "row"}. You always need to provide a base value when doing this.
         */
        "direction"?: GridDirection;
        /**
          * Defines the gutter size for specific breakpoints. You always need to provide a base value when doing this.
         */
        "gutter"?: GridGutter;
        /**
          * Handles wrapping behaviour of elements.
         */
        "wrap"?: GridWrap;
    }
    interface PGridItem {
        /**
          * The offset of the column. Can be between 0 and 11. Also defines the offset of the column for specific breakpoints, like {base: 6, l: 3}. You always need to provide a base value when doing this.
         */
        "offset"?: GridItemOffset;
        /**
          * The size of the column. Can be between 1 and 12. Also defines the size of the column for specific breakpoints, like {base: 6, l: 3}. You always need to provide a base value when doing this.
         */
        "size"?: GridItemSize;
    }
    interface PHeadline {
        /**
          * Text alignment of the component.
         */
        "align"?: TextAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: Extract<TextColor, 'default' | 'inherit'>;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Sets a custom HTML tag depending of the usage of the headline component.
         */
        "tag"?: HeadlineTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
        /**
          * Predefined style of the headline.
         */
        "variant"?: HeadlineVariant;
    }
    interface PIcon {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<IconAriaAttributes>;
        /**
          * Basic color variations depending on theme property.
         */
        "color"?: TextColor;
        /**
          * If enabled, icon will be loaded lazily when it's visible in the viewport.
         */
        "lazy"?: boolean;
        /**
          * Specifies which icon to use.
         */
        "name"?: IconName;
        /**
          * The size of the icon.
         */
        "size"?: IconSize;
        /**
          * Specifies a whole icon path which can be used for custom icons.
         */
        "source"?: string;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: ThemeExtendedElectricDark;
    }
    interface PInlineNotification {
        /**
          * Action icon of the inline-notification.
         */
        "actionIcon"?: IconName;
        /**
          * Action label of the inline-notification.
         */
        "actionLabel"?: string;
        /**
          * Disables the action button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "actionLoading"?: boolean;
        /**
          * Description of the inline-notification.
         */
        "description"?: string;
        /**
          * Heading of the inline-notification.
         */
        "heading"?: string;
        /**
          * Emitted when the action button is clicked.
         */
        "onAction"?: (event: CustomEvent<void>) => void;
        /**
          * Emitted when the close button is clicked.
         */
        "onDismiss"?: (event: CustomEvent<void>) => void;
        /**
          * Defines if the inline-notification can be closed/removed by the user.
         */
        "persistent"?: boolean;
        /**
          * State of the inline-notification.
         */
        "state"?: InlineNotificationState;
        /**
          * Adapts the inline-notification color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PLink {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkAriaAttributes>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown.
         */
        "icon"?: IconName;
        /**
          * A custom URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTarget;
        /**
          * Adapts the link color when used on dark background.
         */
        "theme"?: ThemeExtendedElectric;
        /**
          * The style variant of the link.
         */
        "variant"?: LinkVariant;
    }
    interface PLinkPure {
        /**
          * Display link in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: AlignLabel;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkAriaAttributes>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed
         */
        "icon"?: LinkButtonPureIconName;
        /**
          * A custom URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Size of the link.
         */
        "size"?: BreakpointCustomizable<TextSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTarget;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: ThemeExtendedElectricDark;
        /**
          * The weight of the text (only has effect with visible label).
         */
        "weight"?: TextWeight;
    }
    interface PLinkSocial {
        /**
          * Show or hide label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown.
         */
        "icon"?: SocialIconName;
        /**
          * A custom URL path to a custom social icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTarget;
        /**
          * Adapts the link color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PMarque {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<MarqueAriaAttributes>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Adapts sizing of marque.
         */
        "size"?: MarqueSize;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTarget;
        /**
          * Show/hide trademark sign.
         */
        "trademark"?: boolean;
    }
    interface PModal {
        /**
          * If true, the modal will not be closable via backdrop click.
         */
        "disableBackdropClick"?: boolean;
        /**
          * If true, the modal will not have a close button.
         */
        "disableCloseButton"?: boolean;
        /**
          * If true the modal uses max viewport height and width. Should only be used for mobile.
         */
        "fullscreen"?: BreakpointCustomizable<boolean>;
        /**
          * The title of the modal
         */
        "heading"?: string;
        /**
          * Emitted when the component requests to be closed.
         */
        "onClose"?: (event: CustomEvent<void>) => void;
        /**
          * If true, the modal is open.
         */
        "open"?: boolean;
    }
    interface PPagination {
        /**
          * Index of the currently active page.
         */
        "activePage"?: number;
        /**
          * Aria label what the pagination is used for.
         */
        "allyLabel"?: string;
        /**
          * Aria label for next page icon.
         */
        "allyLabelNext"?: string;
        /**
          * Aria label for page navigation.
         */
        "allyLabelPage"?: string;
        /**
          * Aria label for previous page icon.
         */
        "allyLabelPrev"?: string;
        /**
          * The total count of items which should be shown per page.
         */
        "itemsPerPage"?: number;
        /**
          * The maximum number of page links rendered
         */
        "maxNumberOfPageLinks"?: BreakpointCustomizable<NumberOfPageLinks>;
        /**
          * Emitted when the page changes.
         */
        "onPageChange"?: (event: CustomEvent<PageChangeEvent>) => void;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The total count of items.
         */
        "totalItemsCount"?: number;
    }
    interface PPopover {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<'aria-label'>;
        /**
          * Descriptive text to show additional information when popover is open
         */
        "description"?: string;
        /**
          * Preferred direction in which popover should open, given there is enough space in viewport. Otherwise it will be opened in the direction with most available space.
         */
        "direction"?: PopoverDirection;
    }
    interface PRadioButtonWrapper {
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: FormState;
    }
    interface PSelectWrapper {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Changes the direction to which the dropdown list appears.
         */
        "dropdownDirection"?: DropdownDirection;
        /**
          * Filters select options by typing a character
         */
        "filter"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Forces rendering of native browser select dropdown
         */
        "native"?: boolean;
        /**
          * The validation state.
         */
        "state"?: FormState;
        /**
          * Adapts the select color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PSelectWrapperDropdown {
        "description"?: string;
        "direction"?: DropdownDirection;
        "disabled"?: boolean;
        "filter"?: boolean;
        "isOpenOverride"?: boolean;
        "label"?: string;
        "message"?: string;
        "onOpenChange"?: (isOpen: boolean) => void;
        "required"?: boolean;
        "selectRef"?: HTMLSelectElement;
        "state"?: FormState;
        "theme"?: Theme;
    }
    interface PSpinner {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SpinnerAriaAttributes>;
        /**
          * Size of the spinner.
         */
        "size"?: SpinnerSize;
        /**
          * Adapts the spinner color depending on the theme.
         */
        "theme"?: ThemeExtendedElectricDark;
    }
    interface PSwitch {
        /**
          * Aligns the label.
         */
        "alignLabel"?: AlignLabel;
        /**
          * Visualize the switch with on/off status.
         */
        "checked"?: boolean;
        /**
          * Disables the switch. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Disables the switch and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Emitted when checked status is changed.
         */
        "onSwitchChange"?: (event: CustomEvent<SwitchChangeEvent>) => void;
        /**
          * Stretches the contents to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * To remove the element from tab order.
         */
        "tabbable"?: boolean;
        /**
          * Adapts the switch color depending on the theme.
         */
        "theme"?: ThemeExtendedElectric;
    }
    interface PTable {
        /**
          * A caption describing the contents of the table for accessibility only. This won't be visible in the browser. Use an element with an attribute of slot="name" for a visible caption.
         */
        "caption"?: string;
        /**
          * Emitted when sorting is changed.
         */
        "onSortingChange"?: (event: CustomEvent<SortingChangeEvent>) => void;
    }
    interface PTableBody {
    }
    interface PTableCell {
        /**
          * Displays slotted text multiline or forced into a single line.
         */
        "multiline"?: boolean;
    }
    interface PTableHead {
    }
    interface PTableHeadCell {
        /**
          * Hides the label but stays accessible for screen readers. This property only takes effect when sort property is not defined.
         */
        "hideLabel"?: boolean;
        /**
          * Defines sortability properties.
         */
        "sort"?: TableHeadCellSort;
    }
    interface PTableHeadRow {
    }
    interface PTableRow {
    }
    interface PTabs {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering).
         */
        "activeTabIndex"?: number;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: TabGradientColorTheme;
        /**
          * Emitted when active tab is changed.
         */
        "onTabChange"?: (event: CustomEvent<TabChangeEvent>) => void;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabSize>;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: ThemeExtendedElectric;
        /**
          * The text weight.
         */
        "weight"?: TabWeight;
    }
    interface PTabsBar {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering), undefined if none should be selected.
         */
        "activeTabIndex"?: number | undefined;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: TabGradientColorTheme;
        /**
          * Emitted when active tab is changed.
         */
        "onTabChange"?: (event: CustomEvent<TabChangeEvent>) => void;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabSize>;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: ThemeExtendedElectric;
        /**
          * The text weight.
         */
        "weight"?: TabWeight;
    }
    interface PTabsItem {
        /**
          * Defines the label used in tabs.
         */
        "label"?: string;
    }
    interface PText {
        /**
          * Text alignment of the component.
         */
        "align"?: TextAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: TextColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the text. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<TextSize>;
        /**
          * Sets a custom HTML tag depending of the usage of the text component.
         */
        "tag"?: 'p' | 'span' | 'div' | 'address' | 'blockquote' | 'figcaption' | 'cite' | 'time' | 'legend';
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
        /**
          * The weight of the text.
         */
        "weight"?: TextWeight;
    }
    interface PTextFieldWrapper {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Show or hide label and description text. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: FormState;
        /**
          * The unit text.
         */
        "unit"?: string;
        /**
          * The unit position.
         */
        "unitPosition"?: TextFieldWrapperUnitPosition;
    }
    interface PTextList {
        /**
          * The type of the text list.
         */
        "listType"?: ListType;
        /**
          * The list style type of an ordered list.
         */
        "orderType"?: OrderType;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
    }
    interface PTextListItem {
    }
    interface PTextareaWrapper {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: FormState;
    }
    interface PToast {
        /**
          * Adapts the toast color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PToastItem {
        /**
          * Emitted when the close button is clicked.
         */
        "onDismiss"?: (event: CustomEvent<void>) => void;
        /**
          * State of the toast-item.
         */
        "state"?: ToastState;
        /**
          * Text of the toast-item.
         */
        "text"?: string;
        /**
          * Adapts the toast-item color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface IntrinsicElements {
        "p-accordion": PAccordion;
        "p-banner": PBanner;
        "p-button": PButton;
        "p-button-group": PButtonGroup;
        "p-button-pure": PButtonPure;
        "p-checkbox-wrapper": PCheckboxWrapper;
        "p-content-wrapper": PContentWrapper;
        "p-divider": PDivider;
        "p-fieldset-wrapper": PFieldsetWrapper;
        "p-flex": PFlex;
        "p-flex-item": PFlexItem;
        "p-grid": PGrid;
        "p-grid-item": PGridItem;
        "p-headline": PHeadline;
        "p-icon": PIcon;
        "p-inline-notification": PInlineNotification;
        "p-link": PLink;
        "p-link-pure": PLinkPure;
        "p-link-social": PLinkSocial;
        "p-marque": PMarque;
        "p-modal": PModal;
        "p-pagination": PPagination;
        "p-popover": PPopover;
        "p-radio-button-wrapper": PRadioButtonWrapper;
        "p-select-wrapper": PSelectWrapper;
        "p-select-wrapper-dropdown": PSelectWrapperDropdown;
        "p-spinner": PSpinner;
        "p-switch": PSwitch;
        "p-table": PTable;
        "p-table-body": PTableBody;
        "p-table-cell": PTableCell;
        "p-table-head": PTableHead;
        "p-table-head-cell": PTableHeadCell;
        "p-table-head-row": PTableHeadRow;
        "p-table-row": PTableRow;
        "p-tabs": PTabs;
        "p-tabs-bar": PTabsBar;
        "p-tabs-item": PTabsItem;
        "p-text": PText;
        "p-text-field-wrapper": PTextFieldWrapper;
        "p-text-list": PTextList;
        "p-text-list-item": PTextListItem;
        "p-textarea-wrapper": PTextareaWrapper;
        "p-toast": PToast;
        "p-toast-item": PToastItem;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "p-accordion": LocalJSX.PAccordion & JSXBase.HTMLAttributes<HTMLPAccordionElement>;
            "p-banner": LocalJSX.PBanner & JSXBase.HTMLAttributes<HTMLPBannerElement>;
            "p-button": LocalJSX.PButton & JSXBase.HTMLAttributes<HTMLPButtonElement>;
            "p-button-group": LocalJSX.PButtonGroup & JSXBase.HTMLAttributes<HTMLPButtonGroupElement>;
            "p-button-pure": LocalJSX.PButtonPure & JSXBase.HTMLAttributes<HTMLPButtonPureElement>;
            "p-checkbox-wrapper": LocalJSX.PCheckboxWrapper & JSXBase.HTMLAttributes<HTMLPCheckboxWrapperElement>;
            "p-content-wrapper": LocalJSX.PContentWrapper & JSXBase.HTMLAttributes<HTMLPContentWrapperElement>;
            "p-divider": LocalJSX.PDivider & JSXBase.HTMLAttributes<HTMLPDividerElement>;
            "p-fieldset-wrapper": LocalJSX.PFieldsetWrapper & JSXBase.HTMLAttributes<HTMLPFieldsetWrapperElement>;
            "p-flex": LocalJSX.PFlex & JSXBase.HTMLAttributes<HTMLPFlexElement>;
            "p-flex-item": LocalJSX.PFlexItem & JSXBase.HTMLAttributes<HTMLPFlexItemElement>;
            "p-grid": LocalJSX.PGrid & JSXBase.HTMLAttributes<HTMLPGridElement>;
            "p-grid-item": LocalJSX.PGridItem & JSXBase.HTMLAttributes<HTMLPGridItemElement>;
            "p-headline": LocalJSX.PHeadline & JSXBase.HTMLAttributes<HTMLPHeadlineElement>;
            "p-icon": LocalJSX.PIcon & JSXBase.HTMLAttributes<HTMLPIconElement>;
            "p-inline-notification": LocalJSX.PInlineNotification & JSXBase.HTMLAttributes<HTMLPInlineNotificationElement>;
            "p-link": LocalJSX.PLink & JSXBase.HTMLAttributes<HTMLPLinkElement>;
            "p-link-pure": LocalJSX.PLinkPure & JSXBase.HTMLAttributes<HTMLPLinkPureElement>;
            "p-link-social": LocalJSX.PLinkSocial & JSXBase.HTMLAttributes<HTMLPLinkSocialElement>;
            "p-marque": LocalJSX.PMarque & JSXBase.HTMLAttributes<HTMLPMarqueElement>;
            "p-modal": LocalJSX.PModal & JSXBase.HTMLAttributes<HTMLPModalElement>;
            "p-pagination": LocalJSX.PPagination & JSXBase.HTMLAttributes<HTMLPPaginationElement>;
            "p-popover": LocalJSX.PPopover & JSXBase.HTMLAttributes<HTMLPPopoverElement>;
            "p-radio-button-wrapper": LocalJSX.PRadioButtonWrapper & JSXBase.HTMLAttributes<HTMLPRadioButtonWrapperElement>;
            "p-select-wrapper": LocalJSX.PSelectWrapper & JSXBase.HTMLAttributes<HTMLPSelectWrapperElement>;
            "p-select-wrapper-dropdown": LocalJSX.PSelectWrapperDropdown & JSXBase.HTMLAttributes<HTMLPSelectWrapperDropdownElement>;
            "p-spinner": LocalJSX.PSpinner & JSXBase.HTMLAttributes<HTMLPSpinnerElement>;
            "p-switch": LocalJSX.PSwitch & JSXBase.HTMLAttributes<HTMLPSwitchElement>;
            "p-table": LocalJSX.PTable & JSXBase.HTMLAttributes<HTMLPTableElement>;
            "p-table-body": LocalJSX.PTableBody & JSXBase.HTMLAttributes<HTMLPTableBodyElement>;
            "p-table-cell": LocalJSX.PTableCell & JSXBase.HTMLAttributes<HTMLPTableCellElement>;
            "p-table-head": LocalJSX.PTableHead & JSXBase.HTMLAttributes<HTMLPTableHeadElement>;
            "p-table-head-cell": LocalJSX.PTableHeadCell & JSXBase.HTMLAttributes<HTMLPTableHeadCellElement>;
            "p-table-head-row": LocalJSX.PTableHeadRow & JSXBase.HTMLAttributes<HTMLPTableHeadRowElement>;
            "p-table-row": LocalJSX.PTableRow & JSXBase.HTMLAttributes<HTMLPTableRowElement>;
            "p-tabs": LocalJSX.PTabs & JSXBase.HTMLAttributes<HTMLPTabsElement>;
            "p-tabs-bar": LocalJSX.PTabsBar & JSXBase.HTMLAttributes<HTMLPTabsBarElement>;
            "p-tabs-item": LocalJSX.PTabsItem & JSXBase.HTMLAttributes<HTMLPTabsItemElement>;
            "p-text": LocalJSX.PText & JSXBase.HTMLAttributes<HTMLPTextElement>;
            "p-text-field-wrapper": LocalJSX.PTextFieldWrapper & JSXBase.HTMLAttributes<HTMLPTextFieldWrapperElement>;
            "p-text-list": LocalJSX.PTextList & JSXBase.HTMLAttributes<HTMLPTextListElement>;
            "p-text-list-item": LocalJSX.PTextListItem & JSXBase.HTMLAttributes<HTMLPTextListItemElement>;
            "p-textarea-wrapper": LocalJSX.PTextareaWrapper & JSXBase.HTMLAttributes<HTMLPTextareaWrapperElement>;
            "p-toast": LocalJSX.PToast & JSXBase.HTMLAttributes<HTMLPToastElement>;
            "p-toast-item": LocalJSX.PToastItem & JSXBase.HTMLAttributes<HTMLPToastItemElement>;
        }
    }
}
