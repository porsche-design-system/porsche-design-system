/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { BreakpointCustomizable, ButtonAriaAttribute, ButtonType, ButtonVariant, HeadingSize, IconName, LinkAriaAttribute, LinkTarget, LinkVariant, SelectedAriaAttributes, TextSize, Theme } from "./types";
import { AccordionSize, AccordionTag, AccordionUpdateEventDetail } from "./components/accordion/accordion-utils";
import { BannerState, BannerWidth } from "./components/banner/banner-utils";
import { ButtonIcon } from "./components/button/button-utils";
import { ButtonGroupDirection } from "./components/button-group/button-group-utils";
import { ButtonPureAlignLabel, ButtonPureAriaAttribute, ButtonPureIcon, ButtonPureSize, ButtonPureType, ButtonPureWeight } from "./components/button-pure/button-pure-utils";
import { ButtonTileAlign, ButtonTileAriaAttribute, ButtonTileAspectRatio, ButtonTileBackground, ButtonTileIcon, ButtonTileSize, ButtonTileType, ButtonTileWeight } from "./components/button-tile/button-tile-utils";
import { CarouselAlignHeader, CarouselAriaAttribute, CarouselHeadingSize, CarouselInternationalization, CarouselUpdateEventDetail, CarouselWidth } from "./components/carousel/carousel-utils";
import { CheckboxWrapperState } from "./components/checkbox-wrapper/checkbox-wrapper-utils";
import { ContentWrapperBackgroundColor, ContentWrapperWidth } from "./components/content-wrapper/content-wrapper-utils";
import { CrestAriaAttribute, CrestTarget } from "./components/crest/crest-utils";
import { DisplayAlign, DisplayColor, DisplaySize, DisplayTag } from "./components/display/display-utils";
import { DividerColor, DividerDirection, DividerOrientation } from "./components/divider/divider-utils";
import { FieldsetLabelSize, FieldsetState } from "./components/fieldset/fieldset-utils";
import { FieldsetWrapperLabelSize, FieldsetWrapperState } from "./components/fieldset-wrapper/fieldset-wrapper-utils";
import { FlexAlignContent, FlexAlignItems, FlexDirection, FlexInline, FlexJustifyContent, FlexWrap } from "./components/flex/flex/flex-utils";
import { FlexItemAlignSelf, FlexItemFlex, FlexItemGrow, FlexItemOffset, FlexItemShrink, FlexItemWidth } from "./components/flex/flex-item/flex-item-utils";
import { FlyoutAriaAttribute, FlyoutPosition } from "./components/flyout/flyout-utils";
import { FlyoutNavigationAriaAttribute, FlyoutNavigationUpdateEventDetail } from "./components/flyout-navigation/flyout-navigation/flyout-navigation-utils";
import { GridDirection, GridGutter, GridWrap } from "./components/grid/grid/grid-utils";
import { GridItemOffset, GridItemSize } from "./components/grid/grid-item/grid-item-utils";
import { HeadingTag } from "./components/heading/heading-tag";
import { HeadingAlign, HeadingColor } from "./components/heading/heading-utils";
import { HeadlineAlign, HeadlineColor, HeadlineTag, HeadlineVariant } from "./components/headline/headline-utils";
import { IconAriaAttribute, IconColor, IconSize } from "./components/icon/icon-utils";
import { InlineNotificationActionIcon, InlineNotificationState } from "./components/inline-notification/inline-notification-utils";
import { LinkIcon } from "./components/link/link-utils";
import { LinkPureAlignLabel, LinkPureAriaAttribute, LinkPureIcon, LinkPureSize, LinkPureTarget, LinkPureWeight } from "./components/link-pure/link-pure-utils";
import { LinkSocialIcon, LinkSocialTarget } from "./components/link-social/link-social-utils";
import { LinkTileAlign, LinkTileAriaAttribute, LinkTileAspectRatio, LinkTileBackground, LinkTileSize, LinkTileTarget, LinkTileWeight } from "./components/link-tile/link-tile-utils";
import { LinkTileModelSignatureAspectRatio, LinkTileModelSignatureHeadingTag, LinkTileModelSignatureLinkDirection, LinkTileModelSignatureModel, LinkTileModelSignatureWeight } from "./components/link-tile-model-signature/link-tile-model-signature-utils";
import { LinkTileProductAspectRatio, LinkTileProductLikeEventDetail, LinkTileProductTarget } from "./components/link-tile-product/link-tile-product-utils";
import { MarqueAriaAttribute, MarqueTarget, MarqueVariant } from "./components/marque/marque-utils";
import { MarqueSize } from "./components/marque/marque-size";
import { ModalAriaAttribute } from "./components/modal/modal-utils";
import { ModelSignatureColor, ModelSignatureModel, ModelSignatureSize } from "./components/model-signature/model-signature-utils";
import { MultiSelectDropdownDirection, MultiSelectState, MultiSelectUpdateEventDetail } from "./components/multi-select/multi-select/multi-select-utils";
import { PaginationInternationalization, PaginationMaxNumberOfPageLinks, PaginationUpdateEventDetail } from "./components/pagination/pagination-utils";
import { PinCodeLength, PinCodeState, PinCodeType, PinCodeUpdateEventDetail } from "./components/pin-code/pin-code-utils";
import { PopoverAriaAttribute, PopoverDirection } from "./components/popover/popover-utils";
import { RadioButtonWrapperState } from "./components/radio-button-wrapper/radio-button-wrapper-utils";
import { ScrollerAlignScrollIndicator, ScrollerAriaAttribute, ScrollerGradientColor, ScrollerGradientColorScheme, ScrollerScrollIndicatorPosition, ScrollerScrollToPosition } from "./components/scroller/scroller-utils";
import { SegmentedControlBackgroundColor, SegmentedControlColumns, SegmentedControlUpdateEventDetail } from "./components/segmented-control/segmented-control/segmented-control-utils";
import { SegmentedControlItemIcon } from "./components/segmented-control/segmented-control-item/segmented-control-item-utils";
import { SelectWrapperDropdownDirection, SelectWrapperState } from "./components/select-wrapper/select-wrapper/select-wrapper-utils";
import { SpinnerAriaAttribute, SpinnerSize } from "./components/spinner/spinner-utils";
import { StepperHorizontalSize, StepperHorizontalUpdateEventDetail } from "./components/stepper-horizontal/stepper-horizontal/stepper-horizontal-utils";
import { StepperHorizontalItemState } from "./components/stepper-horizontal/stepper-horizontal-item/stepper-horizontal-item-utils";
import { SwitchAlignLabel, SwitchUpdateEventDetail } from "./components/switch/switch-utils";
import { TableHeadCellSort, TableUpdateEventDetail } from "./components/table/table/table-utils";
import { TabsGradientColor, TabsGradientColorScheme, TabsSize, TabsUpdateEventDetail, TabsWeight } from "./components/tabs/tabs/tabs-utils";
import { TabsBarGradientColor, TabsBarGradientColorScheme, TabsBarSize, TabsBarUpdateEventDetail, TabsBarWeight } from "./components/tabs-bar/tabs-bar-utils";
import { TagColor, TagIcon } from "./components/tag/tag-utils";
import { TagDismissibleAriaAttribute, TagDismissibleColor } from "./components/tag-dismissible/tag-dismissible-utils";
import { TextAlign, TextColor, TextTag, TextWeight } from "./components/text/text-utils";
import { TextFieldWrapperActionIcon, TextFieldWrapperState, TextFieldWrapperUnitPosition } from "./components/text-field-wrapper/text-field-wrapper-utils";
import { TextListListType, TextListOrderType, TextListType } from "./components/text-list/text-list/text-list-utils";
import { TextareaWrapperState } from "./components/textarea-wrapper/textarea-wrapper-utils";
import { ToastMessage } from "./components/toast/toast/toast-manager";
import { ToastState } from "./components/toast/toast/toast-utils";
import { WordmarkAriaAttribute, WordmarkSize, WordmarkTarget } from "./components/wordmark/wordmark-utils";
export { BreakpointCustomizable, ButtonAriaAttribute, ButtonType, ButtonVariant, HeadingSize, IconName, LinkAriaAttribute, LinkTarget, LinkVariant, SelectedAriaAttributes, TextSize, Theme } from "./types";
export { AccordionSize, AccordionTag, AccordionUpdateEventDetail } from "./components/accordion/accordion-utils";
export { BannerState, BannerWidth } from "./components/banner/banner-utils";
export { ButtonIcon } from "./components/button/button-utils";
export { ButtonGroupDirection } from "./components/button-group/button-group-utils";
export { ButtonPureAlignLabel, ButtonPureAriaAttribute, ButtonPureIcon, ButtonPureSize, ButtonPureType, ButtonPureWeight } from "./components/button-pure/button-pure-utils";
export { ButtonTileAlign, ButtonTileAriaAttribute, ButtonTileAspectRatio, ButtonTileBackground, ButtonTileIcon, ButtonTileSize, ButtonTileType, ButtonTileWeight } from "./components/button-tile/button-tile-utils";
export { CarouselAlignHeader, CarouselAriaAttribute, CarouselHeadingSize, CarouselInternationalization, CarouselUpdateEventDetail, CarouselWidth } from "./components/carousel/carousel-utils";
export { CheckboxWrapperState } from "./components/checkbox-wrapper/checkbox-wrapper-utils";
export { ContentWrapperBackgroundColor, ContentWrapperWidth } from "./components/content-wrapper/content-wrapper-utils";
export { CrestAriaAttribute, CrestTarget } from "./components/crest/crest-utils";
export { DisplayAlign, DisplayColor, DisplaySize, DisplayTag } from "./components/display/display-utils";
export { DividerColor, DividerDirection, DividerOrientation } from "./components/divider/divider-utils";
export { FieldsetLabelSize, FieldsetState } from "./components/fieldset/fieldset-utils";
export { FieldsetWrapperLabelSize, FieldsetWrapperState } from "./components/fieldset-wrapper/fieldset-wrapper-utils";
export { FlexAlignContent, FlexAlignItems, FlexDirection, FlexInline, FlexJustifyContent, FlexWrap } from "./components/flex/flex/flex-utils";
export { FlexItemAlignSelf, FlexItemFlex, FlexItemGrow, FlexItemOffset, FlexItemShrink, FlexItemWidth } from "./components/flex/flex-item/flex-item-utils";
export { FlyoutAriaAttribute, FlyoutPosition } from "./components/flyout/flyout-utils";
export { FlyoutNavigationAriaAttribute, FlyoutNavigationUpdateEventDetail } from "./components/flyout-navigation/flyout-navigation/flyout-navigation-utils";
export { GridDirection, GridGutter, GridWrap } from "./components/grid/grid/grid-utils";
export { GridItemOffset, GridItemSize } from "./components/grid/grid-item/grid-item-utils";
export { HeadingTag } from "./components/heading/heading-tag";
export { HeadingAlign, HeadingColor } from "./components/heading/heading-utils";
export { HeadlineAlign, HeadlineColor, HeadlineTag, HeadlineVariant } from "./components/headline/headline-utils";
export { IconAriaAttribute, IconColor, IconSize } from "./components/icon/icon-utils";
export { InlineNotificationActionIcon, InlineNotificationState } from "./components/inline-notification/inline-notification-utils";
export { LinkIcon } from "./components/link/link-utils";
export { LinkPureAlignLabel, LinkPureAriaAttribute, LinkPureIcon, LinkPureSize, LinkPureTarget, LinkPureWeight } from "./components/link-pure/link-pure-utils";
export { LinkSocialIcon, LinkSocialTarget } from "./components/link-social/link-social-utils";
export { LinkTileAlign, LinkTileAriaAttribute, LinkTileAspectRatio, LinkTileBackground, LinkTileSize, LinkTileTarget, LinkTileWeight } from "./components/link-tile/link-tile-utils";
export { LinkTileModelSignatureAspectRatio, LinkTileModelSignatureHeadingTag, LinkTileModelSignatureLinkDirection, LinkTileModelSignatureModel, LinkTileModelSignatureWeight } from "./components/link-tile-model-signature/link-tile-model-signature-utils";
export { LinkTileProductAspectRatio, LinkTileProductLikeEventDetail, LinkTileProductTarget } from "./components/link-tile-product/link-tile-product-utils";
export { MarqueAriaAttribute, MarqueTarget, MarqueVariant } from "./components/marque/marque-utils";
export { MarqueSize } from "./components/marque/marque-size";
export { ModalAriaAttribute } from "./components/modal/modal-utils";
export { ModelSignatureColor, ModelSignatureModel, ModelSignatureSize } from "./components/model-signature/model-signature-utils";
export { MultiSelectDropdownDirection, MultiSelectState, MultiSelectUpdateEventDetail } from "./components/multi-select/multi-select/multi-select-utils";
export { PaginationInternationalization, PaginationMaxNumberOfPageLinks, PaginationUpdateEventDetail } from "./components/pagination/pagination-utils";
export { PinCodeLength, PinCodeState, PinCodeType, PinCodeUpdateEventDetail } from "./components/pin-code/pin-code-utils";
export { PopoverAriaAttribute, PopoverDirection } from "./components/popover/popover-utils";
export { RadioButtonWrapperState } from "./components/radio-button-wrapper/radio-button-wrapper-utils";
export { ScrollerAlignScrollIndicator, ScrollerAriaAttribute, ScrollerGradientColor, ScrollerGradientColorScheme, ScrollerScrollIndicatorPosition, ScrollerScrollToPosition } from "./components/scroller/scroller-utils";
export { SegmentedControlBackgroundColor, SegmentedControlColumns, SegmentedControlUpdateEventDetail } from "./components/segmented-control/segmented-control/segmented-control-utils";
export { SegmentedControlItemIcon } from "./components/segmented-control/segmented-control-item/segmented-control-item-utils";
export { SelectWrapperDropdownDirection, SelectWrapperState } from "./components/select-wrapper/select-wrapper/select-wrapper-utils";
export { SpinnerAriaAttribute, SpinnerSize } from "./components/spinner/spinner-utils";
export { StepperHorizontalSize, StepperHorizontalUpdateEventDetail } from "./components/stepper-horizontal/stepper-horizontal/stepper-horizontal-utils";
export { StepperHorizontalItemState } from "./components/stepper-horizontal/stepper-horizontal-item/stepper-horizontal-item-utils";
export { SwitchAlignLabel, SwitchUpdateEventDetail } from "./components/switch/switch-utils";
export { TableHeadCellSort, TableUpdateEventDetail } from "./components/table/table/table-utils";
export { TabsGradientColor, TabsGradientColorScheme, TabsSize, TabsUpdateEventDetail, TabsWeight } from "./components/tabs/tabs/tabs-utils";
export { TabsBarGradientColor, TabsBarGradientColorScheme, TabsBarSize, TabsBarUpdateEventDetail, TabsBarWeight } from "./components/tabs-bar/tabs-bar-utils";
export { TagColor, TagIcon } from "./components/tag/tag-utils";
export { TagDismissibleAriaAttribute, TagDismissibleColor } from "./components/tag-dismissible/tag-dismissible-utils";
export { TextAlign, TextColor, TextTag, TextWeight } from "./components/text/text-utils";
export { TextFieldWrapperActionIcon, TextFieldWrapperState, TextFieldWrapperUnitPosition } from "./components/text-field-wrapper/text-field-wrapper-utils";
export { TextListListType, TextListOrderType, TextListType } from "./components/text-list/text-list/text-list-utils";
export { TextareaWrapperState } from "./components/textarea-wrapper/textarea-wrapper-utils";
export { ToastMessage } from "./components/toast/toast/toast-manager";
export { ToastState } from "./components/toast/toast/toast-utils";
export { WordmarkAriaAttribute, WordmarkSize, WordmarkTarget } from "./components/wordmark/wordmark-utils";
export namespace Components {
    interface PAccordion {
        /**
          * Displays the Accordion as compact version with thinner border and smaller paddings.
         */
        "compact"?: boolean;
        /**
          * Defines the heading used in accordion.
         */
        "heading"?: string;
        /**
          * Defines if accordion is open.
         */
        "open"?: boolean;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<AccordionSize>;
        /**
          * Sets a headline tag, so it fits correctly within the outline of the page.
         */
        "tag"?: AccordionTag;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PBanner {
        /**
          * Description of the banner.
         */
        "description"?: string;
        /**
          * If false, the banner will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the banner.
         */
        "heading"?: string;
        /**
          * If true, the banner is open.
         */
        "open": boolean;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `dismissButton` instead. Defines if the banner can be closed/removed by the user.
         */
        "persistent"?: boolean;
        /**
          * State of the banner.
         */
        "state"?: BannerState;
        /**
          * Adapts the banner color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "width"?: BannerWidth;
    }
    interface PButton {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: ButtonIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * The name of the button, submitted as a pair with the button's value as part of the form data, when that button is used to submit the form.
         */
        "name"?: string;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonType;
        /**
          * Defines the value associated with the button's name when it's submitted with the form data. This value is passed to the server in params when the form is submitted using this button.
         */
        "value"?: string;
        /**
          * The style variant of the button.
         */
        "variant"?: ButtonVariant;
    }
    interface PButtonGroup {
        /**
          * Defines the direction of the main and cross axis. The default is ’{base: ‘column’, xs: ‘row’}' showing buttons vertically stacked on mobile viewports and side-by-side in a horizontal row from breakpoint ‘xs’. You always need to provide a base value when using breakpoints.
         */
        "direction"?: BreakpointCustomizable<ButtonGroupDirection>;
    }
    interface PButtonPure {
        /**
          * Display button in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<ButtonPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonPureAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown.
         */
        "icon"?: ButtonPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * The name of the button, submitted as a pair with the button's value as part of the form data, when that button is used to submit the form.
         */
        "name"?: string;
        /**
          * Size of the button.
         */
        "size"?: BreakpointCustomizable<ButtonPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonPureType;
        /**
          * Defines the value associated with the button's name when it's submitted with the form data. This value is passed to the server in params when the form is submitted using this button.
         */
        "value"?: string;
        /**
          * The weight of the text (only has effect with visible label).
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "weight"?: ButtonPureWeight;
    }
    interface PButtonTile {
        /**
          * Alignment of button and description.
         */
        "align"?: ButtonTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonTileAriaAttribute>;
        /**
          * Aspect ratio of the button-tile.
         */
        "aspectRatio"?: BreakpointCustomizable<ButtonTileAspectRatio>;
        /**
          * Adapts the description and button theme when used on light background image.
         */
        "background"?: ButtonTileBackground;
        /**
          * Displays the button-tile as compact version with description and button icon only.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description": string;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show gradient.
         */
        "gradient"?: boolean;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: ButtonTileIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Label of the button.
         */
        "label": string;
        /**
          * Disables the button-tile and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Font size of the description.
         */
        "size"?: BreakpointCustomizable<ButtonTileSize>;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonTileType;
        /**
          * Font weight of the description.
         */
        "weight"?: BreakpointCustomizable<ButtonTileWeight>;
    }
    interface PCarousel {
        /**
          * Defines which slide to be active (zero-based numbering).
         */
        "activeSlideIndex"?: number;
        /**
          * Alignment of heading and description
         */
        "alignHeader"?: CarouselAlignHeader;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<CarouselAriaAttribute>;
        /**
          * Defines the description used in the carousel.
         */
        "description"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `pagination` instead. If true, the carousel will not show pagination bullets at the bottom.
         */
        "disablePagination"?: BreakpointCustomizable<boolean>;
        /**
          * Defines the heading used in the carousel.
         */
        "heading"?: string;
        /**
          * Defines the heading size used in the carousel.
         */
        "headingSize"?: CarouselHeadingSize;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev buttons and pagination.
         */
        "intl"?: CarouselInternationalization;
        /**
          * If false, the carousel will not show pagination bullets at the bottom.
         */
        "pagination"?: BreakpointCustomizable<boolean>;
        /**
          * Whether the slides should rewind from last to first slide and vice versa.
         */
        "rewind"?: boolean;
        /**
          * Defines target of skip link (to skip carousel entries).
         */
        "skipLinkTarget"?: string;
        /**
          * Sets the amount of slides visible at the same time. Can be set to `auto` if you want to define different widths per slide via CSS.
         */
        "slidesPerPage"?: BreakpointCustomizable<number> | 'auto';
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * Defines the outer spacings between the carousel and the left and right screen sides.
         */
        "width"?: CarouselWidth;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "wrapContent"?: boolean;
    }
    interface PCheckboxWrapper {
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * @experimental Disables the checkbox and shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: CheckboxWrapperState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface PContentWrapper {
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "backgroundColor"?: ContentWrapperBackgroundColor;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "theme"?: Theme;
        /**
          * Defines the outer spacings between the content area and the left and right screen sides, as well as centering its content and setting a max-width.
         */
        "width"?: ContentWrapperWidth;
    }
    interface PCrest {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<CrestAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: CrestTarget;
    }
    interface PDisplay {
        /**
          * Text alignment of the component.
         */
        "align"?: DisplayAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: DisplayColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "medium", l: "large"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<DisplaySize>;
        /**
          * Sets a custom HTML tag depending on the usage of the display component.
         */
        "tag"?: DisplayTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
    }
    interface PDivider {
        /**
          * Defines color depending on theme.
         */
        "color"?: DividerColor;
        /**
          * Defines direction.
         */
        "direction"?: BreakpointCustomizable<DividerDirection>;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `direction` instead. Defines orientation.
         */
        "orientation"?: BreakpointCustomizable<DividerOrientation>;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    interface PFieldset {
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The size of the label text.
         */
        "labelSize"?: FieldsetLabelSize;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Marks the Fieldset as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: FieldsetState;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-fieldset" instead.
     */
    interface PFieldsetWrapper {
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The size of the label text.
         */
        "labelSize"?: FieldsetWrapperLabelSize;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Marks the Fieldset as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: FieldsetWrapperState;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
     */
    interface PFlex {
        /**
          * This aligns a flex container's individual lines when there is extra space in the cross-axis, similar to how "justifyContent" aligns individual items along the main axis.
         */
        "alignContent"?: BreakpointCustomizable<FlexAlignContent>;
        /**
          * Defines how the flex items are aligned along the cross axis.
         */
        "alignItems"?: BreakpointCustomizable<FlexAlignItems>;
        /**
          * Defines the direction of the main and cross axis. The default "row" defines the main axis as horizontal left to right.
         */
        "direction"?: BreakpointCustomizable<FlexDirection>;
        /**
          * Defines the flex containers content flow if 2 or more containers are siblings of each other.
         */
        "inline"?: BreakpointCustomizable<FlexInline>;
        /**
          * Defines how the flex items are aligned along the main axis.
         */
        "justifyContent"?: BreakpointCustomizable<FlexJustifyContent>;
        /**
          * Handles wrapping behaviour of elements.
         */
        "wrap"?: BreakpointCustomizable<FlexWrap>;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
     */
    interface PFlexItem {
        /**
          * Defines how this flex item is aligned along the cross axis. This overwrites the cross axis alignment set by the container. Corresponds to the "alignSelf" css property.
         */
        "alignSelf"?: BreakpointCustomizable<FlexItemAlignSelf>;
        /**
          * The shorthand property for the combined definition of "shrink", "grow" and "basis"
         */
        "flex"?: BreakpointCustomizable<FlexItemFlex>;
        /**
          * The ability to allow/disallow the flex child to grow.
         */
        "grow"?: BreakpointCustomizable<FlexItemGrow>;
        /**
          * The offset of the column. You can also supply values for specific breakpoints, like {base: "none", l: "one-quarter"}. You always need to provide a base value when doing this.
         */
        "offset"?: BreakpointCustomizable<FlexItemOffset>;
        /**
          * The ability to allow/disallow the flex child to shrink.
         */
        "shrink"?: BreakpointCustomizable<FlexItemShrink>;
        /**
          * The width of the flex item. You can also supply values for specific breakpoints, like {base: "full", l: "one-quarter"}. You always need to provide a base value when doing this.
         */
        "width"?: BreakpointCustomizable<FlexItemWidth>;
    }
    interface PFlyout {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<FlyoutAriaAttribute>;
        /**
          * If true, the flyout is open.
         */
        "open": boolean;
        /**
          * The position of the flyout
         */
        "position"?: FlyoutPosition;
        /**
          * Adapts the flyout color depending on the theme.
         */
        "theme"?: Theme;
    }
    /**
     * @experimental 
     */
    interface PFlyoutNavigation {
        /**
          * Defines which flyout-navigation-item to be visualized as opened.
         */
        "activeIdentifier"?: string | undefined;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<FlyoutNavigationAriaAttribute>;
        /**
          * If true, the flyout-navigation is visualized as opened.
         */
        "open"?: boolean;
        /**
          * Adapts the flyout-navigation color depending on the theme.
         */
        "theme"?: Theme;
    }
    /**
     * @experimental 
     */
    interface PFlyoutNavigationItem {
        /**
          * Unique identifier which controls if this item should be shown when the active-identifier on the flyout-navigation is set to this value.
         */
        "identifier": string;
        /**
          * Label of the item.
         */
        "label"?: string;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface PGrid {
        /**
          * Defines the direction of the main and cross axis. The default "row" defines the main axis as horizontal left to right. Also defines the direction for specific breakpoints, like {base: "column", l: "row"}. You always need to provide a base value when doing this.
         */
        "direction"?: BreakpointCustomizable<GridDirection>;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "gutter"?: BreakpointCustomizable<GridGutter>;
        /**
          * Handles wrapping behaviour of elements.
         */
        "wrap"?: BreakpointCustomizable<GridWrap>;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface PGridItem {
        /**
          * The offset of the column. Can be between 0 and 11. Also defines the offset of the column for specific breakpoints, like {base: 6, l: 3}. You always need to provide a base value when doing this.
         */
        "offset"?: BreakpointCustomizable<GridItemOffset>;
        /**
          * The size of the column. Can be between 1 and 12. Also defines the size of the column for specific breakpoints, like {base: 6, l: 3}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<GridItemSize>;
    }
    interface PHeading {
        /**
          * Text alignment of the component.
         */
        "align"?: HeadingAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: HeadingColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<HeadingSize>;
        /**
          * Sets a custom HTML tag depending on the usage of the heading component.
         */
        "tag"?: HeadingTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-heading" instead.
     */
    interface PHeadline {
        /**
          * Text alignment of the component.
         */
        "align"?: HeadlineAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: HeadlineColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Sets a custom HTML tag depending on the usage of the headline component.
         */
        "tag"?: HeadlineTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
        /**
          * Predefined style of the headline.
         */
        "variant"?: HeadlineVariant;
    }
    interface PIcon {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<IconAriaAttribute>;
        /**
          * Basic color variations depending on theme property.
         */
        "color"?: IconColor;
        /**
          * Has no effect anymore (the component is now using the native `loading="lazy"` attribute by default)
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "lazy"?: boolean;
        /**
          * Specifies which icon to use.
         */
        "name"?: IconName;
        /**
          * The size of the icon.
         */
        "size"?: IconSize;
        /**
          * Specifies a whole icon path which can be used for custom icons.
         */
        "source"?: string;
        /**
          * Adapts the color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
    }
    interface PInlineNotification {
        /**
          * Action icon of the inline-notification.
         */
        "actionIcon"?: InlineNotificationActionIcon;
        /**
          * Action label of the inline-notification.
         */
        "actionLabel"?: string;
        /**
          * Disables the action button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "actionLoading"?: boolean;
        /**
          * Description of the inline-notification.
         */
        "description"?: string;
        /**
          * If false, the inline-notification will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the inline-notification.
         */
        "heading"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `dismissButton` instead. Defines if the inline-notification can be closed/removed by the user.
         */
        "persistent"?: boolean;
        /**
          * State of the inline-notification.
         */
        "state"?: InlineNotificationState;
        /**
          * Adapts the inline-notification color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PLink {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: LinkIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTarget;
        /**
          * Adapts the link color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The style variant of the link.
         */
        "variant"?: LinkVariant;
    }
    interface PLinkPure {
        /**
          * Display link in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<LinkPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkPureAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed
         */
        "icon"?: LinkPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Size of the link.
         */
        "size"?: BreakpointCustomizable<LinkPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkPureTarget;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Shows an underline under the label.
         */
        "underline"?: boolean;
        /**
          * The weight of the text (only has effect with visible label).
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "weight"?: LinkPureWeight;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use `p-link` with corresponding social icon instead.
     */
    interface PLinkSocial {
        /**
          * Show or hide label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown.
         */
        "icon"?: LinkSocialIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkSocialTarget;
        /**
          * Adapts the link color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PLinkTile {
        /**
          * Alignment of link and description.
         */
        "align"?: LinkTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkTileAriaAttribute>;
        /**
          * Aspect ratio of the link-tile.
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileAspectRatio>;
        /**
          * Adapts the description and link theme when used on light background image.
         */
        "background"?: LinkTileBackground;
        /**
          * Displays the link-tile as compact version with description and link icon only.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description": string;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show gradient.
         */
        "gradient"?: boolean;
        /**
          * href of the `<a>`.
         */
        "href": string;
        /**
          * Label of the <a />.
         */
        "label": string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Font size of the description.
         */
        "size"?: BreakpointCustomizable<LinkTileSize>;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTileTarget;
        /**
          * Font weight of the description.
         */
        "weight"?: BreakpointCustomizable<LinkTileWeight>;
    }
    interface PLinkTileModelSignature {
        /**
          * Aspect ratio of the link-tile-model-signature.
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileModelSignatureAspectRatio>;
        /**
          * Description text.
         */
        "description"?: string;
        /**
          * Heading text.
         */
        "heading": string;
        /**
          * Sets a custom headline tag which wraps the heading to enhance semantics.
         */
        "headingTag"?: LinkTileModelSignatureHeadingTag;
        /**
          * Defines the direction of the main and cross axis of the links. The default is '{base: ‘column’, xs: ‘row’}' showing buttons vertically stacked on mobile viewports and side-by-side in a horizontal row from breakpoint 'xs'.
         */
        "linkDirection"?: BreakpointCustomizable<LinkTileModelSignatureLinkDirection>;
        /**
          * Adapts the model of the component.
         */
        "model"?: LinkTileModelSignatureModel;
        /**
          * Adapts the font weight of the heading.
         */
        "weight"?: BreakpointCustomizable<LinkTileModelSignatureWeight>;
    }
    /**
     * @experimental 
     */
    interface PLinkTileProduct {
        /**
          * Aspect ratio of the link-tile-product.
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileProductAspectRatio>;
        /**
          * Additional product description
         */
        "description"?: string;
        /**
          * Product heading
         */
        "heading": string;
        /**
          * href of the `<a>`.
         */
        "href"?: string;
        /**
          * A Boolean attribute indicating that a like button should be shown.
         */
        "likeButton"?: boolean;
        /**
          * A Boolean attribute indicating that a product is liked.
         */
        "liked"?: boolean;
        /**
          * Product price
         */
        "price": string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTileProductTarget;
        /**
          * Adapts the link-tile-product color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PLoadingBaseComponent {
        "loading": boolean;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-wordmark" instead.
     */
    interface PMarque {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<MarqueAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Adapts sizing of marque.
         */
        "size"?: MarqueSize;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: MarqueTarget;
        /**
          * Show/hide trademark sign (only has effect when variant is set to default).
         */
        "trademark"?: boolean;
        /**
          * Shows marque in special editions
         */
        "variant"?: MarqueVariant;
    }
    interface PModal {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ModalAriaAttribute>;
        /**
          * If true, the modal will not be closable via backdrop click.
         */
        "disableBackdropClick"?: boolean;
        /**
          * If true, the modal will not have a dismiss button.
          * @deprecated since v3.0.0, will be removed with next major release, use `dismissButton` instead.
         */
        "disableCloseButton"?: boolean;
        /**
          * If false, the modal will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * If true the modal uses max viewport height and width. Should only be used for mobile.
         */
        "fullscreen"?: BreakpointCustomizable<boolean>;
        /**
          * The title of the modal
         */
        "heading"?: string;
        /**
          * If true, the modal is open.
         */
        "open": boolean;
        /**
          * Adapts the modal color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PModelSignature {
        /**
          * Adapts the color of the component.
         */
        "color"?: ModelSignatureColor;
        /**
          * Adapts the model of the component.
         */
        "model"?: ModelSignatureModel;
        /**
          * Adapts the size of the component.
         */
        "size"?: ModelSignatureSize;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    interface PMultiSelect {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Disables the multi-select
         */
        "disabled"?: boolean;
        /**
          * Changes the direction to which the dropdown list appears.
         */
        "dropdownDirection"?: MultiSelectDropdownDirection;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The name of the control.
         */
        "name": string;
        /**
          * A Boolean attribute indicating that an option with a non-empty string value must be selected.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: MultiSelectState;
        /**
          * Adapts the select color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * The selected values.
         */
        "value"?: string[];
    }
    interface PMultiSelectOption {
        /**
          * Disables the option.
         */
        "disabled"?: boolean;
        /**
          * The option value.
         */
        "value": string;
    }
    interface PPagination {
        /**
          * Index of the currently active page.
         */
        "activePage"?: number;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.root` instead. Aria label what the pagination is used for.
         */
        "allyLabel"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.next` instead. Aria label for next page icon.
         */
        "allyLabelNext"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.page` instead. Aria label for page navigation.
         */
        "allyLabelPage"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.prev` instead. Aria label for previous page icon.
         */
        "allyLabelPrev"?: string;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev and page buttons.
         */
        "intl"?: PaginationInternationalization;
        /**
          * The total count of items which should be shown per page.
         */
        "itemsPerPage": number;
        /**
          * Has no effect anymore
          * @deprecated since v3.10.0, will be removed with next major release
         */
        "maxNumberOfPageLinks"?: BreakpointCustomizable<PaginationMaxNumberOfPageLinks>;
        /**
          * Show or hide the button to jump to the last page.
         */
        "showLastPage"?: boolean;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The total count of items.
         */
        "totalItemsCount": number;
    }
    interface PPinCode {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Disables the Pin Code. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label and description text. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * Number of characters of the Pin Code.
         */
        "length"?: PinCodeLength;
        /**
          * Disables the Pin Code and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Name of the control.
         */
        "name"?: string;
        /**
          * Marks the Pin Code as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: PinCodeState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Pin Code type.
         */
        "type"?: PinCodeType;
        /**
          * Sets the initial value of the Pin Code.
         */
        "value"?: string;
    }
    interface PPopover {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<PopoverAriaAttribute>;
        /**
          * Descriptive text to show additional information when popover is open
         */
        "description"?: string;
        /**
          * Preferred direction in which popover should open, given there is enough space in viewport. Otherwise, it will be opened in the direction with most available space.
         */
        "direction"?: PopoverDirection;
        /**
          * Adapts the popover color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PRadioButtonWrapper {
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * @experimental Disables the radio button and shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: RadioButtonWrapperState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PScroller {
        /**
          * Sets the vertical position of scroll indicator.
         */
        "alignScrollIndicator"?: ScrollerAlignScrollIndicator;
        /**
          * Add ARIA role.
         */
        "aria"?: SelectedAriaAttributes<ScrollerAriaAttribute>;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColor"?: ScrollerGradientColor;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `gradientColor` instead. Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: ScrollerGradientColorScheme;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `alignScrollIndicator` instead. Sets the vertical position of scroll indicator
         */
        "scrollIndicatorPosition"?: ScrollerScrollIndicatorPosition;
        /**
          * Scrolls the scroll area to the left either smooth or immediately.
         */
        "scrollToPosition"?: ScrollerScrollToPosition;
        /**
          * Specifies if scrollbar should be shown.
         */
        "scrollbar"?: boolean;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PSegmentedControl {
        /**
          * @deprecated since v3.0.0, will be removed with next major release. Background color variations
         */
        "backgroundColor"?: SegmentedControlBackgroundColor;
        /**
          * Sets the amount of columns.
         */
        "columns"?: BreakpointCustomizable<SegmentedControlColumns>;
        /**
          * Adapts the segmented-control color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Sets the initial value of the segmented-control.
         */
        "value"?: string | number;
    }
    interface PSegmentedControlItem {
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The icon shown.
         */
        "icon"?: SegmentedControlItemIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The value of this item which is emitted by the parent element if it becomes selected. This property is **required**.
         */
        "value": string | number;
    }
    interface PSelectWrapper {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Changes the direction to which the dropdown list appears.
         */
        "dropdownDirection"?: SelectWrapperDropdownDirection;
        /**
          * Filters select options by typing a character
         */
        "filter"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Forces rendering of native browser select dropdown
         */
        "native"?: boolean;
        /**
          * The validation state.
         */
        "state"?: SelectWrapperState;
        /**
          * Adapts the select color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PSelectWrapperDropdown {
        "description"?: string;
        "direction"?: SelectWrapperDropdownDirection;
        "disabled"?: boolean;
        "filter"?: boolean;
        "isOpenOverride"?: boolean;
        "label"?: string;
        "message"?: string;
        "onOpenChange": (isOpen: boolean) => void;
        "required"?: boolean;
        "selectRef"?: HTMLSelectElement;
        "state"?: SelectWrapperState;
        "theme"?: Theme;
    }
    interface PSpinner {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SpinnerAriaAttribute>;
        /**
          * Size of the spinner.
         */
        "size"?: BreakpointCustomizable<SpinnerSize>;
        /**
          * Adapts the spinner color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PStepperHorizontal {
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<StepperHorizontalSize>;
        /**
          * Adapts the tag color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PStepperHorizontalItem {
        /**
          * Disables the stepper-horizontal-item. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The validation state.
         */
        "state"?: StepperHorizontalItemState;
    }
    interface PSwitch {
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<SwitchAlignLabel>;
        /**
          * Visualize the switch with on/off status.
         */
        "checked"?: boolean;
        /**
          * Disables the switch. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Disables the switch and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Stretches the contents to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Adapts the switch color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PTable {
        /**
          * A caption describing the contents of the table for accessibility only. This won't be visible in the browser. Use an element with an attribute of `slot="caption"` for a visible caption.
         */
        "caption"?: string;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PTableBody {
    }
    interface PTableCell {
        /**
          * Displays slotted text multiline or forced into a single line.
         */
        "multiline"?: boolean;
    }
    interface PTableHead {
    }
    interface PTableHeadCell {
        /**
          * Hides the label but stays accessible for screen readers. This property only takes effect when sort property is not defined.
         */
        "hideLabel"?: boolean;
        /**
          * Displays slotted text multiline or forced into a single line.
         */
        "multiline"?: boolean;
        /**
          * Defines sortability properties.
         */
        "sort"?: TableHeadCellSort;
    }
    interface PTableHeadRow {
    }
    interface PTableRow {
    }
    interface PTabs {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering).
         */
        "activeTabIndex"?: number;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColor"?: TabsGradientColor;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `gradientColor` instead. Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: TabsGradientColorScheme;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabsSize>;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The text weight.
         */
        "weight"?: TabsWeight;
    }
    interface PTabsBar {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering), undefined if none should be selected.
         */
        "activeTabIndex"?: number | undefined;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColor"?: TabsBarGradientColor;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `gradientColor` instead. Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: TabsBarGradientColorScheme;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabsBarSize>;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The text weight.
         */
        "weight"?: TabsBarWeight;
    }
    interface PTabsItem {
        /**
          * Defines the label used in tabs.
         */
        "label": string;
    }
    interface PTag {
        /**
          * Background color variations depending on theme property.
         */
        "color"?: TagColor;
        /**
          * The icon shown.
         */
        "icon"?: TagIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Adapts the tag color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PTagDismissible {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<TagDismissibleAriaAttribute>;
        /**
          * Background color variations
         */
        "color"?: TagDismissibleColor;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PText {
        /**
          * Text alignment of the component.
         */
        "align"?: TextAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: TextColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the text. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<TextSize>;
        /**
          * Sets a custom HTML tag depending on the usage of the text component.
         */
        "tag"?: TextTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
        /**
          * The weight of the text.
         */
        "weight"?: TextWeight;
    }
    interface PTextFieldWrapper {
        /**
          * Action icon can be set to `locate` for `input type="search"` in order to display an action button.
         */
        "actionIcon"?: TextFieldWrapperActionIcon;
        /**
          * Disables the action button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "actionLoading"?: boolean;
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Show or hide label and description text. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `showCounter` instead. Show or hide max character count.
         */
        "showCharacterCount"?: boolean;
        /**
          * Show or hide max character count.
         */
        "showCounter"?: boolean;
        /**
          * @experimental Show or hide password toggle for `input type="password"`.
         */
        "showPasswordToggle"?: boolean;
        /**
          * The validation state.
         */
        "state"?: TextFieldWrapperState;
        /**
          * Show search button if wrapped inside a form.
         */
        "submitButton"?: boolean;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * The unit text.
         */
        "unit"?: string;
        /**
          * The unit position.
         */
        "unitPosition"?: TextFieldWrapperUnitPosition;
    }
    interface PTextList {
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `type` instead. The type of the list.
         */
        "listType"?: TextListListType;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `type` instead. The list style type of ordered list. Only has effect when list type is set to 'ordered'.
         */
        "orderType"?: TextListOrderType;
        /**
          * Adapts the text color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * The list style type.
         */
        "type"?: TextListType;
    }
    interface PTextListItem {
    }
    interface PTextareaWrapper {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `showCounter` instead. Show or hide max character count.
         */
        "showCharacterCount"?: boolean;
        /**
          * Show or hide max character count.
         */
        "showCounter"?: boolean;
        /**
          * The validation state.
         */
        "state"?: TextareaWrapperState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PToast {
        "addMessage": (message: ToastMessage) => Promise<void>;
        /**
          * Adapts the toast color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PToastItem {
        /**
          * State of the toast-item.
         */
        "state"?: ToastState;
        /**
          * Text of the toast-item.
         */
        "text"?: string;
        /**
          * Adapts the toast-item color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PWordmark {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<WordmarkAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Adapts sizing of wordmark.
         */
        "size"?: WordmarkSize;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: WordmarkTarget;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
}
export interface PAccordionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPAccordionElement;
}
export interface PBannerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPBannerElement;
}
export interface PCarouselCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPCarouselElement;
}
export interface PFlyoutCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPFlyoutElement;
}
export interface PFlyoutNavigationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPFlyoutNavigationElement;
}
export interface PInlineNotificationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInlineNotificationElement;
}
export interface PLinkTileProductCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPLinkTileProductElement;
}
export interface PModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPModalElement;
}
export interface PMultiSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPMultiSelectElement;
}
export interface PPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPPaginationElement;
}
export interface PPinCodeCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPPinCodeElement;
}
export interface PSegmentedControlCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPSegmentedControlElement;
}
export interface PStepperHorizontalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPStepperHorizontalElement;
}
export interface PSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPSwitchElement;
}
export interface PTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTableElement;
}
export interface PTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTabsElement;
}
export interface PTabsBarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTabsBarElement;
}
export interface PTextFieldWrapperCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTextFieldWrapperElement;
}
export interface PToastItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPToastItemElement;
}
declare global {
    interface HTMLPAccordionElementEventMap {
        "accordionChange": AccordionUpdateEventDetail;
        "update": AccordionUpdateEventDetail;
    }
    interface HTMLPAccordionElement extends Components.PAccordion, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPAccordionElementEventMap>(type: K, listener: (this: HTMLPAccordionElement, ev: PAccordionCustomEvent<HTMLPAccordionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPAccordionElementEventMap>(type: K, listener: (this: HTMLPAccordionElement, ev: PAccordionCustomEvent<HTMLPAccordionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPAccordionElement: {
        prototype: HTMLPAccordionElement;
        new (): HTMLPAccordionElement;
    };
    interface HTMLPBannerElementEventMap {
        "dismiss": void;
    }
    interface HTMLPBannerElement extends Components.PBanner, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPBannerElementEventMap>(type: K, listener: (this: HTMLPBannerElement, ev: PBannerCustomEvent<HTMLPBannerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPBannerElementEventMap>(type: K, listener: (this: HTMLPBannerElement, ev: PBannerCustomEvent<HTMLPBannerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPBannerElement: {
        prototype: HTMLPBannerElement;
        new (): HTMLPBannerElement;
    };
    interface HTMLPButtonElement extends Components.PButton, HTMLStencilElement {
    }
    var HTMLPButtonElement: {
        prototype: HTMLPButtonElement;
        new (): HTMLPButtonElement;
    };
    interface HTMLPButtonGroupElement extends Components.PButtonGroup, HTMLStencilElement {
    }
    var HTMLPButtonGroupElement: {
        prototype: HTMLPButtonGroupElement;
        new (): HTMLPButtonGroupElement;
    };
    interface HTMLPButtonPureElement extends Components.PButtonPure, HTMLStencilElement {
    }
    var HTMLPButtonPureElement: {
        prototype: HTMLPButtonPureElement;
        new (): HTMLPButtonPureElement;
    };
    interface HTMLPButtonTileElement extends Components.PButtonTile, HTMLStencilElement {
    }
    var HTMLPButtonTileElement: {
        prototype: HTMLPButtonTileElement;
        new (): HTMLPButtonTileElement;
    };
    interface HTMLPCarouselElementEventMap {
        "carouselChange": CarouselUpdateEventDetail;
        "update": CarouselUpdateEventDetail;
    }
    interface HTMLPCarouselElement extends Components.PCarousel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPCarouselElementEventMap>(type: K, listener: (this: HTMLPCarouselElement, ev: PCarouselCustomEvent<HTMLPCarouselElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPCarouselElementEventMap>(type: K, listener: (this: HTMLPCarouselElement, ev: PCarouselCustomEvent<HTMLPCarouselElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPCarouselElement: {
        prototype: HTMLPCarouselElement;
        new (): HTMLPCarouselElement;
    };
    interface HTMLPCheckboxWrapperElement extends Components.PCheckboxWrapper, HTMLStencilElement {
    }
    var HTMLPCheckboxWrapperElement: {
        prototype: HTMLPCheckboxWrapperElement;
        new (): HTMLPCheckboxWrapperElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface HTMLPContentWrapperElement extends Components.PContentWrapper, HTMLStencilElement {
    }
    var HTMLPContentWrapperElement: {
        prototype: HTMLPContentWrapperElement;
        new (): HTMLPContentWrapperElement;
    };
    interface HTMLPCrestElement extends Components.PCrest, HTMLStencilElement {
    }
    var HTMLPCrestElement: {
        prototype: HTMLPCrestElement;
        new (): HTMLPCrestElement;
    };
    interface HTMLPDisplayElement extends Components.PDisplay, HTMLStencilElement {
    }
    var HTMLPDisplayElement: {
        prototype: HTMLPDisplayElement;
        new (): HTMLPDisplayElement;
    };
    interface HTMLPDividerElement extends Components.PDivider, HTMLStencilElement {
    }
    var HTMLPDividerElement: {
        prototype: HTMLPDividerElement;
        new (): HTMLPDividerElement;
    };
    interface HTMLPFieldsetElement extends Components.PFieldset, HTMLStencilElement {
    }
    var HTMLPFieldsetElement: {
        prototype: HTMLPFieldsetElement;
        new (): HTMLPFieldsetElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-fieldset" instead.
     */
    interface HTMLPFieldsetWrapperElement extends Components.PFieldsetWrapper, HTMLStencilElement {
    }
    var HTMLPFieldsetWrapperElement: {
        prototype: HTMLPFieldsetWrapperElement;
        new (): HTMLPFieldsetWrapperElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
     */
    interface HTMLPFlexElement extends Components.PFlex, HTMLStencilElement {
    }
    var HTMLPFlexElement: {
        prototype: HTMLPFlexElement;
        new (): HTMLPFlexElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
     */
    interface HTMLPFlexItemElement extends Components.PFlexItem, HTMLStencilElement {
    }
    var HTMLPFlexItemElement: {
        prototype: HTMLPFlexItemElement;
        new (): HTMLPFlexItemElement;
    };
    interface HTMLPFlyoutElementEventMap {
        "dismiss": void;
    }
    interface HTMLPFlyoutElement extends Components.PFlyout, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPFlyoutElementEventMap>(type: K, listener: (this: HTMLPFlyoutElement, ev: PFlyoutCustomEvent<HTMLPFlyoutElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPFlyoutElementEventMap>(type: K, listener: (this: HTMLPFlyoutElement, ev: PFlyoutCustomEvent<HTMLPFlyoutElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPFlyoutElement: {
        prototype: HTMLPFlyoutElement;
        new (): HTMLPFlyoutElement;
    };
    interface HTMLPFlyoutNavigationElementEventMap {
        "dismiss": void;
        "update": FlyoutNavigationUpdateEventDetail;
    }
    /**
     * @experimental 
     */
    interface HTMLPFlyoutNavigationElement extends Components.PFlyoutNavigation, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPFlyoutNavigationElementEventMap>(type: K, listener: (this: HTMLPFlyoutNavigationElement, ev: PFlyoutNavigationCustomEvent<HTMLPFlyoutNavigationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPFlyoutNavigationElementEventMap>(type: K, listener: (this: HTMLPFlyoutNavigationElement, ev: PFlyoutNavigationCustomEvent<HTMLPFlyoutNavigationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPFlyoutNavigationElement: {
        prototype: HTMLPFlyoutNavigationElement;
        new (): HTMLPFlyoutNavigationElement;
    };
    /**
     * @experimental 
     */
    interface HTMLPFlyoutNavigationItemElement extends Components.PFlyoutNavigationItem, HTMLStencilElement {
    }
    var HTMLPFlyoutNavigationItemElement: {
        prototype: HTMLPFlyoutNavigationItemElement;
        new (): HTMLPFlyoutNavigationItemElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface HTMLPGridElement extends Components.PGrid, HTMLStencilElement {
    }
    var HTMLPGridElement: {
        prototype: HTMLPGridElement;
        new (): HTMLPGridElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface HTMLPGridItemElement extends Components.PGridItem, HTMLStencilElement {
    }
    var HTMLPGridItemElement: {
        prototype: HTMLPGridItemElement;
        new (): HTMLPGridItemElement;
    };
    interface HTMLPHeadingElement extends Components.PHeading, HTMLStencilElement {
    }
    var HTMLPHeadingElement: {
        prototype: HTMLPHeadingElement;
        new (): HTMLPHeadingElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-heading" instead.
     */
    interface HTMLPHeadlineElement extends Components.PHeadline, HTMLStencilElement {
    }
    var HTMLPHeadlineElement: {
        prototype: HTMLPHeadlineElement;
        new (): HTMLPHeadlineElement;
    };
    interface HTMLPIconElement extends Components.PIcon, HTMLStencilElement {
    }
    var HTMLPIconElement: {
        prototype: HTMLPIconElement;
        new (): HTMLPIconElement;
    };
    interface HTMLPInlineNotificationElementEventMap {
        "dismiss": void;
        "action": void;
    }
    interface HTMLPInlineNotificationElement extends Components.PInlineNotification, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInlineNotificationElementEventMap>(type: K, listener: (this: HTMLPInlineNotificationElement, ev: PInlineNotificationCustomEvent<HTMLPInlineNotificationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInlineNotificationElementEventMap>(type: K, listener: (this: HTMLPInlineNotificationElement, ev: PInlineNotificationCustomEvent<HTMLPInlineNotificationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInlineNotificationElement: {
        prototype: HTMLPInlineNotificationElement;
        new (): HTMLPInlineNotificationElement;
    };
    interface HTMLPLinkElement extends Components.PLink, HTMLStencilElement {
    }
    var HTMLPLinkElement: {
        prototype: HTMLPLinkElement;
        new (): HTMLPLinkElement;
    };
    interface HTMLPLinkPureElement extends Components.PLinkPure, HTMLStencilElement {
    }
    var HTMLPLinkPureElement: {
        prototype: HTMLPLinkPureElement;
        new (): HTMLPLinkPureElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use `p-link` with corresponding social icon instead.
     */
    interface HTMLPLinkSocialElement extends Components.PLinkSocial, HTMLStencilElement {
    }
    var HTMLPLinkSocialElement: {
        prototype: HTMLPLinkSocialElement;
        new (): HTMLPLinkSocialElement;
    };
    interface HTMLPLinkTileElement extends Components.PLinkTile, HTMLStencilElement {
    }
    var HTMLPLinkTileElement: {
        prototype: HTMLPLinkTileElement;
        new (): HTMLPLinkTileElement;
    };
    interface HTMLPLinkTileModelSignatureElement extends Components.PLinkTileModelSignature, HTMLStencilElement {
    }
    var HTMLPLinkTileModelSignatureElement: {
        prototype: HTMLPLinkTileModelSignatureElement;
        new (): HTMLPLinkTileModelSignatureElement;
    };
    interface HTMLPLinkTileProductElementEventMap {
        "like": LinkTileProductLikeEventDetail;
    }
    /**
     * @experimental 
     */
    interface HTMLPLinkTileProductElement extends Components.PLinkTileProduct, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPLinkTileProductElementEventMap>(type: K, listener: (this: HTMLPLinkTileProductElement, ev: PLinkTileProductCustomEvent<HTMLPLinkTileProductElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPLinkTileProductElementEventMap>(type: K, listener: (this: HTMLPLinkTileProductElement, ev: PLinkTileProductCustomEvent<HTMLPLinkTileProductElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPLinkTileProductElement: {
        prototype: HTMLPLinkTileProductElement;
        new (): HTMLPLinkTileProductElement;
    };
    interface HTMLPLoadingBaseComponentElement extends Components.PLoadingBaseComponent, HTMLStencilElement {
    }
    var HTMLPLoadingBaseComponentElement: {
        prototype: HTMLPLoadingBaseComponentElement;
        new (): HTMLPLoadingBaseComponentElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-wordmark" instead.
     */
    interface HTMLPMarqueElement extends Components.PMarque, HTMLStencilElement {
    }
    var HTMLPMarqueElement: {
        prototype: HTMLPMarqueElement;
        new (): HTMLPMarqueElement;
    };
    interface HTMLPModalElementEventMap {
        "close": void;
        "dismiss": void;
    }
    interface HTMLPModalElement extends Components.PModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPModalElementEventMap>(type: K, listener: (this: HTMLPModalElement, ev: PModalCustomEvent<HTMLPModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPModalElementEventMap>(type: K, listener: (this: HTMLPModalElement, ev: PModalCustomEvent<HTMLPModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPModalElement: {
        prototype: HTMLPModalElement;
        new (): HTMLPModalElement;
    };
    interface HTMLPModelSignatureElement extends Components.PModelSignature, HTMLStencilElement {
    }
    var HTMLPModelSignatureElement: {
        prototype: HTMLPModelSignatureElement;
        new (): HTMLPModelSignatureElement;
    };
    interface HTMLPMultiSelectElementEventMap {
        "update": MultiSelectUpdateEventDetail;
    }
    interface HTMLPMultiSelectElement extends Components.PMultiSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPMultiSelectElementEventMap>(type: K, listener: (this: HTMLPMultiSelectElement, ev: PMultiSelectCustomEvent<HTMLPMultiSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPMultiSelectElementEventMap>(type: K, listener: (this: HTMLPMultiSelectElement, ev: PMultiSelectCustomEvent<HTMLPMultiSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPMultiSelectElement: {
        prototype: HTMLPMultiSelectElement;
        new (): HTMLPMultiSelectElement;
    };
    interface HTMLPMultiSelectOptionElement extends Components.PMultiSelectOption, HTMLStencilElement {
    }
    var HTMLPMultiSelectOptionElement: {
        prototype: HTMLPMultiSelectOptionElement;
        new (): HTMLPMultiSelectOptionElement;
    };
    interface HTMLPPaginationElementEventMap {
        "pageChange": PaginationUpdateEventDetail;
        "update": PaginationUpdateEventDetail;
    }
    interface HTMLPPaginationElement extends Components.PPagination, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPPaginationElementEventMap>(type: K, listener: (this: HTMLPPaginationElement, ev: PPaginationCustomEvent<HTMLPPaginationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPPaginationElementEventMap>(type: K, listener: (this: HTMLPPaginationElement, ev: PPaginationCustomEvent<HTMLPPaginationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPPaginationElement: {
        prototype: HTMLPPaginationElement;
        new (): HTMLPPaginationElement;
    };
    interface HTMLPPinCodeElementEventMap {
        "update": PinCodeUpdateEventDetail;
    }
    interface HTMLPPinCodeElement extends Components.PPinCode, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPPinCodeElementEventMap>(type: K, listener: (this: HTMLPPinCodeElement, ev: PPinCodeCustomEvent<HTMLPPinCodeElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPPinCodeElementEventMap>(type: K, listener: (this: HTMLPPinCodeElement, ev: PPinCodeCustomEvent<HTMLPPinCodeElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPPinCodeElement: {
        prototype: HTMLPPinCodeElement;
        new (): HTMLPPinCodeElement;
    };
    interface HTMLPPopoverElement extends Components.PPopover, HTMLStencilElement {
    }
    var HTMLPPopoverElement: {
        prototype: HTMLPPopoverElement;
        new (): HTMLPPopoverElement;
    };
    interface HTMLPRadioButtonWrapperElement extends Components.PRadioButtonWrapper, HTMLStencilElement {
    }
    var HTMLPRadioButtonWrapperElement: {
        prototype: HTMLPRadioButtonWrapperElement;
        new (): HTMLPRadioButtonWrapperElement;
    };
    interface HTMLPScrollerElement extends Components.PScroller, HTMLStencilElement {
    }
    var HTMLPScrollerElement: {
        prototype: HTMLPScrollerElement;
        new (): HTMLPScrollerElement;
    };
    interface HTMLPSegmentedControlElementEventMap {
        "segmentedControlChange": SegmentedControlUpdateEventDetail;
        "update": SegmentedControlUpdateEventDetail;
    }
    interface HTMLPSegmentedControlElement extends Components.PSegmentedControl, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPSegmentedControlElementEventMap>(type: K, listener: (this: HTMLPSegmentedControlElement, ev: PSegmentedControlCustomEvent<HTMLPSegmentedControlElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPSegmentedControlElementEventMap>(type: K, listener: (this: HTMLPSegmentedControlElement, ev: PSegmentedControlCustomEvent<HTMLPSegmentedControlElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPSegmentedControlElement: {
        prototype: HTMLPSegmentedControlElement;
        new (): HTMLPSegmentedControlElement;
    };
    interface HTMLPSegmentedControlItemElement extends Components.PSegmentedControlItem, HTMLStencilElement {
    }
    var HTMLPSegmentedControlItemElement: {
        prototype: HTMLPSegmentedControlItemElement;
        new (): HTMLPSegmentedControlItemElement;
    };
    interface HTMLPSelectWrapperElement extends Components.PSelectWrapper, HTMLStencilElement {
    }
    var HTMLPSelectWrapperElement: {
        prototype: HTMLPSelectWrapperElement;
        new (): HTMLPSelectWrapperElement;
    };
    interface HTMLPSelectWrapperDropdownElement extends Components.PSelectWrapperDropdown, HTMLStencilElement {
    }
    var HTMLPSelectWrapperDropdownElement: {
        prototype: HTMLPSelectWrapperDropdownElement;
        new (): HTMLPSelectWrapperDropdownElement;
    };
    interface HTMLPSpinnerElement extends Components.PSpinner, HTMLStencilElement {
    }
    var HTMLPSpinnerElement: {
        prototype: HTMLPSpinnerElement;
        new (): HTMLPSpinnerElement;
    };
    interface HTMLPStepperHorizontalElementEventMap {
        "stepChange": StepperHorizontalUpdateEventDetail;
        "update": StepperHorizontalUpdateEventDetail;
    }
    interface HTMLPStepperHorizontalElement extends Components.PStepperHorizontal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPStepperHorizontalElementEventMap>(type: K, listener: (this: HTMLPStepperHorizontalElement, ev: PStepperHorizontalCustomEvent<HTMLPStepperHorizontalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPStepperHorizontalElementEventMap>(type: K, listener: (this: HTMLPStepperHorizontalElement, ev: PStepperHorizontalCustomEvent<HTMLPStepperHorizontalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPStepperHorizontalElement: {
        prototype: HTMLPStepperHorizontalElement;
        new (): HTMLPStepperHorizontalElement;
    };
    interface HTMLPStepperHorizontalItemElement extends Components.PStepperHorizontalItem, HTMLStencilElement {
    }
    var HTMLPStepperHorizontalItemElement: {
        prototype: HTMLPStepperHorizontalItemElement;
        new (): HTMLPStepperHorizontalItemElement;
    };
    interface HTMLPSwitchElementEventMap {
        "switchChange": SwitchUpdateEventDetail;
        "update": SwitchUpdateEventDetail;
    }
    interface HTMLPSwitchElement extends Components.PSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPSwitchElementEventMap>(type: K, listener: (this: HTMLPSwitchElement, ev: PSwitchCustomEvent<HTMLPSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPSwitchElementEventMap>(type: K, listener: (this: HTMLPSwitchElement, ev: PSwitchCustomEvent<HTMLPSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPSwitchElement: {
        prototype: HTMLPSwitchElement;
        new (): HTMLPSwitchElement;
    };
    interface HTMLPTableElementEventMap {
        "sortingChange": TableUpdateEventDetail;
        "update": TableUpdateEventDetail;
    }
    interface HTMLPTableElement extends Components.PTable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPTableElementEventMap>(type: K, listener: (this: HTMLPTableElement, ev: PTableCustomEvent<HTMLPTableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPTableElementEventMap>(type: K, listener: (this: HTMLPTableElement, ev: PTableCustomEvent<HTMLPTableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPTableElement: {
        prototype: HTMLPTableElement;
        new (): HTMLPTableElement;
    };
    interface HTMLPTableBodyElement extends Components.PTableBody, HTMLStencilElement {
    }
    var HTMLPTableBodyElement: {
        prototype: HTMLPTableBodyElement;
        new (): HTMLPTableBodyElement;
    };
    interface HTMLPTableCellElement extends Components.PTableCell, HTMLStencilElement {
    }
    var HTMLPTableCellElement: {
        prototype: HTMLPTableCellElement;
        new (): HTMLPTableCellElement;
    };
    interface HTMLPTableHeadElement extends Components.PTableHead, HTMLStencilElement {
    }
    var HTMLPTableHeadElement: {
        prototype: HTMLPTableHeadElement;
        new (): HTMLPTableHeadElement;
    };
    interface HTMLPTableHeadCellElement extends Components.PTableHeadCell, HTMLStencilElement {
    }
    var HTMLPTableHeadCellElement: {
        prototype: HTMLPTableHeadCellElement;
        new (): HTMLPTableHeadCellElement;
    };
    interface HTMLPTableHeadRowElement extends Components.PTableHeadRow, HTMLStencilElement {
    }
    var HTMLPTableHeadRowElement: {
        prototype: HTMLPTableHeadRowElement;
        new (): HTMLPTableHeadRowElement;
    };
    interface HTMLPTableRowElement extends Components.PTableRow, HTMLStencilElement {
    }
    var HTMLPTableRowElement: {
        prototype: HTMLPTableRowElement;
        new (): HTMLPTableRowElement;
    };
    interface HTMLPTabsElementEventMap {
        "tabChange": TabsUpdateEventDetail;
        "update": TabsUpdateEventDetail;
    }
    interface HTMLPTabsElement extends Components.PTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPTabsElementEventMap>(type: K, listener: (this: HTMLPTabsElement, ev: PTabsCustomEvent<HTMLPTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPTabsElementEventMap>(type: K, listener: (this: HTMLPTabsElement, ev: PTabsCustomEvent<HTMLPTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPTabsElement: {
        prototype: HTMLPTabsElement;
        new (): HTMLPTabsElement;
    };
    interface HTMLPTabsBarElementEventMap {
        "tabChange": TabsBarUpdateEventDetail;
        "update": TabsBarUpdateEventDetail;
    }
    interface HTMLPTabsBarElement extends Components.PTabsBar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPTabsBarElementEventMap>(type: K, listener: (this: HTMLPTabsBarElement, ev: PTabsBarCustomEvent<HTMLPTabsBarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPTabsBarElementEventMap>(type: K, listener: (this: HTMLPTabsBarElement, ev: PTabsBarCustomEvent<HTMLPTabsBarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPTabsBarElement: {
        prototype: HTMLPTabsBarElement;
        new (): HTMLPTabsBarElement;
    };
    interface HTMLPTabsItemElement extends Components.PTabsItem, HTMLStencilElement {
    }
    var HTMLPTabsItemElement: {
        prototype: HTMLPTabsItemElement;
        new (): HTMLPTabsItemElement;
    };
    interface HTMLPTagElement extends Components.PTag, HTMLStencilElement {
    }
    var HTMLPTagElement: {
        prototype: HTMLPTagElement;
        new (): HTMLPTagElement;
    };
    interface HTMLPTagDismissibleElement extends Components.PTagDismissible, HTMLStencilElement {
    }
    var HTMLPTagDismissibleElement: {
        prototype: HTMLPTagDismissibleElement;
        new (): HTMLPTagDismissibleElement;
    };
    interface HTMLPTextElement extends Components.PText, HTMLStencilElement {
    }
    var HTMLPTextElement: {
        prototype: HTMLPTextElement;
        new (): HTMLPTextElement;
    };
    interface HTMLPTextFieldWrapperElementEventMap {
        "action": void;
    }
    interface HTMLPTextFieldWrapperElement extends Components.PTextFieldWrapper, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPTextFieldWrapperElementEventMap>(type: K, listener: (this: HTMLPTextFieldWrapperElement, ev: PTextFieldWrapperCustomEvent<HTMLPTextFieldWrapperElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPTextFieldWrapperElementEventMap>(type: K, listener: (this: HTMLPTextFieldWrapperElement, ev: PTextFieldWrapperCustomEvent<HTMLPTextFieldWrapperElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPTextFieldWrapperElement: {
        prototype: HTMLPTextFieldWrapperElement;
        new (): HTMLPTextFieldWrapperElement;
    };
    interface HTMLPTextListElement extends Components.PTextList, HTMLStencilElement {
    }
    var HTMLPTextListElement: {
        prototype: HTMLPTextListElement;
        new (): HTMLPTextListElement;
    };
    interface HTMLPTextListItemElement extends Components.PTextListItem, HTMLStencilElement {
    }
    var HTMLPTextListItemElement: {
        prototype: HTMLPTextListItemElement;
        new (): HTMLPTextListItemElement;
    };
    interface HTMLPTextareaWrapperElement extends Components.PTextareaWrapper, HTMLStencilElement {
    }
    var HTMLPTextareaWrapperElement: {
        prototype: HTMLPTextareaWrapperElement;
        new (): HTMLPTextareaWrapperElement;
    };
    interface HTMLPToastElement extends Components.PToast, HTMLStencilElement {
    }
    var HTMLPToastElement: {
        prototype: HTMLPToastElement;
        new (): HTMLPToastElement;
    };
    interface HTMLPToastItemElementEventMap {
        "dismiss": void;
    }
    interface HTMLPToastItemElement extends Components.PToastItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPToastItemElementEventMap>(type: K, listener: (this: HTMLPToastItemElement, ev: PToastItemCustomEvent<HTMLPToastItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPToastItemElementEventMap>(type: K, listener: (this: HTMLPToastItemElement, ev: PToastItemCustomEvent<HTMLPToastItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPToastItemElement: {
        prototype: HTMLPToastItemElement;
        new (): HTMLPToastItemElement;
    };
    interface HTMLPWordmarkElement extends Components.PWordmark, HTMLStencilElement {
    }
    var HTMLPWordmarkElement: {
        prototype: HTMLPWordmarkElement;
        new (): HTMLPWordmarkElement;
    };
    interface HTMLElementTagNameMap {
        "p-accordion": HTMLPAccordionElement;
        "p-banner": HTMLPBannerElement;
        "p-button": HTMLPButtonElement;
        "p-button-group": HTMLPButtonGroupElement;
        "p-button-pure": HTMLPButtonPureElement;
        "p-button-tile": HTMLPButtonTileElement;
        "p-carousel": HTMLPCarouselElement;
        "p-checkbox-wrapper": HTMLPCheckboxWrapperElement;
        "p-content-wrapper": HTMLPContentWrapperElement;
        "p-crest": HTMLPCrestElement;
        "p-display": HTMLPDisplayElement;
        "p-divider": HTMLPDividerElement;
        "p-fieldset": HTMLPFieldsetElement;
        "p-fieldset-wrapper": HTMLPFieldsetWrapperElement;
        "p-flex": HTMLPFlexElement;
        "p-flex-item": HTMLPFlexItemElement;
        "p-flyout": HTMLPFlyoutElement;
        "p-flyout-navigation": HTMLPFlyoutNavigationElement;
        "p-flyout-navigation-item": HTMLPFlyoutNavigationItemElement;
        "p-grid": HTMLPGridElement;
        "p-grid-item": HTMLPGridItemElement;
        "p-heading": HTMLPHeadingElement;
        "p-headline": HTMLPHeadlineElement;
        "p-icon": HTMLPIconElement;
        "p-inline-notification": HTMLPInlineNotificationElement;
        "p-link": HTMLPLinkElement;
        "p-link-pure": HTMLPLinkPureElement;
        "p-link-social": HTMLPLinkSocialElement;
        "p-link-tile": HTMLPLinkTileElement;
        "p-link-tile-model-signature": HTMLPLinkTileModelSignatureElement;
        "p-link-tile-product": HTMLPLinkTileProductElement;
        "p-loading-base-component": HTMLPLoadingBaseComponentElement;
        "p-marque": HTMLPMarqueElement;
        "p-modal": HTMLPModalElement;
        "p-model-signature": HTMLPModelSignatureElement;
        "p-multi-select": HTMLPMultiSelectElement;
        "p-multi-select-option": HTMLPMultiSelectOptionElement;
        "p-pagination": HTMLPPaginationElement;
        "p-pin-code": HTMLPPinCodeElement;
        "p-popover": HTMLPPopoverElement;
        "p-radio-button-wrapper": HTMLPRadioButtonWrapperElement;
        "p-scroller": HTMLPScrollerElement;
        "p-segmented-control": HTMLPSegmentedControlElement;
        "p-segmented-control-item": HTMLPSegmentedControlItemElement;
        "p-select-wrapper": HTMLPSelectWrapperElement;
        "p-select-wrapper-dropdown": HTMLPSelectWrapperDropdownElement;
        "p-spinner": HTMLPSpinnerElement;
        "p-stepper-horizontal": HTMLPStepperHorizontalElement;
        "p-stepper-horizontal-item": HTMLPStepperHorizontalItemElement;
        "p-switch": HTMLPSwitchElement;
        "p-table": HTMLPTableElement;
        "p-table-body": HTMLPTableBodyElement;
        "p-table-cell": HTMLPTableCellElement;
        "p-table-head": HTMLPTableHeadElement;
        "p-table-head-cell": HTMLPTableHeadCellElement;
        "p-table-head-row": HTMLPTableHeadRowElement;
        "p-table-row": HTMLPTableRowElement;
        "p-tabs": HTMLPTabsElement;
        "p-tabs-bar": HTMLPTabsBarElement;
        "p-tabs-item": HTMLPTabsItemElement;
        "p-tag": HTMLPTagElement;
        "p-tag-dismissible": HTMLPTagDismissibleElement;
        "p-text": HTMLPTextElement;
        "p-text-field-wrapper": HTMLPTextFieldWrapperElement;
        "p-text-list": HTMLPTextListElement;
        "p-text-list-item": HTMLPTextListItemElement;
        "p-textarea-wrapper": HTMLPTextareaWrapperElement;
        "p-toast": HTMLPToastElement;
        "p-toast-item": HTMLPToastItemElement;
        "p-wordmark": HTMLPWordmarkElement;
    }
}
declare namespace LocalJSX {
    interface PAccordion {
        /**
          * Displays the Accordion as compact version with thinner border and smaller paddings.
         */
        "compact"?: boolean;
        /**
          * Defines the heading used in accordion.
         */
        "heading"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when accordion state is changed.
         */
        "onAccordionChange"?: (event: PAccordionCustomEvent<AccordionUpdateEventDetail>) => void;
        /**
          * Emitted when accordion state is changed.
         */
        "onUpdate"?: (event: PAccordionCustomEvent<AccordionUpdateEventDetail>) => void;
        /**
          * Defines if accordion is open.
         */
        "open"?: boolean;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<AccordionSize>;
        /**
          * Sets a headline tag, so it fits correctly within the outline of the page.
         */
        "tag"?: AccordionTag;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PBanner {
        /**
          * Description of the banner.
         */
        "description"?: string;
        /**
          * If false, the banner will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the banner.
         */
        "heading"?: string;
        /**
          * Emitted when the close button is clicked.
         */
        "onDismiss"?: (event: PBannerCustomEvent<void>) => void;
        /**
          * If true, the banner is open.
         */
        "open"?: boolean;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `dismissButton` instead. Defines if the banner can be closed/removed by the user.
         */
        "persistent"?: boolean;
        /**
          * State of the banner.
         */
        "state"?: BannerState;
        /**
          * Adapts the banner color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "width"?: BannerWidth;
    }
    interface PButton {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: ButtonIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * The name of the button, submitted as a pair with the button's value as part of the form data, when that button is used to submit the form.
         */
        "name"?: string;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonType;
        /**
          * Defines the value associated with the button's name when it's submitted with the form data. This value is passed to the server in params when the form is submitted using this button.
         */
        "value"?: string;
        /**
          * The style variant of the button.
         */
        "variant"?: ButtonVariant;
    }
    interface PButtonGroup {
        /**
          * Defines the direction of the main and cross axis. The default is ’{base: ‘column’, xs: ‘row’}' showing buttons vertically stacked on mobile viewports and side-by-side in a horizontal row from breakpoint ‘xs’. You always need to provide a base value when using breakpoints.
         */
        "direction"?: BreakpointCustomizable<ButtonGroupDirection>;
    }
    interface PButtonPure {
        /**
          * Display button in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<ButtonPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonPureAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown.
         */
        "icon"?: ButtonPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * The name of the button, submitted as a pair with the button's value as part of the form data, when that button is used to submit the form.
         */
        "name"?: string;
        /**
          * Size of the button.
         */
        "size"?: BreakpointCustomizable<ButtonPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonPureType;
        /**
          * Defines the value associated with the button's name when it's submitted with the form data. This value is passed to the server in params when the form is submitted using this button.
         */
        "value"?: string;
        /**
          * The weight of the text (only has effect with visible label).
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "weight"?: ButtonPureWeight;
    }
    interface PButtonTile {
        /**
          * Alignment of button and description.
         */
        "align"?: ButtonTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonTileAriaAttribute>;
        /**
          * Aspect ratio of the button-tile.
         */
        "aspectRatio"?: BreakpointCustomizable<ButtonTileAspectRatio>;
        /**
          * Adapts the description and button theme when used on light background image.
         */
        "background"?: ButtonTileBackground;
        /**
          * Displays the button-tile as compact version with description and button icon only.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description"?: string;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show gradient.
         */
        "gradient"?: boolean;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: ButtonTileIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Label of the button.
         */
        "label"?: string;
        /**
          * Disables the button-tile and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Font size of the description.
         */
        "size"?: BreakpointCustomizable<ButtonTileSize>;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonTileType;
        /**
          * Font weight of the description.
         */
        "weight"?: BreakpointCustomizable<ButtonTileWeight>;
    }
    interface PCarousel {
        /**
          * Defines which slide to be active (zero-based numbering).
         */
        "activeSlideIndex"?: number;
        /**
          * Alignment of heading and description
         */
        "alignHeader"?: CarouselAlignHeader;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<CarouselAriaAttribute>;
        /**
          * Defines the description used in the carousel.
         */
        "description"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `pagination` instead. If true, the carousel will not show pagination bullets at the bottom.
         */
        "disablePagination"?: BreakpointCustomizable<boolean>;
        /**
          * Defines the heading used in the carousel.
         */
        "heading"?: string;
        /**
          * Defines the heading size used in the carousel.
         */
        "headingSize"?: CarouselHeadingSize;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev buttons and pagination.
         */
        "intl"?: CarouselInternationalization;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when carousel's content slides.
         */
        "onCarouselChange"?: (event: PCarouselCustomEvent<CarouselUpdateEventDetail>) => void;
        /**
          * Emitted when carousel's content slides.
         */
        "onUpdate"?: (event: PCarouselCustomEvent<CarouselUpdateEventDetail>) => void;
        /**
          * If false, the carousel will not show pagination bullets at the bottom.
         */
        "pagination"?: BreakpointCustomizable<boolean>;
        /**
          * Whether the slides should rewind from last to first slide and vice versa.
         */
        "rewind"?: boolean;
        /**
          * Defines target of skip link (to skip carousel entries).
         */
        "skipLinkTarget"?: string;
        /**
          * Sets the amount of slides visible at the same time. Can be set to `auto` if you want to define different widths per slide via CSS.
         */
        "slidesPerPage"?: BreakpointCustomizable<number> | 'auto';
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * Defines the outer spacings between the carousel and the left and right screen sides.
         */
        "width"?: CarouselWidth;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "wrapContent"?: boolean;
    }
    interface PCheckboxWrapper {
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * @experimental Disables the checkbox and shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: CheckboxWrapperState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface PContentWrapper {
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "backgroundColor"?: ContentWrapperBackgroundColor;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "theme"?: Theme;
        /**
          * Defines the outer spacings between the content area and the left and right screen sides, as well as centering its content and setting a max-width.
         */
        "width"?: ContentWrapperWidth;
    }
    interface PCrest {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<CrestAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: CrestTarget;
    }
    interface PDisplay {
        /**
          * Text alignment of the component.
         */
        "align"?: DisplayAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: DisplayColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "medium", l: "large"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<DisplaySize>;
        /**
          * Sets a custom HTML tag depending on the usage of the display component.
         */
        "tag"?: DisplayTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
    }
    interface PDivider {
        /**
          * Defines color depending on theme.
         */
        "color"?: DividerColor;
        /**
          * Defines direction.
         */
        "direction"?: BreakpointCustomizable<DividerDirection>;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `direction` instead. Defines orientation.
         */
        "orientation"?: BreakpointCustomizable<DividerOrientation>;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    interface PFieldset {
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The size of the label text.
         */
        "labelSize"?: FieldsetLabelSize;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Marks the Fieldset as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: FieldsetState;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-fieldset" instead.
     */
    interface PFieldsetWrapper {
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The size of the label text.
         */
        "labelSize"?: FieldsetWrapperLabelSize;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Marks the Fieldset as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: FieldsetWrapperState;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
     */
    interface PFlex {
        /**
          * This aligns a flex container's individual lines when there is extra space in the cross-axis, similar to how "justifyContent" aligns individual items along the main axis.
         */
        "alignContent"?: BreakpointCustomizable<FlexAlignContent>;
        /**
          * Defines how the flex items are aligned along the cross axis.
         */
        "alignItems"?: BreakpointCustomizable<FlexAlignItems>;
        /**
          * Defines the direction of the main and cross axis. The default "row" defines the main axis as horizontal left to right.
         */
        "direction"?: BreakpointCustomizable<FlexDirection>;
        /**
          * Defines the flex containers content flow if 2 or more containers are siblings of each other.
         */
        "inline"?: BreakpointCustomizable<FlexInline>;
        /**
          * Defines how the flex items are aligned along the main axis.
         */
        "justifyContent"?: BreakpointCustomizable<FlexJustifyContent>;
        /**
          * Handles wrapping behaviour of elements.
         */
        "wrap"?: BreakpointCustomizable<FlexWrap>;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
     */
    interface PFlexItem {
        /**
          * Defines how this flex item is aligned along the cross axis. This overwrites the cross axis alignment set by the container. Corresponds to the "alignSelf" css property.
         */
        "alignSelf"?: BreakpointCustomizable<FlexItemAlignSelf>;
        /**
          * The shorthand property for the combined definition of "shrink", "grow" and "basis"
         */
        "flex"?: BreakpointCustomizable<FlexItemFlex>;
        /**
          * The ability to allow/disallow the flex child to grow.
         */
        "grow"?: BreakpointCustomizable<FlexItemGrow>;
        /**
          * The offset of the column. You can also supply values for specific breakpoints, like {base: "none", l: "one-quarter"}. You always need to provide a base value when doing this.
         */
        "offset"?: BreakpointCustomizable<FlexItemOffset>;
        /**
          * The ability to allow/disallow the flex child to shrink.
         */
        "shrink"?: BreakpointCustomizable<FlexItemShrink>;
        /**
          * The width of the flex item. You can also supply values for specific breakpoints, like {base: "full", l: "one-quarter"}. You always need to provide a base value when doing this.
         */
        "width"?: BreakpointCustomizable<FlexItemWidth>;
    }
    interface PFlyout {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<FlyoutAriaAttribute>;
        /**
          * Emitted when the component requests to be dismissed.
         */
        "onDismiss"?: (event: PFlyoutCustomEvent<void>) => void;
        /**
          * If true, the flyout is open.
         */
        "open"?: boolean;
        /**
          * The position of the flyout
         */
        "position"?: FlyoutPosition;
        /**
          * Adapts the flyout color depending on the theme.
         */
        "theme"?: Theme;
    }
    /**
     * @experimental 
     */
    interface PFlyoutNavigation {
        /**
          * Defines which flyout-navigation-item to be visualized as opened.
         */
        "activeIdentifier"?: string | undefined;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<FlyoutNavigationAriaAttribute>;
        /**
          * Emitted when the component requests to be dismissed.
         */
        "onDismiss"?: (event: PFlyoutNavigationCustomEvent<void>) => void;
        /**
          * Emitted when activeIdentifier is changed.
         */
        "onUpdate"?: (event: PFlyoutNavigationCustomEvent<FlyoutNavigationUpdateEventDetail>) => void;
        /**
          * If true, the flyout-navigation is visualized as opened.
         */
        "open"?: boolean;
        /**
          * Adapts the flyout-navigation color depending on the theme.
         */
        "theme"?: Theme;
    }
    /**
     * @experimental 
     */
    interface PFlyoutNavigationItem {
        /**
          * Unique identifier which controls if this item should be shown when the active-identifier on the flyout-navigation is set to this value.
         */
        "identifier"?: string;
        /**
          * Label of the item.
         */
        "label"?: string;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface PGrid {
        /**
          * Defines the direction of the main and cross axis. The default "row" defines the main axis as horizontal left to right. Also defines the direction for specific breakpoints, like {base: "column", l: "row"}. You always need to provide a base value when doing this.
         */
        "direction"?: BreakpointCustomizable<GridDirection>;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "gutter"?: BreakpointCustomizable<GridGutter>;
        /**
          * Handles wrapping behaviour of elements.
         */
        "wrap"?: BreakpointCustomizable<GridWrap>;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface PGridItem {
        /**
          * The offset of the column. Can be between 0 and 11. Also defines the offset of the column for specific breakpoints, like {base: 6, l: 3}. You always need to provide a base value when doing this.
         */
        "offset"?: BreakpointCustomizable<GridItemOffset>;
        /**
          * The size of the column. Can be between 1 and 12. Also defines the size of the column for specific breakpoints, like {base: 6, l: 3}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<GridItemSize>;
    }
    interface PHeading {
        /**
          * Text alignment of the component.
         */
        "align"?: HeadingAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: HeadingColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<HeadingSize>;
        /**
          * Sets a custom HTML tag depending on the usage of the heading component.
         */
        "tag"?: HeadingTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-heading" instead.
     */
    interface PHeadline {
        /**
          * Text alignment of the component.
         */
        "align"?: HeadlineAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: HeadlineColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Sets a custom HTML tag depending on the usage of the headline component.
         */
        "tag"?: HeadlineTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
        /**
          * Predefined style of the headline.
         */
        "variant"?: HeadlineVariant;
    }
    interface PIcon {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<IconAriaAttribute>;
        /**
          * Basic color variations depending on theme property.
         */
        "color"?: IconColor;
        /**
          * Has no effect anymore (the component is now using the native `loading="lazy"` attribute by default)
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "lazy"?: boolean;
        /**
          * Specifies which icon to use.
         */
        "name"?: IconName;
        /**
          * The size of the icon.
         */
        "size"?: IconSize;
        /**
          * Specifies a whole icon path which can be used for custom icons.
         */
        "source"?: string;
        /**
          * Adapts the color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
    }
    interface PInlineNotification {
        /**
          * Action icon of the inline-notification.
         */
        "actionIcon"?: InlineNotificationActionIcon;
        /**
          * Action label of the inline-notification.
         */
        "actionLabel"?: string;
        /**
          * Disables the action button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "actionLoading"?: boolean;
        /**
          * Description of the inline-notification.
         */
        "description"?: string;
        /**
          * If false, the inline-notification will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the inline-notification.
         */
        "heading"?: string;
        /**
          * Emitted when the action button is clicked.
         */
        "onAction"?: (event: PInlineNotificationCustomEvent<void>) => void;
        /**
          * Emitted when the close button is clicked.
         */
        "onDismiss"?: (event: PInlineNotificationCustomEvent<void>) => void;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `dismissButton` instead. Defines if the inline-notification can be closed/removed by the user.
         */
        "persistent"?: boolean;
        /**
          * State of the inline-notification.
         */
        "state"?: InlineNotificationState;
        /**
          * Adapts the inline-notification color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PLink {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: LinkIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTarget;
        /**
          * Adapts the link color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The style variant of the link.
         */
        "variant"?: LinkVariant;
    }
    interface PLinkPure {
        /**
          * Display link in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<LinkPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkPureAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed
         */
        "icon"?: LinkPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Size of the link.
         */
        "size"?: BreakpointCustomizable<LinkPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkPureTarget;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Shows an underline under the label.
         */
        "underline"?: boolean;
        /**
          * The weight of the text (only has effect with visible label).
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "weight"?: LinkPureWeight;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use `p-link` with corresponding social icon instead.
     */
    interface PLinkSocial {
        /**
          * Show or hide label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown.
         */
        "icon"?: LinkSocialIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkSocialTarget;
        /**
          * Adapts the link color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PLinkTile {
        /**
          * Alignment of link and description.
         */
        "align"?: LinkTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkTileAriaAttribute>;
        /**
          * Aspect ratio of the link-tile.
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileAspectRatio>;
        /**
          * Adapts the description and link theme when used on light background image.
         */
        "background"?: LinkTileBackground;
        /**
          * Displays the link-tile as compact version with description and link icon only.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description"?: string;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show gradient.
         */
        "gradient"?: boolean;
        /**
          * href of the `<a>`.
         */
        "href"?: string;
        /**
          * Label of the <a />.
         */
        "label"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Font size of the description.
         */
        "size"?: BreakpointCustomizable<LinkTileSize>;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTileTarget;
        /**
          * Font weight of the description.
         */
        "weight"?: BreakpointCustomizable<LinkTileWeight>;
    }
    interface PLinkTileModelSignature {
        /**
          * Aspect ratio of the link-tile-model-signature.
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileModelSignatureAspectRatio>;
        /**
          * Description text.
         */
        "description"?: string;
        /**
          * Heading text.
         */
        "heading"?: string;
        /**
          * Sets a custom headline tag which wraps the heading to enhance semantics.
         */
        "headingTag"?: LinkTileModelSignatureHeadingTag;
        /**
          * Defines the direction of the main and cross axis of the links. The default is '{base: ‘column’, xs: ‘row’}' showing buttons vertically stacked on mobile viewports and side-by-side in a horizontal row from breakpoint 'xs'.
         */
        "linkDirection"?: BreakpointCustomizable<LinkTileModelSignatureLinkDirection>;
        /**
          * Adapts the model of the component.
         */
        "model"?: LinkTileModelSignatureModel;
        /**
          * Adapts the font weight of the heading.
         */
        "weight"?: BreakpointCustomizable<LinkTileModelSignatureWeight>;
    }
    /**
     * @experimental 
     */
    interface PLinkTileProduct {
        /**
          * Aspect ratio of the link-tile-product.
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileProductAspectRatio>;
        /**
          * Additional product description
         */
        "description"?: string;
        /**
          * Product heading
         */
        "heading"?: string;
        /**
          * href of the `<a>`.
         */
        "href"?: string;
        /**
          * A Boolean attribute indicating that a like button should be shown.
         */
        "likeButton"?: boolean;
        /**
          * A Boolean attribute indicating that a product is liked.
         */
        "liked"?: boolean;
        /**
          * Emitted when the like button is clicked.
         */
        "onLike"?: (event: PLinkTileProductCustomEvent<LinkTileProductLikeEventDetail>) => void;
        /**
          * Product price
         */
        "price"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTileProductTarget;
        /**
          * Adapts the link-tile-product color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PLoadingBaseComponent {
        "loading"?: boolean;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-wordmark" instead.
     */
    interface PMarque {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<MarqueAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Adapts sizing of marque.
         */
        "size"?: MarqueSize;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: MarqueTarget;
        /**
          * Show/hide trademark sign (only has effect when variant is set to default).
         */
        "trademark"?: boolean;
        /**
          * Shows marque in special editions
         */
        "variant"?: MarqueVariant;
    }
    interface PModal {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ModalAriaAttribute>;
        /**
          * If true, the modal will not be closable via backdrop click.
         */
        "disableBackdropClick"?: boolean;
        /**
          * If true, the modal will not have a dismiss button.
          * @deprecated since v3.0.0, will be removed with next major release, use `dismissButton` instead.
         */
        "disableCloseButton"?: boolean;
        /**
          * If false, the modal will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * If true the modal uses max viewport height and width. Should only be used for mobile.
         */
        "fullscreen"?: BreakpointCustomizable<boolean>;
        /**
          * The title of the modal
         */
        "heading"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `dismiss` event instead. Emitted when the component requests to be dismissed.
         */
        "onClose"?: (event: PModalCustomEvent<void>) => void;
        /**
          * Emitted when the component requests to be dismissed.
         */
        "onDismiss"?: (event: PModalCustomEvent<void>) => void;
        /**
          * If true, the modal is open.
         */
        "open"?: boolean;
        /**
          * Adapts the modal color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PModelSignature {
        /**
          * Adapts the color of the component.
         */
        "color"?: ModelSignatureColor;
        /**
          * Adapts the model of the component.
         */
        "model"?: ModelSignatureModel;
        /**
          * Adapts the size of the component.
         */
        "size"?: ModelSignatureSize;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    interface PMultiSelect {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Disables the multi-select
         */
        "disabled"?: boolean;
        /**
          * Changes the direction to which the dropdown list appears.
         */
        "dropdownDirection"?: MultiSelectDropdownDirection;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The name of the control.
         */
        "name"?: string;
        /**
          * Emitted when the selection is changed.
         */
        "onUpdate"?: (event: PMultiSelectCustomEvent<MultiSelectUpdateEventDetail>) => void;
        /**
          * A Boolean attribute indicating that an option with a non-empty string value must be selected.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: MultiSelectState;
        /**
          * Adapts the select color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * The selected values.
         */
        "value"?: string[];
    }
    interface PMultiSelectOption {
        /**
          * Disables the option.
         */
        "disabled"?: boolean;
        /**
          * The option value.
         */
        "value"?: string;
    }
    interface PPagination {
        /**
          * Index of the currently active page.
         */
        "activePage"?: number;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.root` instead. Aria label what the pagination is used for.
         */
        "allyLabel"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.next` instead. Aria label for next page icon.
         */
        "allyLabelNext"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.page` instead. Aria label for page navigation.
         */
        "allyLabelPage"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.prev` instead. Aria label for previous page icon.
         */
        "allyLabelPrev"?: string;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev and page buttons.
         */
        "intl"?: PaginationInternationalization;
        /**
          * The total count of items which should be shown per page.
         */
        "itemsPerPage"?: number;
        /**
          * Has no effect anymore
          * @deprecated since v3.10.0, will be removed with next major release
         */
        "maxNumberOfPageLinks"?: BreakpointCustomizable<PaginationMaxNumberOfPageLinks>;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when the page changes.
         */
        "onPageChange"?: (event: PPaginationCustomEvent<PaginationUpdateEventDetail>) => void;
        /**
          * Emitted when the page changes.
         */
        "onUpdate"?: (event: PPaginationCustomEvent<PaginationUpdateEventDetail>) => void;
        /**
          * Show or hide the button to jump to the last page.
         */
        "showLastPage"?: boolean;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The total count of items.
         */
        "totalItemsCount"?: number;
    }
    interface PPinCode {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Disables the Pin Code. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label and description text. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * Number of characters of the Pin Code.
         */
        "length"?: PinCodeLength;
        /**
          * Disables the Pin Code and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Name of the control.
         */
        "name"?: string;
        /**
          * Emitted when selected element changes.
         */
        "onUpdate"?: (event: PPinCodeCustomEvent<PinCodeUpdateEventDetail>) => void;
        /**
          * Marks the Pin Code as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: PinCodeState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Pin Code type.
         */
        "type"?: PinCodeType;
        /**
          * Sets the initial value of the Pin Code.
         */
        "value"?: string;
    }
    interface PPopover {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<PopoverAriaAttribute>;
        /**
          * Descriptive text to show additional information when popover is open
         */
        "description"?: string;
        /**
          * Preferred direction in which popover should open, given there is enough space in viewport. Otherwise, it will be opened in the direction with most available space.
         */
        "direction"?: PopoverDirection;
        /**
          * Adapts the popover color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PRadioButtonWrapper {
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * @experimental Disables the radio button and shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: RadioButtonWrapperState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PScroller {
        /**
          * Sets the vertical position of scroll indicator.
         */
        "alignScrollIndicator"?: ScrollerAlignScrollIndicator;
        /**
          * Add ARIA role.
         */
        "aria"?: SelectedAriaAttributes<ScrollerAriaAttribute>;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColor"?: ScrollerGradientColor;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `gradientColor` instead. Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: ScrollerGradientColorScheme;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `alignScrollIndicator` instead. Sets the vertical position of scroll indicator
         */
        "scrollIndicatorPosition"?: ScrollerScrollIndicatorPosition;
        /**
          * Scrolls the scroll area to the left either smooth or immediately.
         */
        "scrollToPosition"?: ScrollerScrollToPosition;
        /**
          * Specifies if scrollbar should be shown.
         */
        "scrollbar"?: boolean;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PSegmentedControl {
        /**
          * @deprecated since v3.0.0, will be removed with next major release. Background color variations
         */
        "backgroundColor"?: SegmentedControlBackgroundColor;
        /**
          * Sets the amount of columns.
         */
        "columns"?: BreakpointCustomizable<SegmentedControlColumns>;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when selected element changes.
         */
        "onSegmentedControlChange"?: (event: PSegmentedControlCustomEvent<SegmentedControlUpdateEventDetail>) => void;
        /**
          * Emitted when selected element changes.
         */
        "onUpdate"?: (event: PSegmentedControlCustomEvent<SegmentedControlUpdateEventDetail>) => void;
        /**
          * Adapts the segmented-control color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Sets the initial value of the segmented-control.
         */
        "value"?: string | number;
    }
    interface PSegmentedControlItem {
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The icon shown.
         */
        "icon"?: SegmentedControlItemIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The value of this item which is emitted by the parent element if it becomes selected. This property is **required**.
         */
        "value"?: string | number;
    }
    interface PSelectWrapper {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Changes the direction to which the dropdown list appears.
         */
        "dropdownDirection"?: SelectWrapperDropdownDirection;
        /**
          * Filters select options by typing a character
         */
        "filter"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Forces rendering of native browser select dropdown
         */
        "native"?: boolean;
        /**
          * The validation state.
         */
        "state"?: SelectWrapperState;
        /**
          * Adapts the select color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PSelectWrapperDropdown {
        "description"?: string;
        "direction"?: SelectWrapperDropdownDirection;
        "disabled"?: boolean;
        "filter"?: boolean;
        "isOpenOverride"?: boolean;
        "label"?: string;
        "message"?: string;
        "onOpenChange"?: (isOpen: boolean) => void;
        "required"?: boolean;
        "selectRef"?: HTMLSelectElement;
        "state"?: SelectWrapperState;
        "theme"?: Theme;
    }
    interface PSpinner {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SpinnerAriaAttribute>;
        /**
          * Size of the spinner.
         */
        "size"?: BreakpointCustomizable<SpinnerSize>;
        /**
          * Adapts the spinner color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PStepperHorizontal {
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when active step is changed.
         */
        "onStepChange"?: (event: PStepperHorizontalCustomEvent<StepperHorizontalUpdateEventDetail>) => void;
        /**
          * Emitted when active step is changed.
         */
        "onUpdate"?: (event: PStepperHorizontalCustomEvent<StepperHorizontalUpdateEventDetail>) => void;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<StepperHorizontalSize>;
        /**
          * Adapts the tag color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PStepperHorizontalItem {
        /**
          * Disables the stepper-horizontal-item. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The validation state.
         */
        "state"?: StepperHorizontalItemState;
    }
    interface PSwitch {
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<SwitchAlignLabel>;
        /**
          * Visualize the switch with on/off status.
         */
        "checked"?: boolean;
        /**
          * Disables the switch. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Disables the switch and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when checked status is changed.
         */
        "onSwitchChange"?: (event: PSwitchCustomEvent<SwitchUpdateEventDetail>) => void;
        /**
          * Emitted when checked status is changed.
         */
        "onUpdate"?: (event: PSwitchCustomEvent<SwitchUpdateEventDetail>) => void;
        /**
          * Stretches the contents to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Adapts the switch color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PTable {
        /**
          * A caption describing the contents of the table for accessibility only. This won't be visible in the browser. Use an element with an attribute of `slot="caption"` for a visible caption.
         */
        "caption"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when sorting is changed.
         */
        "onSortingChange"?: (event: PTableCustomEvent<TableUpdateEventDetail>) => void;
        /**
          * Emitted when sorting is changed.
         */
        "onUpdate"?: (event: PTableCustomEvent<TableUpdateEventDetail>) => void;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PTableBody {
    }
    interface PTableCell {
        /**
          * Displays slotted text multiline or forced into a single line.
         */
        "multiline"?: boolean;
    }
    interface PTableHead {
    }
    interface PTableHeadCell {
        /**
          * Hides the label but stays accessible for screen readers. This property only takes effect when sort property is not defined.
         */
        "hideLabel"?: boolean;
        /**
          * Displays slotted text multiline or forced into a single line.
         */
        "multiline"?: boolean;
        /**
          * Defines sortability properties.
         */
        "sort"?: TableHeadCellSort;
    }
    interface PTableHeadRow {
    }
    interface PTableRow {
    }
    interface PTabs {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering).
         */
        "activeTabIndex"?: number;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColor"?: TabsGradientColor;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `gradientColor` instead. Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: TabsGradientColorScheme;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when active tab is changed.
         */
        "onTabChange"?: (event: PTabsCustomEvent<TabsUpdateEventDetail>) => void;
        /**
          * Emitted when active tab is changed.
         */
        "onUpdate"?: (event: PTabsCustomEvent<TabsUpdateEventDetail>) => void;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabsSize>;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The text weight.
         */
        "weight"?: TabsWeight;
    }
    interface PTabsBar {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering), undefined if none should be selected.
         */
        "activeTabIndex"?: number | undefined;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColor"?: TabsBarGradientColor;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `gradientColor` instead. Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: TabsBarGradientColorScheme;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when active tab is changed.
         */
        "onTabChange"?: (event: PTabsBarCustomEvent<TabsBarUpdateEventDetail>) => void;
        /**
          * Emitted when active tab is changed.
         */
        "onUpdate"?: (event: PTabsBarCustomEvent<TabsBarUpdateEventDetail>) => void;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabsBarSize>;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The text weight.
         */
        "weight"?: TabsBarWeight;
    }
    interface PTabsItem {
        /**
          * Defines the label used in tabs.
         */
        "label"?: string;
    }
    interface PTag {
        /**
          * Background color variations depending on theme property.
         */
        "color"?: TagColor;
        /**
          * The icon shown.
         */
        "icon"?: TagIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Adapts the tag color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PTagDismissible {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<TagDismissibleAriaAttribute>;
        /**
          * Background color variations
         */
        "color"?: TagDismissibleColor;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PText {
        /**
          * Text alignment of the component.
         */
        "align"?: TextAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: TextColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the text. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<TextSize>;
        /**
          * Sets a custom HTML tag depending on the usage of the text component.
         */
        "tag"?: TextTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
        /**
          * The weight of the text.
         */
        "weight"?: TextWeight;
    }
    interface PTextFieldWrapper {
        /**
          * Action icon can be set to `locate` for `input type="search"` in order to display an action button.
         */
        "actionIcon"?: TextFieldWrapperActionIcon;
        /**
          * Disables the action button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "actionLoading"?: boolean;
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Show or hide label and description text. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Emitted when the action button is clicked.
         */
        "onAction"?: (event: PTextFieldWrapperCustomEvent<void>) => void;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `showCounter` instead. Show or hide max character count.
         */
        "showCharacterCount"?: boolean;
        /**
          * Show or hide max character count.
         */
        "showCounter"?: boolean;
        /**
          * @experimental Show or hide password toggle for `input type="password"`.
         */
        "showPasswordToggle"?: boolean;
        /**
          * The validation state.
         */
        "state"?: TextFieldWrapperState;
        /**
          * Show search button if wrapped inside a form.
         */
        "submitButton"?: boolean;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * The unit text.
         */
        "unit"?: string;
        /**
          * The unit position.
         */
        "unitPosition"?: TextFieldWrapperUnitPosition;
    }
    interface PTextList {
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `type` instead. The type of the list.
         */
        "listType"?: TextListListType;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `type` instead. The list style type of ordered list. Only has effect when list type is set to 'ordered'.
         */
        "orderType"?: TextListOrderType;
        /**
          * Adapts the text color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * The list style type.
         */
        "type"?: TextListType;
    }
    interface PTextListItem {
    }
    interface PTextareaWrapper {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `showCounter` instead. Show or hide max character count.
         */
        "showCharacterCount"?: boolean;
        /**
          * Show or hide max character count.
         */
        "showCounter"?: boolean;
        /**
          * The validation state.
         */
        "state"?: TextareaWrapperState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PToast {
        /**
          * Adapts the toast color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PToastItem {
        /**
          * Emitted when the close button is clicked.
         */
        "onDismiss"?: (event: PToastItemCustomEvent<void>) => void;
        /**
          * State of the toast-item.
         */
        "state"?: ToastState;
        /**
          * Text of the toast-item.
         */
        "text"?: string;
        /**
          * Adapts the toast-item color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PWordmark {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<WordmarkAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Adapts sizing of wordmark.
         */
        "size"?: WordmarkSize;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: WordmarkTarget;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    interface IntrinsicElements {
        "p-accordion": PAccordion;
        "p-banner": PBanner;
        "p-button": PButton;
        "p-button-group": PButtonGroup;
        "p-button-pure": PButtonPure;
        "p-button-tile": PButtonTile;
        "p-carousel": PCarousel;
        "p-checkbox-wrapper": PCheckboxWrapper;
        "p-content-wrapper": PContentWrapper;
        "p-crest": PCrest;
        "p-display": PDisplay;
        "p-divider": PDivider;
        "p-fieldset": PFieldset;
        "p-fieldset-wrapper": PFieldsetWrapper;
        "p-flex": PFlex;
        "p-flex-item": PFlexItem;
        "p-flyout": PFlyout;
        "p-flyout-navigation": PFlyoutNavigation;
        "p-flyout-navigation-item": PFlyoutNavigationItem;
        "p-grid": PGrid;
        "p-grid-item": PGridItem;
        "p-heading": PHeading;
        "p-headline": PHeadline;
        "p-icon": PIcon;
        "p-inline-notification": PInlineNotification;
        "p-link": PLink;
        "p-link-pure": PLinkPure;
        "p-link-social": PLinkSocial;
        "p-link-tile": PLinkTile;
        "p-link-tile-model-signature": PLinkTileModelSignature;
        "p-link-tile-product": PLinkTileProduct;
        "p-loading-base-component": PLoadingBaseComponent;
        "p-marque": PMarque;
        "p-modal": PModal;
        "p-model-signature": PModelSignature;
        "p-multi-select": PMultiSelect;
        "p-multi-select-option": PMultiSelectOption;
        "p-pagination": PPagination;
        "p-pin-code": PPinCode;
        "p-popover": PPopover;
        "p-radio-button-wrapper": PRadioButtonWrapper;
        "p-scroller": PScroller;
        "p-segmented-control": PSegmentedControl;
        "p-segmented-control-item": PSegmentedControlItem;
        "p-select-wrapper": PSelectWrapper;
        "p-select-wrapper-dropdown": PSelectWrapperDropdown;
        "p-spinner": PSpinner;
        "p-stepper-horizontal": PStepperHorizontal;
        "p-stepper-horizontal-item": PStepperHorizontalItem;
        "p-switch": PSwitch;
        "p-table": PTable;
        "p-table-body": PTableBody;
        "p-table-cell": PTableCell;
        "p-table-head": PTableHead;
        "p-table-head-cell": PTableHeadCell;
        "p-table-head-row": PTableHeadRow;
        "p-table-row": PTableRow;
        "p-tabs": PTabs;
        "p-tabs-bar": PTabsBar;
        "p-tabs-item": PTabsItem;
        "p-tag": PTag;
        "p-tag-dismissible": PTagDismissible;
        "p-text": PText;
        "p-text-field-wrapper": PTextFieldWrapper;
        "p-text-list": PTextList;
        "p-text-list-item": PTextListItem;
        "p-textarea-wrapper": PTextareaWrapper;
        "p-toast": PToast;
        "p-toast-item": PToastItem;
        "p-wordmark": PWordmark;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "p-accordion": LocalJSX.PAccordion & JSXBase.HTMLAttributes<HTMLPAccordionElement>;
            "p-banner": LocalJSX.PBanner & JSXBase.HTMLAttributes<HTMLPBannerElement>;
            "p-button": LocalJSX.PButton & JSXBase.HTMLAttributes<HTMLPButtonElement>;
            "p-button-group": LocalJSX.PButtonGroup & JSXBase.HTMLAttributes<HTMLPButtonGroupElement>;
            "p-button-pure": LocalJSX.PButtonPure & JSXBase.HTMLAttributes<HTMLPButtonPureElement>;
            "p-button-tile": LocalJSX.PButtonTile & JSXBase.HTMLAttributes<HTMLPButtonTileElement>;
            "p-carousel": LocalJSX.PCarousel & JSXBase.HTMLAttributes<HTMLPCarouselElement>;
            "p-checkbox-wrapper": LocalJSX.PCheckboxWrapper & JSXBase.HTMLAttributes<HTMLPCheckboxWrapperElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
             */
            "p-content-wrapper": LocalJSX.PContentWrapper & JSXBase.HTMLAttributes<HTMLPContentWrapperElement>;
            "p-crest": LocalJSX.PCrest & JSXBase.HTMLAttributes<HTMLPCrestElement>;
            "p-display": LocalJSX.PDisplay & JSXBase.HTMLAttributes<HTMLPDisplayElement>;
            "p-divider": LocalJSX.PDivider & JSXBase.HTMLAttributes<HTMLPDividerElement>;
            "p-fieldset": LocalJSX.PFieldset & JSXBase.HTMLAttributes<HTMLPFieldsetElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Please use "p-fieldset" instead.
             */
            "p-fieldset-wrapper": LocalJSX.PFieldsetWrapper & JSXBase.HTMLAttributes<HTMLPFieldsetWrapperElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
             */
            "p-flex": LocalJSX.PFlex & JSXBase.HTMLAttributes<HTMLPFlexElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
             */
            "p-flex-item": LocalJSX.PFlexItem & JSXBase.HTMLAttributes<HTMLPFlexItemElement>;
            "p-flyout": LocalJSX.PFlyout & JSXBase.HTMLAttributes<HTMLPFlyoutElement>;
            /**
             * @experimental 
             */
            "p-flyout-navigation": LocalJSX.PFlyoutNavigation & JSXBase.HTMLAttributes<HTMLPFlyoutNavigationElement>;
            /**
             * @experimental 
             */
            "p-flyout-navigation-item": LocalJSX.PFlyoutNavigationItem & JSXBase.HTMLAttributes<HTMLPFlyoutNavigationItemElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
             */
            "p-grid": LocalJSX.PGrid & JSXBase.HTMLAttributes<HTMLPGridElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
             */
            "p-grid-item": LocalJSX.PGridItem & JSXBase.HTMLAttributes<HTMLPGridItemElement>;
            "p-heading": LocalJSX.PHeading & JSXBase.HTMLAttributes<HTMLPHeadingElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Please use "p-heading" instead.
             */
            "p-headline": LocalJSX.PHeadline & JSXBase.HTMLAttributes<HTMLPHeadlineElement>;
            "p-icon": LocalJSX.PIcon & JSXBase.HTMLAttributes<HTMLPIconElement>;
            "p-inline-notification": LocalJSX.PInlineNotification & JSXBase.HTMLAttributes<HTMLPInlineNotificationElement>;
            "p-link": LocalJSX.PLink & JSXBase.HTMLAttributes<HTMLPLinkElement>;
            "p-link-pure": LocalJSX.PLinkPure & JSXBase.HTMLAttributes<HTMLPLinkPureElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Use `p-link` with corresponding social icon instead.
             */
            "p-link-social": LocalJSX.PLinkSocial & JSXBase.HTMLAttributes<HTMLPLinkSocialElement>;
            "p-link-tile": LocalJSX.PLinkTile & JSXBase.HTMLAttributes<HTMLPLinkTileElement>;
            "p-link-tile-model-signature": LocalJSX.PLinkTileModelSignature & JSXBase.HTMLAttributes<HTMLPLinkTileModelSignatureElement>;
            /**
             * @experimental 
             */
            "p-link-tile-product": LocalJSX.PLinkTileProduct & JSXBase.HTMLAttributes<HTMLPLinkTileProductElement>;
            "p-loading-base-component": LocalJSX.PLoadingBaseComponent & JSXBase.HTMLAttributes<HTMLPLoadingBaseComponentElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Please use "p-wordmark" instead.
             */
            "p-marque": LocalJSX.PMarque & JSXBase.HTMLAttributes<HTMLPMarqueElement>;
            "p-modal": LocalJSX.PModal & JSXBase.HTMLAttributes<HTMLPModalElement>;
            "p-model-signature": LocalJSX.PModelSignature & JSXBase.HTMLAttributes<HTMLPModelSignatureElement>;
            "p-multi-select": LocalJSX.PMultiSelect & JSXBase.HTMLAttributes<HTMLPMultiSelectElement>;
            "p-multi-select-option": LocalJSX.PMultiSelectOption & JSXBase.HTMLAttributes<HTMLPMultiSelectOptionElement>;
            "p-pagination": LocalJSX.PPagination & JSXBase.HTMLAttributes<HTMLPPaginationElement>;
            "p-pin-code": LocalJSX.PPinCode & JSXBase.HTMLAttributes<HTMLPPinCodeElement>;
            "p-popover": LocalJSX.PPopover & JSXBase.HTMLAttributes<HTMLPPopoverElement>;
            "p-radio-button-wrapper": LocalJSX.PRadioButtonWrapper & JSXBase.HTMLAttributes<HTMLPRadioButtonWrapperElement>;
            "p-scroller": LocalJSX.PScroller & JSXBase.HTMLAttributes<HTMLPScrollerElement>;
            "p-segmented-control": LocalJSX.PSegmentedControl & JSXBase.HTMLAttributes<HTMLPSegmentedControlElement>;
            "p-segmented-control-item": LocalJSX.PSegmentedControlItem & JSXBase.HTMLAttributes<HTMLPSegmentedControlItemElement>;
            "p-select-wrapper": LocalJSX.PSelectWrapper & JSXBase.HTMLAttributes<HTMLPSelectWrapperElement>;
            "p-select-wrapper-dropdown": LocalJSX.PSelectWrapperDropdown & JSXBase.HTMLAttributes<HTMLPSelectWrapperDropdownElement>;
            "p-spinner": LocalJSX.PSpinner & JSXBase.HTMLAttributes<HTMLPSpinnerElement>;
            "p-stepper-horizontal": LocalJSX.PStepperHorizontal & JSXBase.HTMLAttributes<HTMLPStepperHorizontalElement>;
            "p-stepper-horizontal-item": LocalJSX.PStepperHorizontalItem & JSXBase.HTMLAttributes<HTMLPStepperHorizontalItemElement>;
            "p-switch": LocalJSX.PSwitch & JSXBase.HTMLAttributes<HTMLPSwitchElement>;
            "p-table": LocalJSX.PTable & JSXBase.HTMLAttributes<HTMLPTableElement>;
            "p-table-body": LocalJSX.PTableBody & JSXBase.HTMLAttributes<HTMLPTableBodyElement>;
            "p-table-cell": LocalJSX.PTableCell & JSXBase.HTMLAttributes<HTMLPTableCellElement>;
            "p-table-head": LocalJSX.PTableHead & JSXBase.HTMLAttributes<HTMLPTableHeadElement>;
            "p-table-head-cell": LocalJSX.PTableHeadCell & JSXBase.HTMLAttributes<HTMLPTableHeadCellElement>;
            "p-table-head-row": LocalJSX.PTableHeadRow & JSXBase.HTMLAttributes<HTMLPTableHeadRowElement>;
            "p-table-row": LocalJSX.PTableRow & JSXBase.HTMLAttributes<HTMLPTableRowElement>;
            "p-tabs": LocalJSX.PTabs & JSXBase.HTMLAttributes<HTMLPTabsElement>;
            "p-tabs-bar": LocalJSX.PTabsBar & JSXBase.HTMLAttributes<HTMLPTabsBarElement>;
            "p-tabs-item": LocalJSX.PTabsItem & JSXBase.HTMLAttributes<HTMLPTabsItemElement>;
            "p-tag": LocalJSX.PTag & JSXBase.HTMLAttributes<HTMLPTagElement>;
            "p-tag-dismissible": LocalJSX.PTagDismissible & JSXBase.HTMLAttributes<HTMLPTagDismissibleElement>;
            "p-text": LocalJSX.PText & JSXBase.HTMLAttributes<HTMLPTextElement>;
            "p-text-field-wrapper": LocalJSX.PTextFieldWrapper & JSXBase.HTMLAttributes<HTMLPTextFieldWrapperElement>;
            "p-text-list": LocalJSX.PTextList & JSXBase.HTMLAttributes<HTMLPTextListElement>;
            "p-text-list-item": LocalJSX.PTextListItem & JSXBase.HTMLAttributes<HTMLPTextListItemElement>;
            "p-textarea-wrapper": LocalJSX.PTextareaWrapper & JSXBase.HTMLAttributes<HTMLPTextareaWrapperElement>;
            "p-toast": LocalJSX.PToast & JSXBase.HTMLAttributes<HTMLPToastElement>;
            "p-toast-item": LocalJSX.PToastItem & JSXBase.HTMLAttributes<HTMLPToastItemElement>;
            "p-wordmark": LocalJSX.PWordmark & JSXBase.HTMLAttributes<HTMLPWordmarkElement>;
        }
    }
}
