/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { BreakpointCustomizable, ButtonAriaAttribute, ButtonType, ButtonVariant, FlagName, HeadingSize, HeadingTag, IconName, LinkAriaAttribute, LinkTarget, LinkVariant, SelectedAriaAttributes, SelectedAriaRole, TextSize } from "./types";
import { AccordionHeadingTag, AccordionSize, AccordionUpdateEventDetail } from "./components/accordion/accordion-utils";
import { BannerHeadingTag, BannerState } from "./components/banner/banner-utils";
import { ButtonIcon } from "./components/button/button-utils";
import { ButtonPureAlignLabel, ButtonPureAriaAttribute, ButtonPureIcon, ButtonPureSize, ButtonPureType } from "./components/button-pure/button-pure-utils";
import { ButtonTileAlign, ButtonTileAriaAttribute, ButtonTileAspectRatio, ButtonTileIcon, ButtonTileSize, ButtonTileType, ButtonTileWeight } from "./components/button-tile/button-tile-utils";
import { CanvasBackground, CanvasSidebarStartUpdateEventDetail } from "./components/canvas/canvas-utils";
import { CarouselAlignControls, CarouselAlignHeader, CarouselAriaAttribute, CarouselHeadingSize, CarouselInternationalization, CarouselSlidesPerPage, CarouselUpdateEventDetail, CarouselWidth } from "./components/carousel/carousel-utils";
import { CheckboxBlurEventDetail, CheckboxChangeEventDetail, CheckboxState } from "./components/checkbox/checkbox-utils";
import { CrestAriaAttribute, CrestTarget } from "./components/crest/crest-utils";
import { DisplayAlign, DisplayColor, DisplaySize, DisplayTag } from "./components/display/display-utils";
import { DividerColor, DividerDirection } from "./components/divider/divider-utils";
import { DrilldownAriaAttribute, DrilldownUpdateEventDetail } from "./components/drilldown/drilldown/drilldown-utils";
import { DrilldownLinkAriaAttribute, DrilldownLinkTarget } from "./components/drilldown/drilldown-link/drilldown-link-utils";
import { FieldsetLabelSize, FieldsetState } from "./components/fieldset/fieldset-utils";
import { FlagAriaAttribute, FlagSize } from "./components/flag/flag-utils";
import { FlyoutAriaAttribute, FlyoutBackdrop, FlyoutBackground, FlyoutFooterBehavior, FlyoutMotionHiddenEndEventDetail, FlyoutMotionVisibleEndEventDetail, FlyoutPosition } from "./components/flyout/flyout-utils";
import { HeadingAlign, HeadingColor } from "./components/heading/heading-utils";
import { IconAriaAttribute, IconColor, IconSize } from "./components/icon/icon-utils";
import { InlineNotificationActionIcon, InlineNotificationHeadingTag, InlineNotificationState } from "./components/inline-notification/inline-notification-utils";
import { InputDateBlurEventDetail, InputDateChangeEventDetail, InputDateInputEventDetail, InputDateState } from "./components/input-date/input-date-utils";
import { InputEmailBlurEventDetail, InputEmailChangeEventDetail, InputEmailInputEventDetail, InputEmailState } from "./components/input-email/input-email-utils";
import { InputMonthBlurEventDetail, InputMonthChangeEventDetail, InputMonthInputEventDetail, InputMonthState } from "./components/input-month/input-month-utils";
import { InputNumberBlurEventDetail, InputNumberChangeEventDetail, InputNumberInputEventDetail, InputNumberState } from "./components/input-number/input-number-utils";
import { InputPasswordBlurEventDetail, InputPasswordChangeEventDetail, InputPasswordInputEventDetail, InputPasswordState } from "./components/input-password/input-password-utils";
import { InputSearchBlurEventDetail, InputSearchChangeEventDetail, InputSearchInputEventDetail, InputSearchState } from "./components/input-search/input-search-utils";
import { InputTelBlurEventDetail, InputTelChangeEventDetail, InputTelInputEventDetail, InputTelState } from "./components/input-tel/input-tel-utils";
import { InputTextBlurEventDetail, InputTextChangeEventDetail, InputTextInputEventDetail, InputTextState } from "./components/input-text/input-text-utils";
import { InputTimeBlurEventDetail, InputTimeChangeEventDetail, InputTimeInputEventDetail, InputTimeState } from "./components/input-time/input-time-utils";
import { InputUrlBlurEventDetail, InputUrlChangeEventDetail, InputUrlInputEventDetail, InputUrlState } from "./components/input-url/input-url-utils";
import { InputWeekBlurEventDetail, InputWeekChangeEventDetail, InputWeekInputEventDetail, InputWeekState } from "./components/input-week/input-week-utils";
import { LinkIcon } from "./components/link/link-utils";
import { LinkPureAlignLabel, LinkPureAriaAttribute, LinkPureIcon, LinkPureSize, LinkPureTarget } from "./components/link-pure/link-pure-utils";
import { LinkTileAlign, LinkTileAriaAttribute, LinkTileAspectRatio, LinkTileSize, LinkTileTarget, LinkTileWeight } from "./components/link-tile/link-tile-utils";
import { LinkTileProductAspectRatio, LinkTileProductLikeEventDetail, LinkTileProductTarget } from "./components/link-tile-product/link-tile-product-utils";
import { ModalAriaAttribute, ModalBackdrop, ModalBackground, ModalMotionHiddenEndEventDetail, ModalMotionVisibleEndEventDetail } from "./components/modal/modal-utils";
import { ModelSignatureColor, ModelSignatureFetchPriority, ModelSignatureModel, ModelSignatureSize } from "./components/model-signature/model-signature-utils";
import { MultiSelectChangeEventDetail, MultiSelectDropdownDirection, MultiSelectState, MultiSelectToggleEventDetail } from "./components/multi-select/multi-select/multi-select-utils";
import { PaginationInternationalization, PaginationUpdateEventDetail } from "./components/pagination/pagination-utils";
import { PinCodeChangeEventDetail, PinCodeLength, PinCodeState, PinCodeType } from "./components/pin-code/pin-code-utils";
import { PopoverAriaAttribute, PopoverDirection } from "./components/popover/popover-utils";
import { RadioGroupChangeEventDetail, RadioGroupDirection, RadioGroupState } from "./components/radio-group/radio-group/radio-group-utils";
import { ScrollerAlignScrollIndicator, ScrollerAriaAttribute, ScrollerScrollToPosition } from "./components/scroller/scroller-utils";
import { SegmentedControlChangeEventDetail, SegmentedControlColumns, SegmentedControlState } from "./components/segmented-control/segmented-control/segmented-control-utils";
import { SegmentedControlItemAriaAttribute, SegmentedControlItemIcon } from "./components/segmented-control/segmented-control-item/segmented-control-item-utils";
import { SelectChangeEventDetail, SelectDropdownDirection, SelectState, SelectToggleEventDetail } from "./components/select/select/select-utils";
import { SheetAriaAttribute, SheetBackground, SheetMotionHiddenEndEventDetail, SheetMotionVisibleEndEventDetail } from "./components/sheet/sheet-utils";
import { SpinnerAriaAttribute, SpinnerSize } from "./components/spinner/spinner-utils";
import { StepperHorizontalSize, StepperHorizontalUpdateEventDetail } from "./components/stepper-horizontal/stepper-horizontal/stepper-horizontal-utils";
import { StepperHorizontalItemState } from "./components/stepper-horizontal/stepper-horizontal-item/stepper-horizontal-item-utils";
import { SwitchAlignLabel, SwitchUpdateEventDetail } from "./components/switch/switch-utils";
import { TableHeadCellSort, TableLayout, TableUpdateEventDetail } from "./components/table/table/table-utils";
import { TabsSize, TabsUpdateEventDetail, TabsWeight } from "./components/tabs/tabs/tabs-utils";
import { TabsBarSize, TabsBarUpdateEventDetail, TabsBarWeight } from "./components/tabs-bar/tabs-bar-utils";
import { TagIcon, TagVariant } from "./components/tag/tag-utils";
import { TagDismissibleAriaAttribute } from "./components/tag-dismissible/tag-dismissible-utils";
import { TextAlign, TextColor, TextTag, TextWeight } from "./components/text/text-utils";
import { TextListType } from "./components/text-list/text-list/text-list-utils";
import { TextareaBlurEventDetail, TextareaChangeEventDetail, TextareaInputEventDetail, TextareaResize, TextareaState, TextareaWrap } from "./components/textarea/textarea-utils";
import { ToastMessage } from "./components/toast/toast/toast-manager";
import { ToastState } from "./components/toast/toast/toast-utils";
import { WordmarkAriaAttribute, WordmarkSize, WordmarkTarget } from "./components/wordmark/wordmark-utils";
export { BreakpointCustomizable, ButtonAriaAttribute, ButtonType, ButtonVariant, FlagName, HeadingSize, HeadingTag, IconName, LinkAriaAttribute, LinkTarget, LinkVariant, SelectedAriaAttributes, SelectedAriaRole, TextSize } from "./types";
export { AccordionHeadingTag, AccordionSize, AccordionUpdateEventDetail } from "./components/accordion/accordion-utils";
export { BannerHeadingTag, BannerState } from "./components/banner/banner-utils";
export { ButtonIcon } from "./components/button/button-utils";
export { ButtonPureAlignLabel, ButtonPureAriaAttribute, ButtonPureIcon, ButtonPureSize, ButtonPureType } from "./components/button-pure/button-pure-utils";
export { ButtonTileAlign, ButtonTileAriaAttribute, ButtonTileAspectRatio, ButtonTileIcon, ButtonTileSize, ButtonTileType, ButtonTileWeight } from "./components/button-tile/button-tile-utils";
export { CanvasBackground, CanvasSidebarStartUpdateEventDetail } from "./components/canvas/canvas-utils";
export { CarouselAlignControls, CarouselAlignHeader, CarouselAriaAttribute, CarouselHeadingSize, CarouselInternationalization, CarouselSlidesPerPage, CarouselUpdateEventDetail, CarouselWidth } from "./components/carousel/carousel-utils";
export { CheckboxBlurEventDetail, CheckboxChangeEventDetail, CheckboxState } from "./components/checkbox/checkbox-utils";
export { CrestAriaAttribute, CrestTarget } from "./components/crest/crest-utils";
export { DisplayAlign, DisplayColor, DisplaySize, DisplayTag } from "./components/display/display-utils";
export { DividerColor, DividerDirection } from "./components/divider/divider-utils";
export { DrilldownAriaAttribute, DrilldownUpdateEventDetail } from "./components/drilldown/drilldown/drilldown-utils";
export { DrilldownLinkAriaAttribute, DrilldownLinkTarget } from "./components/drilldown/drilldown-link/drilldown-link-utils";
export { FieldsetLabelSize, FieldsetState } from "./components/fieldset/fieldset-utils";
export { FlagAriaAttribute, FlagSize } from "./components/flag/flag-utils";
export { FlyoutAriaAttribute, FlyoutBackdrop, FlyoutBackground, FlyoutFooterBehavior, FlyoutMotionHiddenEndEventDetail, FlyoutMotionVisibleEndEventDetail, FlyoutPosition } from "./components/flyout/flyout-utils";
export { HeadingAlign, HeadingColor } from "./components/heading/heading-utils";
export { IconAriaAttribute, IconColor, IconSize } from "./components/icon/icon-utils";
export { InlineNotificationActionIcon, InlineNotificationHeadingTag, InlineNotificationState } from "./components/inline-notification/inline-notification-utils";
export { InputDateBlurEventDetail, InputDateChangeEventDetail, InputDateInputEventDetail, InputDateState } from "./components/input-date/input-date-utils";
export { InputEmailBlurEventDetail, InputEmailChangeEventDetail, InputEmailInputEventDetail, InputEmailState } from "./components/input-email/input-email-utils";
export { InputMonthBlurEventDetail, InputMonthChangeEventDetail, InputMonthInputEventDetail, InputMonthState } from "./components/input-month/input-month-utils";
export { InputNumberBlurEventDetail, InputNumberChangeEventDetail, InputNumberInputEventDetail, InputNumberState } from "./components/input-number/input-number-utils";
export { InputPasswordBlurEventDetail, InputPasswordChangeEventDetail, InputPasswordInputEventDetail, InputPasswordState } from "./components/input-password/input-password-utils";
export { InputSearchBlurEventDetail, InputSearchChangeEventDetail, InputSearchInputEventDetail, InputSearchState } from "./components/input-search/input-search-utils";
export { InputTelBlurEventDetail, InputTelChangeEventDetail, InputTelInputEventDetail, InputTelState } from "./components/input-tel/input-tel-utils";
export { InputTextBlurEventDetail, InputTextChangeEventDetail, InputTextInputEventDetail, InputTextState } from "./components/input-text/input-text-utils";
export { InputTimeBlurEventDetail, InputTimeChangeEventDetail, InputTimeInputEventDetail, InputTimeState } from "./components/input-time/input-time-utils";
export { InputUrlBlurEventDetail, InputUrlChangeEventDetail, InputUrlInputEventDetail, InputUrlState } from "./components/input-url/input-url-utils";
export { InputWeekBlurEventDetail, InputWeekChangeEventDetail, InputWeekInputEventDetail, InputWeekState } from "./components/input-week/input-week-utils";
export { LinkIcon } from "./components/link/link-utils";
export { LinkPureAlignLabel, LinkPureAriaAttribute, LinkPureIcon, LinkPureSize, LinkPureTarget } from "./components/link-pure/link-pure-utils";
export { LinkTileAlign, LinkTileAriaAttribute, LinkTileAspectRatio, LinkTileSize, LinkTileTarget, LinkTileWeight } from "./components/link-tile/link-tile-utils";
export { LinkTileProductAspectRatio, LinkTileProductLikeEventDetail, LinkTileProductTarget } from "./components/link-tile-product/link-tile-product-utils";
export { ModalAriaAttribute, ModalBackdrop, ModalBackground, ModalMotionHiddenEndEventDetail, ModalMotionVisibleEndEventDetail } from "./components/modal/modal-utils";
export { ModelSignatureColor, ModelSignatureFetchPriority, ModelSignatureModel, ModelSignatureSize } from "./components/model-signature/model-signature-utils";
export { MultiSelectChangeEventDetail, MultiSelectDropdownDirection, MultiSelectState, MultiSelectToggleEventDetail } from "./components/multi-select/multi-select/multi-select-utils";
export { PaginationInternationalization, PaginationUpdateEventDetail } from "./components/pagination/pagination-utils";
export { PinCodeChangeEventDetail, PinCodeLength, PinCodeState, PinCodeType } from "./components/pin-code/pin-code-utils";
export { PopoverAriaAttribute, PopoverDirection } from "./components/popover/popover-utils";
export { RadioGroupChangeEventDetail, RadioGroupDirection, RadioGroupState } from "./components/radio-group/radio-group/radio-group-utils";
export { ScrollerAlignScrollIndicator, ScrollerAriaAttribute, ScrollerScrollToPosition } from "./components/scroller/scroller-utils";
export { SegmentedControlChangeEventDetail, SegmentedControlColumns, SegmentedControlState } from "./components/segmented-control/segmented-control/segmented-control-utils";
export { SegmentedControlItemAriaAttribute, SegmentedControlItemIcon } from "./components/segmented-control/segmented-control-item/segmented-control-item-utils";
export { SelectChangeEventDetail, SelectDropdownDirection, SelectState, SelectToggleEventDetail } from "./components/select/select/select-utils";
export { SheetAriaAttribute, SheetBackground, SheetMotionHiddenEndEventDetail, SheetMotionVisibleEndEventDetail } from "./components/sheet/sheet-utils";
export { SpinnerAriaAttribute, SpinnerSize } from "./components/spinner/spinner-utils";
export { StepperHorizontalSize, StepperHorizontalUpdateEventDetail } from "./components/stepper-horizontal/stepper-horizontal/stepper-horizontal-utils";
export { StepperHorizontalItemState } from "./components/stepper-horizontal/stepper-horizontal-item/stepper-horizontal-item-utils";
export { SwitchAlignLabel, SwitchUpdateEventDetail } from "./components/switch/switch-utils";
export { TableHeadCellSort, TableLayout, TableUpdateEventDetail } from "./components/table/table/table-utils";
export { TabsSize, TabsUpdateEventDetail, TabsWeight } from "./components/tabs/tabs/tabs-utils";
export { TabsBarSize, TabsBarUpdateEventDetail, TabsBarWeight } from "./components/tabs-bar/tabs-bar-utils";
export { TagIcon, TagVariant } from "./components/tag/tag-utils";
export { TagDismissibleAriaAttribute } from "./components/tag-dismissible/tag-dismissible-utils";
export { TextAlign, TextColor, TextTag, TextWeight } from "./components/text/text-utils";
export { TextListType } from "./components/text-list/text-list/text-list-utils";
export { TextareaBlurEventDetail, TextareaChangeEventDetail, TextareaInputEventDetail, TextareaResize, TextareaState, TextareaWrap } from "./components/textarea/textarea-utils";
export { ToastMessage } from "./components/toast/toast/toast-manager";
export { ToastState } from "./components/toast/toast/toast-utils";
export { WordmarkAriaAttribute, WordmarkSize, WordmarkTarget } from "./components/wordmark/wordmark-utils";
export namespace Components {
    /**
     * @controlled {"props": ["open"], "event": "update"}
     */
    interface PAccordion {
        /**
          * Displays the Accordion as compact version with thinner border and smaller paddings.
         */
        "compact"?: boolean;
        /**
          * Defines the heading used in accordion.
         */
        "heading"?: string;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
          * @default 'h2'
         */
        "headingTag"?: AccordionHeadingTag;
        /**
          * Defines if accordion is open.
         */
        "open"?: boolean;
        /**
          * The text size.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<AccordionSize>;
        /**
          * @experimental Sticks the Accordion heading at the top, fixed while scrolling
         */
        "sticky"?: boolean;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PBanner {
        /**
          * Description of the banner.
          * @default ''
         */
        "description"?: string;
        /**
          * If false, the banner will not have a dismiss button.
          * @default true
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the banner.
          * @default ''
         */
        "heading"?: string;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
          * @default 'h5'
         */
        "headingTag"?: BannerHeadingTag;
        /**
          * If true, the banner is open.
          * @default false
         */
        "open": boolean;
        /**
          * State of the banner.
          * @default 'info'
         */
        "state"?: BannerState;
    }
    interface PButton {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonAriaAttribute>;
        /**
          * Displays as compact version.
          * @default false
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the button should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
          * @default 'none'
         */
        "icon"?: ButtonIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
          * @default false
         */
        "loading"?: boolean;
        /**
          * The name of the button, submitted as a pair with the button's value as part of the form data, when that button is used to submit the form.
         */
        "name"?: string;
        /**
          * Specifies the type of the button.
          * @default 'submit'
         */
        "type"?: ButtonType;
        /**
          * Defines the value associated with the button's name when it's submitted with the form data. This value is passed to the server in params when the form is submitted using this button.
         */
        "value"?: string;
        /**
          * The style variant of the button.
          * @default 'primary'
         */
        "variant"?: ButtonVariant;
    }
    interface PButtonPure {
        /**
          * Display button in active state.
          * @default false
         */
        "active"?: boolean;
        /**
          * Aligns the label.
          * @default 'end'
         */
        "alignLabel"?: BreakpointCustomizable<ButtonPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonPureAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the button should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown.
          * @default 'arrow-right'
         */
        "icon"?: ButtonPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
          * @default false
         */
        "loading"?: boolean;
        /**
          * The name of the button, submitted as a pair with the button's value as part of the form data, when that button is used to submit the form.
         */
        "name"?: string;
        /**
          * Size of the button.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<ButtonPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
          * @default false
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Specifies the type of the button.
          * @default 'submit'
         */
        "type"?: ButtonPureType;
        /**
          * Shows an underline under the label.
          * @default false
         */
        "underline"?: boolean;
        /**
          * Defines the value associated with the button's name when it's submitted with the form data. This value is passed to the server in params when the form is submitted using this button.
         */
        "value"?: string;
    }
    interface PButtonTile {
        /**
          * Alignment of button and description.
          * @default 'bottom'
         */
        "align"?: ButtonTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonTileAriaAttribute>;
        /**
          * Aspect ratio of the button-tile.
          * @default '4/3'
         */
        "aspectRatio"?: BreakpointCustomizable<ButtonTileAspectRatio>;
        /**
          * Displays the button-tile as compact version with description and button icon only.
          * @default false
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description": string;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Show gradient.
          * @default false
         */
        "gradient"?: boolean;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
          * @default 'none'
         */
        "icon"?: ButtonTileIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Label of the button.
         */
        "label": string;
        /**
          * Disables the button-tile and shows a loading indicator. No events will be triggered while loading state is active.
          * @default false
         */
        "loading"?: boolean;
        /**
          * Font size of the description.
          * @default 'medium'
         */
        "size"?: BreakpointCustomizable<ButtonTileSize>;
        /**
          * Specifies the type of the button.
          * @default 'submit'
         */
        "type"?: ButtonTileType;
        /**
          * Font weight of the description.
          * @default 'semi-bold'
         */
        "weight"?: BreakpointCustomizable<ButtonTileWeight>;
    }
    /**
     * @experimental 
     */
    interface PCanvas {
        /**
          * Defines the background color of the main section and auto adjust it for the sidebar
          * @default 'canvas'
         */
        "background"?: CanvasBackground;
        /**
          * Open the sidebar on the end side
          * @default false
         */
        "sidebarEndOpen"?: boolean;
        /**
          * Open the sidebar on the start side
          * @default false
         */
        "sidebarStartOpen"?: boolean;
    }
    /**
     * @controlled { "props": ["activeSlideIndex"], "event": "update", "isInternallyMutated": true }
     */
    interface PCarousel {
        /**
          * Defines which slide to be active (zero-based numbering).
          * @default 0
         */
        "activeSlideIndex"?: number;
        /**
          * Alignment of slotted controls
          * @default 'auto'
         */
        "alignControls"?: CarouselAlignControls;
        /**
          * Alignment of heading and description
          * @default 'start'
         */
        "alignHeader"?: CarouselAlignHeader;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<CarouselAriaAttribute>;
        /**
          * Defines the description used in the carousel.
         */
        "description"?: string;
        /**
          * Indicates whether focus should be set on the center slide. If true, the carousel loops by individual slide; otherwise, it loops by page.
          * @default false
         */
        "focusOnCenterSlide"?: boolean;
        /**
          * Fades the slides out.
          * @default false
         */
        "gradient"?: boolean;
        /**
          * Defines the heading used in the carousel.
         */
        "heading"?: string;
        /**
          * Defines the heading size used in the carousel.
          * @default 'x-large'
         */
        "headingSize"?: CarouselHeadingSize;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev buttons and pagination.
         */
        "intl"?: CarouselInternationalization;
        /**
          * If false, the carousel will not show pagination bullets at the bottom.
          * @default false
         */
        "pagination"?: BreakpointCustomizable<boolean>;
        /**
          * Whether the slides should rewind from last to first slide and vice versa.
          * @default false
         */
        "rewind"?: boolean;
        /**
          * Defines target of skip link (to skip carousel entries).
         */
        "skipLinkTarget"?: string;
        /**
          * Sets the amount of slides visible at the same time. Can be set to `auto` if you want to define different widths per slide via CSS.
          * @default 1
         */
        "slidesPerPage"?: BreakpointCustomizable<CarouselSlidesPerPage>;
        /**
          * Determines whether to trim spaces before/after the carousel if `focusOnCenterSlide` option is true.
          * @default false
         */
        "trimSpace"?: boolean;
        /**
          * Defines the outer spacings between the carousel and the left and right screen sides.
          * @default 'basic'
         */
        "width"?: CarouselWidth;
    }
    interface PCheckbox {
        /**
          * Reflects the checkbox current checked state and allows setting the initial checked state.
          * @default false
         */
        "checked"?: boolean;
        /**
          * Displays as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Marks the checkbox as disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the checkbox should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility, it's recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Marks the checkbox as indeterminate.
          * @default false
         */
        "indeterminate"?: boolean;
        /**
          * The label text.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Disables the checkbox and shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
          * @default ''
         */
        "message"?: string;
        /**
          * The name of the checkbox.
          * @default ''
         */
        "name"?: string;
        /**
          * Marks the checkbox as required.
          * @default false
         */
        "required"?: boolean;
        /**
          * The validation state.
          * @default 'none'
         */
        "state"?: CheckboxState;
        /**
          * The checkbox value. When a form is submitted, only a checkbox which is currently checked is included in the submission.
          * @default 'on'
         */
        "value"?: string;
    }
    interface PCrest {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<CrestAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Target attribute where the link should be opened.
          * @default '_self'
         */
        "target"?: CrestTarget;
    }
    interface PDisplay {
        /**
          * Text alignment of the component.
          * @default 'start'
         */
        "align"?: DisplayAlign;
        /**
          * Basic text color variations.
          * @default 'primary'
         */
        "color"?: DisplayColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
          * @default false
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "medium", l: "large"}. You always need to provide a base value when doing this.
          * @default 'large'
         */
        "size"?: BreakpointCustomizable<DisplaySize>;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
         */
        "tag"?: DisplayTag;
    }
    interface PDivider {
        /**
          * Defines color.
          * @default 'contrast-lower'
         */
        "color"?: DividerColor;
        /**
          * Defines direction.
          * @default 'horizontal'
         */
        "direction"?: BreakpointCustomizable<DividerDirection>;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     * @controlled {"props": ["activeIdentifier"], "event": "update"}
     * @experimental 
     */
    interface PDrilldown {
        /**
          * Defines which drilldown-item to be visualized as opened.
         */
        "activeIdentifier"?: string | undefined;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<DrilldownAriaAttribute>;
        /**
          * If true, the drilldown is visualized as opened.
          * @default false
         */
        "open"?: boolean;
    }
    /**
     * @experimental 
     */
    interface PDrilldownItem {
        /**
          * Private property set by the component itself.
          * @default false
         */
        "cascade"?: boolean;
        /**
          * Unique identifier which controls if this item should be shown when the active-identifier on the drilldown is set to this value.
         */
        "identifier": string;
        /**
          * Renders back button, header section on mobile view and cascade button to reach a deeper level of the navigation structure.
         */
        "label"?: string;
        /**
          * Private property set by the component itself.
          * @default false
         */
        "primary"?: boolean;
        /**
          * Private property set by the component itself.
          * @default false
         */
        "secondary"?: boolean;
    }
    /**
     * @experimental 
     */
    interface PDrilldownLink {
        /**
          * Display link in active state.
          * @default false
         */
        "active"?: boolean;
        /**
          * Add ARIA attributes (only has effect when `href` is defined and no slotted anchor is used).
         */
        "aria"?: SelectedAriaAttributes<DrilldownLinkAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file (only has effect when `href` is defined and no slotted anchor is used).
         */
        "download"?: string;
        /**
          * When providing an url then the component will be rendered as `<a>` otherwise the component expects a slotted anchor.
         */
        "href"?: string;
        /**
          * Specifies the relationship of the target object to the link object (only has effect when `href` is defined and no slotted anchor is used).
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened (only has effect when `href` is defined and no slotted anchor is used).
          * @default '_self'
         */
        "target"?: DrilldownLinkTarget;
    }
    interface PFieldset {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaRole<'radiogroup'>;
        /**
          * The label text.
          * @default ''
         */
        "label"?: string;
        /**
          * The size of the label text.
          * @default 'medium'
         */
        "labelSize"?: FieldsetLabelSize;
        /**
          * The message styled depending on validation state.
          * @default ''
         */
        "message"?: string;
        /**
          * Marks the Fieldset as required.
          * @default false
         */
        "required"?: boolean;
        /**
          * The validation state.
          * @default 'none'
         */
        "state"?: FieldsetState;
    }
    interface PFlag {
        /**
          * A map of ARIA attributes to enhance the flag's accessibility. For example, use `{ 'aria-label': 'German flag' }` to provide a descriptive label for screen readers.
         */
        "aria"?: SelectedAriaAttributes<FlagAriaAttribute>;
        /**
          * Specifies the country flag to display. Use the two-letter ISO 3166-1 alpha-2 country code. For example, use `us` for the United States, `de` for Germany, `gb` for Great Britain.
          * @default 'de'
         */
        "name"?: FlagName;
        /**
          * The size of the flag. Pre-defined sizes are aligned with the Porsche Next typescale. Available values are `small`, `medium`, `large`, etc.
          * @default 'small'
         */
        "size"?: FlagSize;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PFlyout {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<FlyoutAriaAttribute>;
        /**
          * Defines the backdrop, 'blur' (should be used when the underlying content is not relevant for users) and 'shading' (should be used when the user still needs a visual connection to the underlying content).
          * @default 'blur'
         */
        "backdrop"?: FlyoutBackdrop;
        /**
          * Defines the background color
          * @default 'canvas'
         */
        "background"?: FlyoutBackground;
        /**
          * If true, the flyout will not be closable via backdrop click.
          * @default false
         */
        "disableBackdropClick"?: boolean;
        /**
          * Determines the footer's position behavior. When set to "fixed," the flyout content stretches to fill the full height, keeping the footer permanently at the bottom. When set to "sticky," the footer flows beneath the content and only becomes fixed if the content overflows.
          * @default 'sticky'
         */
        "footerBehavior"?: FlyoutFooterBehavior;
        /**
          * If true, the flyout is open.
          * @default false
         */
        "open": boolean;
        /**
          * The position of the flyout
          * @default 'end'
         */
        "position"?: FlyoutPosition;
    }
    interface PHeading {
        /**
          * Text alignment of the component.
          * @default 'start'
         */
        "align"?: HeadingAlign;
        /**
          * Basic text color variations.
          * @default 'primary'
         */
        "color"?: HeadingColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
          * @default false
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
          * @default 'xx-large'
         */
        "size"?: BreakpointCustomizable<HeadingSize>;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
         */
        "tag"?: HeadingTag;
    }
    interface PIcon {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<IconAriaAttribute>;
        /**
          * Basic color variations.
          * @default 'primary'
         */
        "color"?: IconColor;
        /**
          * Specifies which icon to use.
          * @default 'arrow-right'
         */
        "name"?: IconName;
        /**
          * The size of the icon.
          * @default 'small'
         */
        "size"?: IconSize;
        /**
          * Specifies a whole icon path which can be used for custom icons.
         */
        "source"?: string;
    }
    interface PInlineNotification {
        /**
          * Action icon of the inline-notification.
          * @default 'arrow-right'
         */
        "actionIcon"?: InlineNotificationActionIcon;
        /**
          * Action label of the inline-notification.
         */
        "actionLabel"?: string;
        /**
          * Disables the action button and shows a loading indicator. No events will be triggered while loading state is active.
          * @default false
         */
        "actionLoading"?: boolean;
        /**
          * Description of the inline-notification.
          * @default ''
         */
        "description"?: string;
        /**
          * If false, the inline-notification will not have a dismiss button.
          * @default true
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the inline-notification.
          * @default ''
         */
        "heading"?: string;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
          * @default 'h5'
         */
        "headingTag"?: InlineNotificationHeadingTag;
        /**
          * State of the inline-notification.
          * @default 'info'
         */
        "state"?: InlineNotificationState;
    }
    interface PInputDate {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., auto-complete='bday' for a birthday).
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * Specifies the latest date that can be selected. The value must be a date string in YYYY-MM-DD format (e.g., max='2024-12-31').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * Specifies the earliest date that can be selected. The value must be a date string in YYYY-MM-DD format (e.g., min='2023-01-01').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputDateState;
        /**
          * Defines the granularity of the date input. This value is given in days. The default is 1 (one day).
          * @default 1
         */
        "step"?: number;
        /**
          * The default date value for the input, in YYYY-MM-DD format (e.g., value='2025-07-02').
          * @default ''
         */
        "value"?: string;
    }
    interface PInputEmail {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='email').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Controls the visibility of the email icon.
          * @default false
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * A boolean value that, if present, it allows the user to enter a list of multiple email addresses, separated by commas (and optional whitespace). The browser will validate each email address in the list.
          * @default false
         */
        "multiple"?: boolean;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * Specifies a regular expression that the input's value must match for the value to pass constraint validation. This allows for more specific email validation rules than the browser's default (e.g., restricting to a specific domain). If provided, it overrides the browser's default email validation.
         */
        "pattern"?: string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='you@example.com'). This text is displayed when the input field is empty.
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputEmailState;
        /**
          * The default email address (or comma-separated list of addresses) for the input.
          * @default ''
         */
        "value"?: string;
    }
    interface PInputMonth {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features.
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * Specifies the latest month that can be selected. The value must be a month string in YYYY-MM format(e.g., max='2024-12').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * Specifies the earliest month that can be selected. The value must be a month string in YYYY-MM format (e.g., min='2023-01').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputMonthState;
        /**
          * Defines the stepping interval in months. For example, step="1" increments by 1 month, step="12" by 1 year. The default is 1 month.
          * @default 1
         */
        "step"?: number;
        /**
          * The default month value for the input, in YYYY-MM format (e.g., value='2025-07').
          * @default ''
         */
        "value"?: string;
    }
    interface PInputNumber {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='postal-code').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Show or hide the increment/decrement stepper controls.
          * @default false
         */
        "controls"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * The max value of the number input.
         */
        "max"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * The min value of the number input.
         */
        "min"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Enter a number'). This text is displayed when the input field is empty.
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputNumberState;
        /**
          * The granularity that the value must adhere to.
          * @default 1
         */
        "step"?: number;
        /**
          * The number input value.
          * @default ''
         */
        "value"?: string;
    }
    interface PInputPassword {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='current-password', autocomplete='new-password').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Enter your password'). This text is displayed when the input field is empty.
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputPasswordState;
        /**
          * Show or hide password toggle for `input type="password"`.
          * @default false
         */
        "toggle"?: boolean;
        /**
          * The password input value.
          * @default ''
         */
        "value"?: string;
    }
    interface PInputSearch {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='on').
         */
        "autoComplete"?: string;
        /**
          * Show clear input value button
          * @default false
         */
        "clear"?: boolean;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Show search indicator icon
          * @default false
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Search...'). This text is displayed when the input field is empty.
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputSearchState;
        /**
          * The search input value.
          * @default ''
         */
        "value"?: string;
    }
    interface PInputTel {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='tel').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Controls the visibility of the phone icon.
          * @default false
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * Specifies a regular expression that the input's value must match for the value to pass constraint validation. This allows for more specific tel validation rules than the browser's default. If provided, it overrides the browser's default tel validation.
         */
        "pattern"?: string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='(123) 456-7890')
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputTelState;
        /**
          * The tel input value.
          * @default ''
         */
        "value"?: string;
    }
    interface PInputText {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='name').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Show or hide the character counter.
          * @default false
         */
        "counter"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Enter your full name'). This text is displayed when the input field is empty.
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicate whether to enable spell-checking.
         */
        "spellCheck"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputTextState;
        /**
          * The text input value.
          * @default ''
         */
        "value"?: string;
    }
    interface PInputTime {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., auto-complete='on').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * Specifies the latest time that can be selected. The value must be a time string in hh:mm or hh:mm:ss format (e.g., max='17:30').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * Specifies the earliest time that can be selected. The value must be a time string in hh:mm or hh:mm:ss format (e.g., min='09:00').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputTimeState;
        /**
          * efines the granularity of the time input. The step value is given in seconds. The default is 60 (one minute). You can also specify smaller increments (e.g., step='1' for seconds, step='0.001' for milliseconds).
          * @default 60
         */
        "step"?: number;
        /**
          * The default time value for the input, in hh:mm or hh:mm:ss format (e.g., value='14:00').
          * @default ''
         */
        "value"?: string;
    }
    interface PInputUrl {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='url').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Controls the visibility of the url icon.
          * @default false
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * Specifies a regular expression that the input's value must match for the value to pass constraint validation. This allows for more specific url validation rules than the browser's default. If provided, it overrides the browser's default tel validation.
         */
        "pattern"?: string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='https://porsche.com/')
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputUrlState;
        /**
          * The url input value.
          * @default ''
         */
        "value"?: string;
    }
    interface PInputWeek {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features.
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * Specifies the latest week that can be selected. The value must be a week string in YYYY-Www format (e.g., max='2024-W52').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * Specifies the earliest week that can be selected. The value must be a week string in YYYY-Www format (e.g., min='2024-W01').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputWeekState;
        /**
          * Defines the stepping interval in weeks. For example, step="1" increments by 1 week. The default is 1 month.
          * @default 1
         */
        "step"?: number;
        /**
          * The default week value for the input, in YYYY-Www format (e.g., value='2025-W27')
          * @default ''
         */
        "value"?: string;
    }
    interface PLink {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkAriaAttribute>;
        /**
          * Displays as compact version.
          * @default false
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
          * @default 'none'
         */
        "icon"?: LinkIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
          * @default '_self'
         */
        "target"?: LinkTarget;
        /**
          * The style variant of the link.
          * @default 'primary'
         */
        "variant"?: LinkVariant;
    }
    interface PLinkPure {
        /**
          * Display link in active state.
          * @default false
         */
        "active"?: boolean;
        /**
          * Aligns the label.
          * @default 'end'
         */
        "alignLabel"?: BreakpointCustomizable<LinkPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkPureAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed
          * @default 'arrow-right'
         */
        "icon"?: LinkPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Size of the link.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<LinkPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
          * @default false
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Target attribute where the link should be opened.
          * @default '_self'
         */
        "target"?: LinkPureTarget;
        /**
          * Shows an underline under the label.
          * @default false
         */
        "underline"?: boolean;
    }
    interface PLinkTile {
        /**
          * Alignment of link and description.
          * @default 'bottom'
         */
        "align"?: LinkTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkTileAriaAttribute>;
        /**
          * Aspect ratio of the link-tile.
          * @default '4/3'
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileAspectRatio>;
        /**
          * Displays the link-tile as compact version with description and link icon only.
          * @default false
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description": string;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show gradient.
          * @default false
         */
        "gradient"?: boolean;
        /**
          * href of the `<a>`.
         */
        "href": string;
        /**
          * Label of the <a />.
         */
        "label": string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Font size of the description.
          * @default 'medium'
         */
        "size"?: BreakpointCustomizable<LinkTileSize>;
        /**
          * Target attribute where the link should be opened.
          * @default '_self'
         */
        "target"?: LinkTileTarget;
        /**
          * Font weight of the description.
          * @default 'semi-bold'
         */
        "weight"?: BreakpointCustomizable<LinkTileWeight>;
    }
    /**
     * @controlled {"props": ["liked"], "event": "like"}
     * @experimental 
     */
    interface PLinkTileProduct {
        /**
          * Aspect ratio of the link-tile-product.
          * @default '3/4'
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileProductAspectRatio>;
        /**
          * Additional product description.
         */
        "description"?: string;
        /**
          * Product heading.
         */
        "heading": string;
        /**
          * href of the `<a>`.
         */
        "href"?: string;
        /**
          * A Boolean attribute indicating that a like button should be shown.
          * @default true
         */
        "likeButton"?: boolean;
        /**
          * A Boolean attribute indicating that a product is liked.
          * @default false
         */
        "liked"?: boolean;
        /**
          * Product retail price (with or without discount).
         */
        "price": string;
        /**
          * Shows original price (recommended retail price) with line-through. Needs prop "price" to be defined, otherwise this prop has no effect.
         */
        "priceOriginal"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
          * @default '_self'
         */
        "target"?: LinkTileProductTarget;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PModal {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ModalAriaAttribute>;
        /**
          * Defines the backdrop, 'blur' (should be used when Modal is opened by user interaction, e.g. after a click on a button) and 'shading' (should be used when Modal gets opened automatically, e.g. Cookie Consent).
          * @default 'blur'
         */
        "backdrop"?: ModalBackdrop;
        /**
          * Defines the background color
          * @default 'canvas'
         */
        "background"?: ModalBackground;
        /**
          * If true, the modal will not be closable via backdrop click.
          * @default false
         */
        "disableBackdropClick"?: boolean;
        /**
          * If false, the modal will not have a dismiss button.
          * @default true
         */
        "dismissButton"?: boolean;
        /**
          * If true the modal uses max viewport height and width. Should only be used for mobile.
          * @default false
         */
        "fullscreen"?: BreakpointCustomizable<boolean>;
        /**
          * If true, the modal is open.
          * @default false
         */
        "open": boolean;
    }
    interface PModelSignature {
        /**
          * Adapts the color of the component.
          * @default 'primary'
         */
        "color"?: ModelSignatureColor;
        /**
          * Defines the fetch priority of the model signature. In the end it is just a recommendation to the browser, but it defines the priority on its own.
          * @default 'auto'
         */
        "fetchPriority"?: ModelSignatureFetchPriority;
        /**
          * Defines whether the model signature is always loaded or only loaded when it is in the viewport (this feature may not work reliably).
          * @default false
         */
        "lazy"?: boolean;
        /**
          * Adapts the model of the component.
          * @default '911'
         */
        "model"?: ModelSignatureModel;
        /**
          * When set to `true`, then all model signatures are visually aligned with each other. When set to `false` the model signature comes without any safe zone.
          * @default true
         */
        "safeZone"?: boolean;
        /**
          * Adapts the size of the component. When set to `inherit` a CSS `width` or `height` needs to be defined on the host but not both.
          * @default 'small'
         */
        "size"?: ModelSignatureSize;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PMultiSelect {
        /**
          * Displays as compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * The description text.
          * @default ''
         */
        "description"?: string;
        /**
          * Disables the multi-select
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Changes the direction to which the dropdown list appears.
          * @default 'auto'
         */
        "dropdownDirection"?: MultiSelectDropdownDirection;
        /**
          * The id of a form element the multi-select should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
          * @default ''
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
          * @default ''
         */
        "message"?: string;
        /**
          * The name of the control.
         */
        "name": string;
        /**
          * A Boolean attribute indicating that an option with a non-empty string value must be selected.
          * @default false
         */
        "required"?: boolean;
        /**
          * The validation state.
          * @default 'none'
         */
        "state"?: MultiSelectState;
        /**
          * The selected values.
          * @default []
         */
        "value"?: string[];
    }
    interface PMultiSelectOption {
        /**
          * Disables the option.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The option value.
         */
        "value": string;
    }
    interface POptgroup {
        /**
          * Disables the optgroup.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The optgroup label.
         */
        "label"?: string;
    }
    /**
     * @controlled { "props": ["activePage"], "event": "update", "isInternallyMutated": true }
     */
    interface PPagination {
        /**
          * Index of the currently active page.
          * @default 1
         */
        "activePage"?: number;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev and page buttons.
          * @default {     root: 'Pagination',     prev: 'Previous page',     next: 'Next page',     page: 'Page',   }
         */
        "intl"?: PaginationInternationalization;
        /**
          * The total count of items which should be shown per page.
          * @default 1
         */
        "itemsPerPage": number;
        /**
          * Show or hide the button to jump to the last page.
          * @default true
         */
        "showLastPage"?: boolean;
        /**
          * The total count of items.
          * @default 1
         */
        "totalItemsCount": number;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PPinCode {
        /**
          * A boolean value that, if present, renders the pin-code as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * The description text.
          * @default ''
         */
        "description"?: string;
        /**
          * Disables the Pin Code. No events will be triggered while disabled state is active.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the pin-code should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label and description text. For better accessibility it is recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
          * @default ''
         */
        "label"?: string;
        /**
          * Number of characters of the Pin Code.
          * @default 4
         */
        "length"?: PinCodeLength;
        /**
          * Disables the Pin Code and shows a loading indicator. No events will be triggered while loading state is active.
          * @default false
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
          * @default ''
         */
        "message"?: string;
        /**
          * Name of the control.
         */
        "name"?: string;
        /**
          * Marks the Pin Code as required.
          * @default false
         */
        "required"?: boolean;
        /**
          * The validation state.
          * @default 'none'
         */
        "state"?: PinCodeState;
        /**
          * Pin Code type.
          * @default 'number'
         */
        "type"?: PinCodeType;
        /**
          * Sets the initial value of the Pin Code.
          * @default ''
         */
        "value"?: string;
    }
    interface PPopover {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<PopoverAriaAttribute>;
        /**
          * Descriptive text to show additional information when popover is open
         */
        "description"?: string;
        /**
          * Preferred direction in which popover should open, given there is enough space in viewport. Otherwise, it will be opened in the direction with most available space.
          * @default 'bottom'
         */
        "direction"?: PopoverDirection;
    }
    interface PRadioGroup {
        /**
          * A boolean value that, if present, renders the radio group as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the radio group.
          * @default ''
         */
        "description"?: string;
        /**
          * Defines the direction of the main and cross axis. The default is 'column' showing options vertically stacked. You always need to provide a base value when using breakpoints.
          * @default 'column'
         */
        "direction"?: BreakpointCustomizable<RadioGroupDirection>;
        /**
          * A boolean value that, if present, makes the radio group unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the radio group belongs to (useful if the radio group is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * The name of the group of radio buttons, used when submitting the form data.
         */
        "name": string;
        /**
          * A boolean value that specifies a selection must be made from the group before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the radio group component.
          * @default 'none'
         */
        "state"?: RadioGroupState;
        /**
          * The default value for the radio-group.
          * @default ''
         */
        "value"?: string;
    }
    interface PRadioGroupOption {
        /**
          * A boolean value that, if present, makes the radio group option unusable and unclickable.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * The value for the input.
         */
        "value"?: string;
    }
    interface PScroller {
        /**
          * Sets the vertical position of scroll indicator.
          * @default 'center'
         */
        "alignScrollIndicator"?: ScrollerAlignScrollIndicator;
        /**
          * Add ARIA role.
         */
        "aria"?: SelectedAriaAttributes<ScrollerAriaAttribute>;
        /**
          * Scrolls the scroll area to the left either smooth or immediately.
         */
        "scrollToPosition"?: ScrollerScrollToPosition;
        /**
          * Specifies if scrollbar should be shown.
          * @default false
         */
        "scrollbar"?: boolean;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PSegmentedControl {
        /**
          * Sets the amount of columns.
          * @default 'auto'
         */
        "columns"?: BreakpointCustomizable<SegmentedControlColumns>;
        /**
          * A boolean value that, if present, renders the segmented-control as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the segmented-control.
          * @default ''
         */
        "description"?: string;
        /**
          * Disables the segmented-control.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the segmented-control should be associated with.
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * The name of the segmented-control.
         */
        "name"?: string;
        /**
          * A boolean value that specifies a selection must be made from the group before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the component.
          * @default 'none'
         */
        "state"?: SegmentedControlState;
        /**
          * Sets the initial value of the segmented-control.
         */
        "value"?: string | number;
    }
    interface PSegmentedControlItem {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SegmentedControlItemAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The icon shown.
         */
        "icon"?: SegmentedControlItemIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The value of this item which is emitted by the parent element if it becomes selected. This property is **required**.
         */
        "value": string | number;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PSelect {
        /**
          * Displays as compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * The description text.
          * @default ''
         */
        "description"?: string;
        /**
          * Disables the select.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Changes the direction to which the dropdown list appears.
          * @default 'auto'
         */
        "dropdownDirection"?: SelectDropdownDirection;
        /**
          * Shows an input in the dropdown allowing options to be filtered. Will be ignored if the `filter` slot is used.
          * @default false
         */
        "filter"?: boolean;
        /**
          * The id of a form element the select should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
          * @default ''
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
          * @default ''
         */
        "message"?: string;
        /**
          * The name of the control.
         */
        "name": string;
        /**
          * A Boolean attribute indicating that an option with a non-empty string value must be selected.
          * @default false
         */
        "required"?: boolean;
        /**
          * The validation state.
          * @default 'none'
         */
        "state"?: SelectState;
        /**
          * The selected value.
         */
        "value"?: string;
    }
    interface PSelectOption {
        /**
          * Disables the option.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The option value.
         */
        "value"?: string;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PSheet {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SheetAriaAttribute>;
        /**
          * Defines the background color
          * @default 'canvas'
         */
        "background"?: SheetBackground;
        /**
          * If true, the sheet will not be closable via backdrop click.
          * @default false
         */
        "disableBackdropClick"?: boolean;
        /**
          * If false, the sheet will not have a dismiss button.
          * @default true
         */
        "dismissButton"?: boolean;
        /**
          * If true, the sheet is open.
          * @default false
         */
        "open": boolean;
    }
    interface PSpinner {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SpinnerAriaAttribute>;
        /**
          * Size of the spinner.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<SpinnerSize>;
    }
    interface PStepperHorizontal {
        /**
          * The text size.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<StepperHorizontalSize>;
    }
    interface PStepperHorizontalItem {
        /**
          * Disables the stepper-horizontal-item. No events will be triggered while disabled state is active.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The validation state.
         */
        "state"?: StepperHorizontalItemState;
    }
    /**
     * @controlled {"props": ["checked"], "event": "update"}
     */
    interface PSwitch {
        /**
          * Aligns the label.
          * @default 'end'
         */
        "alignLabel"?: BreakpointCustomizable<SwitchAlignLabel>;
        /**
          * Visualize the switch with on/off status.
          * @default false
         */
        "checked"?: boolean;
        /**
          * Displays as compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Disables the switch. No events will be triggered while disabled state is active.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Disables the switch and shows a loading indicator. No events will be triggered while loading state is active.
          * @default false
         */
        "loading"?: boolean;
        /**
          * Stretches the contents to max available space.
          * @default false
         */
        "stretch"?: BreakpointCustomizable<boolean>;
    }
    interface PTable {
        /**
          * A caption describing the contents of the table for accessibility only. This won't be visible in the browser. Use an element with an attribute of `slot="caption"` for a visible caption.
         */
        "caption"?: string;
        /**
          * Displays as compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Controls the layout behavior of the table.
          * @default 'auto'
         */
        "layout"?: TableLayout;
    }
    interface PTableBody {
    }
    interface PTableCell {
        /**
          * Displays slotted text multiline or forced into a single line.
          * @default false
         */
        "multiline"?: boolean;
    }
    interface PTableHead {
    }
    interface PTableHeadCell {
        /**
          * Hides the label but stays accessible for screen readers. This property only takes effect when sort property is not defined.
          * @default false
         */
        "hideLabel"?: boolean;
        /**
          * Displays slotted text multiline or forced into a single line.
          * @default false
         */
        "multiline"?: boolean;
        /**
          * Defines sortability properties.
         */
        "sort"?: TableHeadCellSort;
    }
    interface PTableHeadRow {
    }
    interface PTableRow {
    }
    /**
     * @controlled { "props": ["activeTabIndex"], "event": "update", "isInternallyMutated": true }
     */
    interface PTabs {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering).
          * @default 0
         */
        "activeTabIndex"?: number;
        /**
          * The text size.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<TabsSize>;
        /**
          * The text weight.
          * @default 'regular'
         */
        "weight"?: TabsWeight;
    }
    /**
     * @controlled {"props": ["activeTabIndex"], "event": "update"}
     */
    interface PTabsBar {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering), undefined if none should be selected.
         */
        "activeTabIndex"?: number | undefined;
        /**
          * The text size.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<TabsBarSize>;
        /**
          * The text weight.
          * @default 'regular'
         */
        "weight"?: TabsBarWeight;
    }
    interface PTabsItem {
        /**
          * Defines the label used in tabs.
         */
        "label": string;
    }
    interface PTag {
        /**
          * Displays as compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * The icon shown.
          * @default 'none'
         */
        "icon"?: TagIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Background color variations.
          * @default 'secondary'
         */
        "variant"?: TagVariant;
    }
    interface PTagDismissible {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<TagDismissibleAriaAttribute>;
        /**
          * A boolean value that, if present, renders the tag dismissible as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * The label text.
         */
        "label"?: string;
    }
    interface PText {
        /**
          * Text alignment of the component.
          * @default 'start'
         */
        "align"?: TextAlign;
        /**
          * Basic text color variations.
          * @default 'primary'
         */
        "color"?: TextColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
          * @default false
         */
        "ellipsis"?: boolean;
        /**
          * Size of the text. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<TextSize>;
        /**
          * Sets a custom HTML tag depending on the usage of the text component.
          * @default 'p'
         */
        "tag"?: TextTag;
        /**
          * The weight of the text.
          * @default 'regular'
         */
        "weight"?: TextWeight;
    }
    interface PTextList {
        /**
          * The list style type.
          * @default 'unordered'
         */
        "type"?: TextListType;
    }
    interface PTextListItem {
    }
    interface PTextarea {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='on').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the textarea as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Show or hide the character counter.
          * @default false
         */
        "counter"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the textarea.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the textarea unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the textarea belongs to (useful if the textarea is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the textarea.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the textarea's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the textarea, used when submitting the form data.
         */
        "name": string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Write your message here...'). This text is displayed when the textarea is empty.
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the textarea uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the textarea must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Controls whether the textarea is resizable and in which direction.
          * @default 'vertical'
         */
        "resize"?: TextareaResize;
        /**
          * The number of rows. Has no effect when field-sizing CSS Variable '--p-textarea-field-sizing' is set to 'content'.
          * @default 7
         */
        "rows"?: number;
        /**
          * Specifies whether the textarea should have its spelling and grammar checked
         */
        "spellCheck"?: boolean;
        /**
          * Indicates the validation or overall status of the textarea component.
          * @default 'none'
         */
        "state"?: TextareaState;
        /**
          * The textarea value.
          * @default ''
         */
        "value"?: string;
        /**
          * Handles wrapping behavior of elements.
          * @default 'soft'
         */
        "wrap"?: TextareaWrap;
    }
    interface PToast {
        "addMessage": (message: ToastMessage) => Promise<void>;
    }
    interface PToastItem {
        /**
          * State of the toast-item.
          * @default 'info'
         */
        "state"?: ToastState;
        /**
          * Text of the toast-item.
          * @default ''
         */
        "text"?: string;
    }
    interface PWordmark {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<WordmarkAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Adapts sizing of wordmark.
          * @default 'small'
         */
        "size"?: WordmarkSize;
        /**
          * Target attribute where the link should be opened.
          * @default '_self'
         */
        "target"?: WordmarkTarget;
    }
}
export interface PAccordionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPAccordionElement;
}
export interface PBannerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPBannerElement;
}
export interface PCanvasCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPCanvasElement;
}
export interface PCarouselCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPCarouselElement;
}
export interface PCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPCheckboxElement;
}
export interface PDrilldownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPDrilldownElement;
}
export interface PFlyoutCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPFlyoutElement;
}
export interface PInlineNotificationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInlineNotificationElement;
}
export interface PInputDateCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputDateElement;
}
export interface PInputEmailCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputEmailElement;
}
export interface PInputMonthCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputMonthElement;
}
export interface PInputNumberCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputNumberElement;
}
export interface PInputPasswordCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputPasswordElement;
}
export interface PInputSearchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputSearchElement;
}
export interface PInputTelCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputTelElement;
}
export interface PInputTextCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputTextElement;
}
export interface PInputTimeCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputTimeElement;
}
export interface PInputUrlCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputUrlElement;
}
export interface PInputWeekCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputWeekElement;
}
export interface PLinkTileProductCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPLinkTileProductElement;
}
export interface PModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPModalElement;
}
export interface PMultiSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPMultiSelectElement;
}
export interface PPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPPaginationElement;
}
export interface PPinCodeCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPPinCodeElement;
}
export interface PRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPRadioGroupElement;
}
export interface PSegmentedControlCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPSegmentedControlElement;
}
export interface PSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPSelectElement;
}
export interface PSheetCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPSheetElement;
}
export interface PStepperHorizontalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPStepperHorizontalElement;
}
export interface PSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPSwitchElement;
}
export interface PTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTableElement;
}
export interface PTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTabsElement;
}
export interface PTabsBarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTabsBarElement;
}
export interface PTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTextareaElement;
}
export interface PToastItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPToastItemElement;
}
declare global {
    interface HTMLPAccordionElementEventMap {
        "update": AccordionUpdateEventDetail;
    }
    /**
     * @controlled {"props": ["open"], "event": "update"}
     */
    interface HTMLPAccordionElement extends Components.PAccordion, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPAccordionElementEventMap>(type: K, listener: (this: HTMLPAccordionElement, ev: PAccordionCustomEvent<HTMLPAccordionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPAccordionElementEventMap>(type: K, listener: (this: HTMLPAccordionElement, ev: PAccordionCustomEvent<HTMLPAccordionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPAccordionElement: {
        prototype: HTMLPAccordionElement;
        new (): HTMLPAccordionElement;
    };
    interface HTMLPBannerElementEventMap {
        "dismiss": void;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface HTMLPBannerElement extends Components.PBanner, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPBannerElementEventMap>(type: K, listener: (this: HTMLPBannerElement, ev: PBannerCustomEvent<HTMLPBannerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPBannerElementEventMap>(type: K, listener: (this: HTMLPBannerElement, ev: PBannerCustomEvent<HTMLPBannerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPBannerElement: {
        prototype: HTMLPBannerElement;
        new (): HTMLPBannerElement;
    };
    interface HTMLPButtonElement extends Components.PButton, HTMLStencilElement {
    }
    var HTMLPButtonElement: {
        prototype: HTMLPButtonElement;
        new (): HTMLPButtonElement;
    };
    interface HTMLPButtonPureElement extends Components.PButtonPure, HTMLStencilElement {
    }
    var HTMLPButtonPureElement: {
        prototype: HTMLPButtonPureElement;
        new (): HTMLPButtonPureElement;
    };
    interface HTMLPButtonTileElement extends Components.PButtonTile, HTMLStencilElement {
    }
    var HTMLPButtonTileElement: {
        prototype: HTMLPButtonTileElement;
        new (): HTMLPButtonTileElement;
    };
    interface HTMLPCanvasElementEventMap {
        "sidebarStartUpdate": CanvasSidebarStartUpdateEventDetail;
        "sidebarEndDismiss": void;
    }
    /**
     * @experimental 
     */
    interface HTMLPCanvasElement extends Components.PCanvas, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPCanvasElementEventMap>(type: K, listener: (this: HTMLPCanvasElement, ev: PCanvasCustomEvent<HTMLPCanvasElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPCanvasElementEventMap>(type: K, listener: (this: HTMLPCanvasElement, ev: PCanvasCustomEvent<HTMLPCanvasElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPCanvasElement: {
        prototype: HTMLPCanvasElement;
        new (): HTMLPCanvasElement;
    };
    interface HTMLPCarouselElementEventMap {
        "update": CarouselUpdateEventDetail;
    }
    /**
     * @controlled { "props": ["activeSlideIndex"], "event": "update", "isInternallyMutated": true }
     */
    interface HTMLPCarouselElement extends Components.PCarousel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPCarouselElementEventMap>(type: K, listener: (this: HTMLPCarouselElement, ev: PCarouselCustomEvent<HTMLPCarouselElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPCarouselElementEventMap>(type: K, listener: (this: HTMLPCarouselElement, ev: PCarouselCustomEvent<HTMLPCarouselElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPCarouselElement: {
        prototype: HTMLPCarouselElement;
        new (): HTMLPCarouselElement;
    };
    interface HTMLPCheckboxElementEventMap {
        "change": CheckboxChangeEventDetail;
        "blur": CheckboxBlurEventDetail;
    }
    interface HTMLPCheckboxElement extends Components.PCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPCheckboxElementEventMap>(type: K, listener: (this: HTMLPCheckboxElement, ev: PCheckboxCustomEvent<HTMLPCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPCheckboxElementEventMap>(type: K, listener: (this: HTMLPCheckboxElement, ev: PCheckboxCustomEvent<HTMLPCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPCheckboxElement: {
        prototype: HTMLPCheckboxElement;
        new (): HTMLPCheckboxElement;
    };
    interface HTMLPCrestElement extends Components.PCrest, HTMLStencilElement {
    }
    var HTMLPCrestElement: {
        prototype: HTMLPCrestElement;
        new (): HTMLPCrestElement;
    };
    interface HTMLPDisplayElement extends Components.PDisplay, HTMLStencilElement {
    }
    var HTMLPDisplayElement: {
        prototype: HTMLPDisplayElement;
        new (): HTMLPDisplayElement;
    };
    interface HTMLPDividerElement extends Components.PDivider, HTMLStencilElement {
    }
    var HTMLPDividerElement: {
        prototype: HTMLPDividerElement;
        new (): HTMLPDividerElement;
    };
    interface HTMLPDrilldownElementEventMap {
        "dismiss": void;
        "update": DrilldownUpdateEventDetail;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     * @controlled {"props": ["activeIdentifier"], "event": "update"}
     * @experimental 
     */
    interface HTMLPDrilldownElement extends Components.PDrilldown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPDrilldownElementEventMap>(type: K, listener: (this: HTMLPDrilldownElement, ev: PDrilldownCustomEvent<HTMLPDrilldownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPDrilldownElementEventMap>(type: K, listener: (this: HTMLPDrilldownElement, ev: PDrilldownCustomEvent<HTMLPDrilldownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPDrilldownElement: {
        prototype: HTMLPDrilldownElement;
        new (): HTMLPDrilldownElement;
    };
    /**
     * @experimental 
     */
    interface HTMLPDrilldownItemElement extends Components.PDrilldownItem, HTMLStencilElement {
    }
    var HTMLPDrilldownItemElement: {
        prototype: HTMLPDrilldownItemElement;
        new (): HTMLPDrilldownItemElement;
    };
    /**
     * @experimental 
     */
    interface HTMLPDrilldownLinkElement extends Components.PDrilldownLink, HTMLStencilElement {
    }
    var HTMLPDrilldownLinkElement: {
        prototype: HTMLPDrilldownLinkElement;
        new (): HTMLPDrilldownLinkElement;
    };
    interface HTMLPFieldsetElement extends Components.PFieldset, HTMLStencilElement {
    }
    var HTMLPFieldsetElement: {
        prototype: HTMLPFieldsetElement;
        new (): HTMLPFieldsetElement;
    };
    interface HTMLPFlagElement extends Components.PFlag, HTMLStencilElement {
    }
    var HTMLPFlagElement: {
        prototype: HTMLPFlagElement;
        new (): HTMLPFlagElement;
    };
    interface HTMLPFlyoutElementEventMap {
        "dismiss": void;
        "motionVisibleEnd": FlyoutMotionVisibleEndEventDetail;
        "motionHiddenEnd": FlyoutMotionHiddenEndEventDetail;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface HTMLPFlyoutElement extends Components.PFlyout, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPFlyoutElementEventMap>(type: K, listener: (this: HTMLPFlyoutElement, ev: PFlyoutCustomEvent<HTMLPFlyoutElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPFlyoutElementEventMap>(type: K, listener: (this: HTMLPFlyoutElement, ev: PFlyoutCustomEvent<HTMLPFlyoutElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPFlyoutElement: {
        prototype: HTMLPFlyoutElement;
        new (): HTMLPFlyoutElement;
    };
    interface HTMLPHeadingElement extends Components.PHeading, HTMLStencilElement {
    }
    var HTMLPHeadingElement: {
        prototype: HTMLPHeadingElement;
        new (): HTMLPHeadingElement;
    };
    interface HTMLPIconElement extends Components.PIcon, HTMLStencilElement {
    }
    var HTMLPIconElement: {
        prototype: HTMLPIconElement;
        new (): HTMLPIconElement;
    };
    interface HTMLPInlineNotificationElementEventMap {
        "dismiss": void;
        "action": void;
    }
    interface HTMLPInlineNotificationElement extends Components.PInlineNotification, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInlineNotificationElementEventMap>(type: K, listener: (this: HTMLPInlineNotificationElement, ev: PInlineNotificationCustomEvent<HTMLPInlineNotificationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInlineNotificationElementEventMap>(type: K, listener: (this: HTMLPInlineNotificationElement, ev: PInlineNotificationCustomEvent<HTMLPInlineNotificationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInlineNotificationElement: {
        prototype: HTMLPInlineNotificationElement;
        new (): HTMLPInlineNotificationElement;
    };
    interface HTMLPInputDateElementEventMap {
        "change": InputDateChangeEventDetail;
        "blur": InputDateBlurEventDetail;
        "input": InputDateInputEventDetail;
    }
    interface HTMLPInputDateElement extends Components.PInputDate, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputDateElementEventMap>(type: K, listener: (this: HTMLPInputDateElement, ev: PInputDateCustomEvent<HTMLPInputDateElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputDateElementEventMap>(type: K, listener: (this: HTMLPInputDateElement, ev: PInputDateCustomEvent<HTMLPInputDateElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputDateElement: {
        prototype: HTMLPInputDateElement;
        new (): HTMLPInputDateElement;
    };
    interface HTMLPInputEmailElementEventMap {
        "change": InputEmailChangeEventDetail;
        "blur": InputEmailBlurEventDetail;
        "input": InputEmailInputEventDetail;
    }
    interface HTMLPInputEmailElement extends Components.PInputEmail, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputEmailElementEventMap>(type: K, listener: (this: HTMLPInputEmailElement, ev: PInputEmailCustomEvent<HTMLPInputEmailElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputEmailElementEventMap>(type: K, listener: (this: HTMLPInputEmailElement, ev: PInputEmailCustomEvent<HTMLPInputEmailElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputEmailElement: {
        prototype: HTMLPInputEmailElement;
        new (): HTMLPInputEmailElement;
    };
    interface HTMLPInputMonthElementEventMap {
        "change": InputMonthChangeEventDetail;
        "blur": InputMonthBlurEventDetail;
        "input": InputMonthInputEventDetail;
    }
    interface HTMLPInputMonthElement extends Components.PInputMonth, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputMonthElementEventMap>(type: K, listener: (this: HTMLPInputMonthElement, ev: PInputMonthCustomEvent<HTMLPInputMonthElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputMonthElementEventMap>(type: K, listener: (this: HTMLPInputMonthElement, ev: PInputMonthCustomEvent<HTMLPInputMonthElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputMonthElement: {
        prototype: HTMLPInputMonthElement;
        new (): HTMLPInputMonthElement;
    };
    interface HTMLPInputNumberElementEventMap {
        "change": InputNumberChangeEventDetail;
        "blur": InputNumberBlurEventDetail;
        "input": InputNumberInputEventDetail;
    }
    interface HTMLPInputNumberElement extends Components.PInputNumber, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputNumberElementEventMap>(type: K, listener: (this: HTMLPInputNumberElement, ev: PInputNumberCustomEvent<HTMLPInputNumberElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputNumberElementEventMap>(type: K, listener: (this: HTMLPInputNumberElement, ev: PInputNumberCustomEvent<HTMLPInputNumberElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputNumberElement: {
        prototype: HTMLPInputNumberElement;
        new (): HTMLPInputNumberElement;
    };
    interface HTMLPInputPasswordElementEventMap {
        "change": InputPasswordChangeEventDetail;
        "blur": InputPasswordBlurEventDetail;
        "input": InputPasswordInputEventDetail;
    }
    interface HTMLPInputPasswordElement extends Components.PInputPassword, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputPasswordElementEventMap>(type: K, listener: (this: HTMLPInputPasswordElement, ev: PInputPasswordCustomEvent<HTMLPInputPasswordElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputPasswordElementEventMap>(type: K, listener: (this: HTMLPInputPasswordElement, ev: PInputPasswordCustomEvent<HTMLPInputPasswordElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputPasswordElement: {
        prototype: HTMLPInputPasswordElement;
        new (): HTMLPInputPasswordElement;
    };
    interface HTMLPInputSearchElementEventMap {
        "change": InputSearchChangeEventDetail;
        "blur": InputSearchBlurEventDetail;
        "input": InputSearchInputEventDetail;
    }
    interface HTMLPInputSearchElement extends Components.PInputSearch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputSearchElementEventMap>(type: K, listener: (this: HTMLPInputSearchElement, ev: PInputSearchCustomEvent<HTMLPInputSearchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputSearchElementEventMap>(type: K, listener: (this: HTMLPInputSearchElement, ev: PInputSearchCustomEvent<HTMLPInputSearchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputSearchElement: {
        prototype: HTMLPInputSearchElement;
        new (): HTMLPInputSearchElement;
    };
    interface HTMLPInputTelElementEventMap {
        "change": InputTelChangeEventDetail;
        "blur": InputTelBlurEventDetail;
        "input": InputTelInputEventDetail;
    }
    interface HTMLPInputTelElement extends Components.PInputTel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputTelElementEventMap>(type: K, listener: (this: HTMLPInputTelElement, ev: PInputTelCustomEvent<HTMLPInputTelElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputTelElementEventMap>(type: K, listener: (this: HTMLPInputTelElement, ev: PInputTelCustomEvent<HTMLPInputTelElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputTelElement: {
        prototype: HTMLPInputTelElement;
        new (): HTMLPInputTelElement;
    };
    interface HTMLPInputTextElementEventMap {
        "change": InputTextChangeEventDetail;
        "blur": InputTextBlurEventDetail;
        "input": InputTextInputEventDetail;
    }
    interface HTMLPInputTextElement extends Components.PInputText, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputTextElementEventMap>(type: K, listener: (this: HTMLPInputTextElement, ev: PInputTextCustomEvent<HTMLPInputTextElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputTextElementEventMap>(type: K, listener: (this: HTMLPInputTextElement, ev: PInputTextCustomEvent<HTMLPInputTextElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputTextElement: {
        prototype: HTMLPInputTextElement;
        new (): HTMLPInputTextElement;
    };
    interface HTMLPInputTimeElementEventMap {
        "change": InputTimeChangeEventDetail;
        "blur": InputTimeBlurEventDetail;
        "input": InputTimeInputEventDetail;
    }
    interface HTMLPInputTimeElement extends Components.PInputTime, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputTimeElementEventMap>(type: K, listener: (this: HTMLPInputTimeElement, ev: PInputTimeCustomEvent<HTMLPInputTimeElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputTimeElementEventMap>(type: K, listener: (this: HTMLPInputTimeElement, ev: PInputTimeCustomEvent<HTMLPInputTimeElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputTimeElement: {
        prototype: HTMLPInputTimeElement;
        new (): HTMLPInputTimeElement;
    };
    interface HTMLPInputUrlElementEventMap {
        "change": InputUrlChangeEventDetail;
        "blur": InputUrlBlurEventDetail;
        "input": InputUrlInputEventDetail;
    }
    interface HTMLPInputUrlElement extends Components.PInputUrl, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputUrlElementEventMap>(type: K, listener: (this: HTMLPInputUrlElement, ev: PInputUrlCustomEvent<HTMLPInputUrlElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputUrlElementEventMap>(type: K, listener: (this: HTMLPInputUrlElement, ev: PInputUrlCustomEvent<HTMLPInputUrlElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputUrlElement: {
        prototype: HTMLPInputUrlElement;
        new (): HTMLPInputUrlElement;
    };
    interface HTMLPInputWeekElementEventMap {
        "change": InputWeekChangeEventDetail;
        "blur": InputWeekBlurEventDetail;
        "input": InputWeekInputEventDetail;
    }
    interface HTMLPInputWeekElement extends Components.PInputWeek, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputWeekElementEventMap>(type: K, listener: (this: HTMLPInputWeekElement, ev: PInputWeekCustomEvent<HTMLPInputWeekElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputWeekElementEventMap>(type: K, listener: (this: HTMLPInputWeekElement, ev: PInputWeekCustomEvent<HTMLPInputWeekElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputWeekElement: {
        prototype: HTMLPInputWeekElement;
        new (): HTMLPInputWeekElement;
    };
    interface HTMLPLinkElement extends Components.PLink, HTMLStencilElement {
    }
    var HTMLPLinkElement: {
        prototype: HTMLPLinkElement;
        new (): HTMLPLinkElement;
    };
    interface HTMLPLinkPureElement extends Components.PLinkPure, HTMLStencilElement {
    }
    var HTMLPLinkPureElement: {
        prototype: HTMLPLinkPureElement;
        new (): HTMLPLinkPureElement;
    };
    interface HTMLPLinkTileElement extends Components.PLinkTile, HTMLStencilElement {
    }
    var HTMLPLinkTileElement: {
        prototype: HTMLPLinkTileElement;
        new (): HTMLPLinkTileElement;
    };
    interface HTMLPLinkTileProductElementEventMap {
        "like": LinkTileProductLikeEventDetail;
    }
    /**
     * @controlled {"props": ["liked"], "event": "like"}
     * @experimental 
     */
    interface HTMLPLinkTileProductElement extends Components.PLinkTileProduct, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPLinkTileProductElementEventMap>(type: K, listener: (this: HTMLPLinkTileProductElement, ev: PLinkTileProductCustomEvent<HTMLPLinkTileProductElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPLinkTileProductElementEventMap>(type: K, listener: (this: HTMLPLinkTileProductElement, ev: PLinkTileProductCustomEvent<HTMLPLinkTileProductElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPLinkTileProductElement: {
        prototype: HTMLPLinkTileProductElement;
        new (): HTMLPLinkTileProductElement;
    };
    interface HTMLPModalElementEventMap {
        "dismiss": void;
        "motionVisibleEnd": ModalMotionVisibleEndEventDetail;
        "motionHiddenEnd": ModalMotionHiddenEndEventDetail;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface HTMLPModalElement extends Components.PModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPModalElementEventMap>(type: K, listener: (this: HTMLPModalElement, ev: PModalCustomEvent<HTMLPModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPModalElementEventMap>(type: K, listener: (this: HTMLPModalElement, ev: PModalCustomEvent<HTMLPModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPModalElement: {
        prototype: HTMLPModalElement;
        new (): HTMLPModalElement;
    };
    interface HTMLPModelSignatureElement extends Components.PModelSignature, HTMLStencilElement {
    }
    var HTMLPModelSignatureElement: {
        prototype: HTMLPModelSignatureElement;
        new (): HTMLPModelSignatureElement;
    };
    interface HTMLPMultiSelectElementEventMap {
        "blur": void;
        "change": MultiSelectChangeEventDetail;
        "toggle": MultiSelectToggleEventDetail;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface HTMLPMultiSelectElement extends Components.PMultiSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPMultiSelectElementEventMap>(type: K, listener: (this: HTMLPMultiSelectElement, ev: PMultiSelectCustomEvent<HTMLPMultiSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPMultiSelectElementEventMap>(type: K, listener: (this: HTMLPMultiSelectElement, ev: PMultiSelectCustomEvent<HTMLPMultiSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPMultiSelectElement: {
        prototype: HTMLPMultiSelectElement;
        new (): HTMLPMultiSelectElement;
    };
    interface HTMLPMultiSelectOptionElement extends Components.PMultiSelectOption, HTMLStencilElement {
    }
    var HTMLPMultiSelectOptionElement: {
        prototype: HTMLPMultiSelectOptionElement;
        new (): HTMLPMultiSelectOptionElement;
    };
    interface HTMLPOptgroupElement extends Components.POptgroup, HTMLStencilElement {
    }
    var HTMLPOptgroupElement: {
        prototype: HTMLPOptgroupElement;
        new (): HTMLPOptgroupElement;
    };
    interface HTMLPPaginationElementEventMap {
        "update": PaginationUpdateEventDetail;
    }
    /**
     * @controlled { "props": ["activePage"], "event": "update", "isInternallyMutated": true }
     */
    interface HTMLPPaginationElement extends Components.PPagination, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPPaginationElementEventMap>(type: K, listener: (this: HTMLPPaginationElement, ev: PPaginationCustomEvent<HTMLPPaginationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPPaginationElementEventMap>(type: K, listener: (this: HTMLPPaginationElement, ev: PPaginationCustomEvent<HTMLPPaginationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPPaginationElement: {
        prototype: HTMLPPaginationElement;
        new (): HTMLPPaginationElement;
    };
    interface HTMLPPinCodeElementEventMap {
        "blur": void;
        "change": PinCodeChangeEventDetail;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface HTMLPPinCodeElement extends Components.PPinCode, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPPinCodeElementEventMap>(type: K, listener: (this: HTMLPPinCodeElement, ev: PPinCodeCustomEvent<HTMLPPinCodeElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPPinCodeElementEventMap>(type: K, listener: (this: HTMLPPinCodeElement, ev: PPinCodeCustomEvent<HTMLPPinCodeElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPPinCodeElement: {
        prototype: HTMLPPinCodeElement;
        new (): HTMLPPinCodeElement;
    };
    interface HTMLPPopoverElement extends Components.PPopover, HTMLStencilElement {
    }
    var HTMLPPopoverElement: {
        prototype: HTMLPPopoverElement;
        new (): HTMLPPopoverElement;
    };
    interface HTMLPRadioGroupElementEventMap {
        "blur": void;
        "change": RadioGroupChangeEventDetail;
    }
    interface HTMLPRadioGroupElement extends Components.PRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPRadioGroupElementEventMap>(type: K, listener: (this: HTMLPRadioGroupElement, ev: PRadioGroupCustomEvent<HTMLPRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPRadioGroupElementEventMap>(type: K, listener: (this: HTMLPRadioGroupElement, ev: PRadioGroupCustomEvent<HTMLPRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPRadioGroupElement: {
        prototype: HTMLPRadioGroupElement;
        new (): HTMLPRadioGroupElement;
    };
    interface HTMLPRadioGroupOptionElement extends Components.PRadioGroupOption, HTMLStencilElement {
    }
    var HTMLPRadioGroupOptionElement: {
        prototype: HTMLPRadioGroupOptionElement;
        new (): HTMLPRadioGroupOptionElement;
    };
    interface HTMLPScrollerElement extends Components.PScroller, HTMLStencilElement {
    }
    var HTMLPScrollerElement: {
        prototype: HTMLPScrollerElement;
        new (): HTMLPScrollerElement;
    };
    interface HTMLPSegmentedControlElementEventMap {
        "blur": void;
        "change": SegmentedControlChangeEventDetail;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface HTMLPSegmentedControlElement extends Components.PSegmentedControl, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPSegmentedControlElementEventMap>(type: K, listener: (this: HTMLPSegmentedControlElement, ev: PSegmentedControlCustomEvent<HTMLPSegmentedControlElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPSegmentedControlElementEventMap>(type: K, listener: (this: HTMLPSegmentedControlElement, ev: PSegmentedControlCustomEvent<HTMLPSegmentedControlElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPSegmentedControlElement: {
        prototype: HTMLPSegmentedControlElement;
        new (): HTMLPSegmentedControlElement;
    };
    interface HTMLPSegmentedControlItemElement extends Components.PSegmentedControlItem, HTMLStencilElement {
    }
    var HTMLPSegmentedControlItemElement: {
        prototype: HTMLPSegmentedControlItemElement;
        new (): HTMLPSegmentedControlItemElement;
    };
    interface HTMLPSelectElementEventMap {
        "blur": void;
        "change": SelectChangeEventDetail;
        "toggle": SelectToggleEventDetail;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface HTMLPSelectElement extends Components.PSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPSelectElementEventMap>(type: K, listener: (this: HTMLPSelectElement, ev: PSelectCustomEvent<HTMLPSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPSelectElementEventMap>(type: K, listener: (this: HTMLPSelectElement, ev: PSelectCustomEvent<HTMLPSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPSelectElement: {
        prototype: HTMLPSelectElement;
        new (): HTMLPSelectElement;
    };
    interface HTMLPSelectOptionElement extends Components.PSelectOption, HTMLStencilElement {
    }
    var HTMLPSelectOptionElement: {
        prototype: HTMLPSelectOptionElement;
        new (): HTMLPSelectOptionElement;
    };
    interface HTMLPSheetElementEventMap {
        "dismiss": void;
        "motionVisibleEnd": SheetMotionVisibleEndEventDetail;
        "motionHiddenEnd": SheetMotionHiddenEndEventDetail;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface HTMLPSheetElement extends Components.PSheet, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPSheetElementEventMap>(type: K, listener: (this: HTMLPSheetElement, ev: PSheetCustomEvent<HTMLPSheetElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPSheetElementEventMap>(type: K, listener: (this: HTMLPSheetElement, ev: PSheetCustomEvent<HTMLPSheetElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPSheetElement: {
        prototype: HTMLPSheetElement;
        new (): HTMLPSheetElement;
    };
    interface HTMLPSpinnerElement extends Components.PSpinner, HTMLStencilElement {
    }
    var HTMLPSpinnerElement: {
        prototype: HTMLPSpinnerElement;
        new (): HTMLPSpinnerElement;
    };
    interface HTMLPStepperHorizontalElementEventMap {
        "update": StepperHorizontalUpdateEventDetail;
    }
    interface HTMLPStepperHorizontalElement extends Components.PStepperHorizontal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPStepperHorizontalElementEventMap>(type: K, listener: (this: HTMLPStepperHorizontalElement, ev: PStepperHorizontalCustomEvent<HTMLPStepperHorizontalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPStepperHorizontalElementEventMap>(type: K, listener: (this: HTMLPStepperHorizontalElement, ev: PStepperHorizontalCustomEvent<HTMLPStepperHorizontalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPStepperHorizontalElement: {
        prototype: HTMLPStepperHorizontalElement;
        new (): HTMLPStepperHorizontalElement;
    };
    interface HTMLPStepperHorizontalItemElement extends Components.PStepperHorizontalItem, HTMLStencilElement {
    }
    var HTMLPStepperHorizontalItemElement: {
        prototype: HTMLPStepperHorizontalItemElement;
        new (): HTMLPStepperHorizontalItemElement;
    };
    interface HTMLPSwitchElementEventMap {
        "update": SwitchUpdateEventDetail;
    }
    /**
     * @controlled {"props": ["checked"], "event": "update"}
     */
    interface HTMLPSwitchElement extends Components.PSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPSwitchElementEventMap>(type: K, listener: (this: HTMLPSwitchElement, ev: PSwitchCustomEvent<HTMLPSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPSwitchElementEventMap>(type: K, listener: (this: HTMLPSwitchElement, ev: PSwitchCustomEvent<HTMLPSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPSwitchElement: {
        prototype: HTMLPSwitchElement;
        new (): HTMLPSwitchElement;
    };
    interface HTMLPTableElementEventMap {
        "update": TableUpdateEventDetail;
    }
    interface HTMLPTableElement extends Components.PTable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPTableElementEventMap>(type: K, listener: (this: HTMLPTableElement, ev: PTableCustomEvent<HTMLPTableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPTableElementEventMap>(type: K, listener: (this: HTMLPTableElement, ev: PTableCustomEvent<HTMLPTableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPTableElement: {
        prototype: HTMLPTableElement;
        new (): HTMLPTableElement;
    };
    interface HTMLPTableBodyElement extends Components.PTableBody, HTMLStencilElement {
    }
    var HTMLPTableBodyElement: {
        prototype: HTMLPTableBodyElement;
        new (): HTMLPTableBodyElement;
    };
    interface HTMLPTableCellElement extends Components.PTableCell, HTMLStencilElement {
    }
    var HTMLPTableCellElement: {
        prototype: HTMLPTableCellElement;
        new (): HTMLPTableCellElement;
    };
    interface HTMLPTableHeadElement extends Components.PTableHead, HTMLStencilElement {
    }
    var HTMLPTableHeadElement: {
        prototype: HTMLPTableHeadElement;
        new (): HTMLPTableHeadElement;
    };
    interface HTMLPTableHeadCellElement extends Components.PTableHeadCell, HTMLStencilElement {
    }
    var HTMLPTableHeadCellElement: {
        prototype: HTMLPTableHeadCellElement;
        new (): HTMLPTableHeadCellElement;
    };
    interface HTMLPTableHeadRowElement extends Components.PTableHeadRow, HTMLStencilElement {
    }
    var HTMLPTableHeadRowElement: {
        prototype: HTMLPTableHeadRowElement;
        new (): HTMLPTableHeadRowElement;
    };
    interface HTMLPTableRowElement extends Components.PTableRow, HTMLStencilElement {
    }
    var HTMLPTableRowElement: {
        prototype: HTMLPTableRowElement;
        new (): HTMLPTableRowElement;
    };
    interface HTMLPTabsElementEventMap {
        "update": TabsUpdateEventDetail;
    }
    /**
     * @controlled { "props": ["activeTabIndex"], "event": "update", "isInternallyMutated": true }
     */
    interface HTMLPTabsElement extends Components.PTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPTabsElementEventMap>(type: K, listener: (this: HTMLPTabsElement, ev: PTabsCustomEvent<HTMLPTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPTabsElementEventMap>(type: K, listener: (this: HTMLPTabsElement, ev: PTabsCustomEvent<HTMLPTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPTabsElement: {
        prototype: HTMLPTabsElement;
        new (): HTMLPTabsElement;
    };
    interface HTMLPTabsBarElementEventMap {
        "update": TabsBarUpdateEventDetail;
    }
    /**
     * @controlled {"props": ["activeTabIndex"], "event": "update"}
     */
    interface HTMLPTabsBarElement extends Components.PTabsBar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPTabsBarElementEventMap>(type: K, listener: (this: HTMLPTabsBarElement, ev: PTabsBarCustomEvent<HTMLPTabsBarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPTabsBarElementEventMap>(type: K, listener: (this: HTMLPTabsBarElement, ev: PTabsBarCustomEvent<HTMLPTabsBarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPTabsBarElement: {
        prototype: HTMLPTabsBarElement;
        new (): HTMLPTabsBarElement;
    };
    interface HTMLPTabsItemElement extends Components.PTabsItem, HTMLStencilElement {
    }
    var HTMLPTabsItemElement: {
        prototype: HTMLPTabsItemElement;
        new (): HTMLPTabsItemElement;
    };
    interface HTMLPTagElement extends Components.PTag, HTMLStencilElement {
    }
    var HTMLPTagElement: {
        prototype: HTMLPTagElement;
        new (): HTMLPTagElement;
    };
    interface HTMLPTagDismissibleElement extends Components.PTagDismissible, HTMLStencilElement {
    }
    var HTMLPTagDismissibleElement: {
        prototype: HTMLPTagDismissibleElement;
        new (): HTMLPTagDismissibleElement;
    };
    interface HTMLPTextElement extends Components.PText, HTMLStencilElement {
    }
    var HTMLPTextElement: {
        prototype: HTMLPTextElement;
        new (): HTMLPTextElement;
    };
    interface HTMLPTextListElement extends Components.PTextList, HTMLStencilElement {
    }
    var HTMLPTextListElement: {
        prototype: HTMLPTextListElement;
        new (): HTMLPTextListElement;
    };
    interface HTMLPTextListItemElement extends Components.PTextListItem, HTMLStencilElement {
    }
    var HTMLPTextListItemElement: {
        prototype: HTMLPTextListItemElement;
        new (): HTMLPTextListItemElement;
    };
    interface HTMLPTextareaElementEventMap {
        "change": TextareaChangeEventDetail;
        "blur": TextareaBlurEventDetail;
        "input": TextareaInputEventDetail;
    }
    interface HTMLPTextareaElement extends Components.PTextarea, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPTextareaElementEventMap>(type: K, listener: (this: HTMLPTextareaElement, ev: PTextareaCustomEvent<HTMLPTextareaElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPTextareaElementEventMap>(type: K, listener: (this: HTMLPTextareaElement, ev: PTextareaCustomEvent<HTMLPTextareaElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPTextareaElement: {
        prototype: HTMLPTextareaElement;
        new (): HTMLPTextareaElement;
    };
    interface HTMLPToastElement extends Components.PToast, HTMLStencilElement {
    }
    var HTMLPToastElement: {
        prototype: HTMLPToastElement;
        new (): HTMLPToastElement;
    };
    interface HTMLPToastItemElementEventMap {
        "dismiss": void;
    }
    interface HTMLPToastItemElement extends Components.PToastItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPToastItemElementEventMap>(type: K, listener: (this: HTMLPToastItemElement, ev: PToastItemCustomEvent<HTMLPToastItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPToastItemElementEventMap>(type: K, listener: (this: HTMLPToastItemElement, ev: PToastItemCustomEvent<HTMLPToastItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPToastItemElement: {
        prototype: HTMLPToastItemElement;
        new (): HTMLPToastItemElement;
    };
    interface HTMLPWordmarkElement extends Components.PWordmark, HTMLStencilElement {
    }
    var HTMLPWordmarkElement: {
        prototype: HTMLPWordmarkElement;
        new (): HTMLPWordmarkElement;
    };
    interface HTMLElementTagNameMap {
        "p-accordion": HTMLPAccordionElement;
        "p-banner": HTMLPBannerElement;
        "p-button": HTMLPButtonElement;
        "p-button-pure": HTMLPButtonPureElement;
        "p-button-tile": HTMLPButtonTileElement;
        "p-canvas": HTMLPCanvasElement;
        "p-carousel": HTMLPCarouselElement;
        "p-checkbox": HTMLPCheckboxElement;
        "p-crest": HTMLPCrestElement;
        "p-display": HTMLPDisplayElement;
        "p-divider": HTMLPDividerElement;
        "p-drilldown": HTMLPDrilldownElement;
        "p-drilldown-item": HTMLPDrilldownItemElement;
        "p-drilldown-link": HTMLPDrilldownLinkElement;
        "p-fieldset": HTMLPFieldsetElement;
        "p-flag": HTMLPFlagElement;
        "p-flyout": HTMLPFlyoutElement;
        "p-heading": HTMLPHeadingElement;
        "p-icon": HTMLPIconElement;
        "p-inline-notification": HTMLPInlineNotificationElement;
        "p-input-date": HTMLPInputDateElement;
        "p-input-email": HTMLPInputEmailElement;
        "p-input-month": HTMLPInputMonthElement;
        "p-input-number": HTMLPInputNumberElement;
        "p-input-password": HTMLPInputPasswordElement;
        "p-input-search": HTMLPInputSearchElement;
        "p-input-tel": HTMLPInputTelElement;
        "p-input-text": HTMLPInputTextElement;
        "p-input-time": HTMLPInputTimeElement;
        "p-input-url": HTMLPInputUrlElement;
        "p-input-week": HTMLPInputWeekElement;
        "p-link": HTMLPLinkElement;
        "p-link-pure": HTMLPLinkPureElement;
        "p-link-tile": HTMLPLinkTileElement;
        "p-link-tile-product": HTMLPLinkTileProductElement;
        "p-modal": HTMLPModalElement;
        "p-model-signature": HTMLPModelSignatureElement;
        "p-multi-select": HTMLPMultiSelectElement;
        "p-multi-select-option": HTMLPMultiSelectOptionElement;
        "p-optgroup": HTMLPOptgroupElement;
        "p-pagination": HTMLPPaginationElement;
        "p-pin-code": HTMLPPinCodeElement;
        "p-popover": HTMLPPopoverElement;
        "p-radio-group": HTMLPRadioGroupElement;
        "p-radio-group-option": HTMLPRadioGroupOptionElement;
        "p-scroller": HTMLPScrollerElement;
        "p-segmented-control": HTMLPSegmentedControlElement;
        "p-segmented-control-item": HTMLPSegmentedControlItemElement;
        "p-select": HTMLPSelectElement;
        "p-select-option": HTMLPSelectOptionElement;
        "p-sheet": HTMLPSheetElement;
        "p-spinner": HTMLPSpinnerElement;
        "p-stepper-horizontal": HTMLPStepperHorizontalElement;
        "p-stepper-horizontal-item": HTMLPStepperHorizontalItemElement;
        "p-switch": HTMLPSwitchElement;
        "p-table": HTMLPTableElement;
        "p-table-body": HTMLPTableBodyElement;
        "p-table-cell": HTMLPTableCellElement;
        "p-table-head": HTMLPTableHeadElement;
        "p-table-head-cell": HTMLPTableHeadCellElement;
        "p-table-head-row": HTMLPTableHeadRowElement;
        "p-table-row": HTMLPTableRowElement;
        "p-tabs": HTMLPTabsElement;
        "p-tabs-bar": HTMLPTabsBarElement;
        "p-tabs-item": HTMLPTabsItemElement;
        "p-tag": HTMLPTagElement;
        "p-tag-dismissible": HTMLPTagDismissibleElement;
        "p-text": HTMLPTextElement;
        "p-text-list": HTMLPTextListElement;
        "p-text-list-item": HTMLPTextListItemElement;
        "p-textarea": HTMLPTextareaElement;
        "p-toast": HTMLPToastElement;
        "p-toast-item": HTMLPToastItemElement;
        "p-wordmark": HTMLPWordmarkElement;
    }
}
declare namespace LocalJSX {
    /**
     * @controlled {"props": ["open"], "event": "update"}
     */
    interface PAccordion {
        /**
          * Displays the Accordion as compact version with thinner border and smaller paddings.
         */
        "compact"?: boolean;
        /**
          * Defines the heading used in accordion.
         */
        "heading"?: string;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
          * @default 'h2'
         */
        "headingTag"?: AccordionHeadingTag;
        /**
          * Emitted when accordion state is changed.
         */
        "onUpdate"?: (event: PAccordionCustomEvent<AccordionUpdateEventDetail>) => void;
        /**
          * Defines if accordion is open.
         */
        "open"?: boolean;
        /**
          * The text size.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<AccordionSize>;
        /**
          * @experimental Sticks the Accordion heading at the top, fixed while scrolling
         */
        "sticky"?: boolean;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PBanner {
        /**
          * Description of the banner.
          * @default ''
         */
        "description"?: string;
        /**
          * If false, the banner will not have a dismiss button.
          * @default true
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the banner.
          * @default ''
         */
        "heading"?: string;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
          * @default 'h5'
         */
        "headingTag"?: BannerHeadingTag;
        /**
          * Emitted when the close button is clicked.
         */
        "onDismiss"?: (event: PBannerCustomEvent<void>) => void;
        /**
          * If true, the banner is open.
          * @default false
         */
        "open"?: boolean;
        /**
          * State of the banner.
          * @default 'info'
         */
        "state"?: BannerState;
    }
    interface PButton {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonAriaAttribute>;
        /**
          * Displays as compact version.
          * @default false
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the button should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
          * @default 'none'
         */
        "icon"?: ButtonIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
          * @default false
         */
        "loading"?: boolean;
        /**
          * The name of the button, submitted as a pair with the button's value as part of the form data, when that button is used to submit the form.
         */
        "name"?: string;
        /**
          * Specifies the type of the button.
          * @default 'submit'
         */
        "type"?: ButtonType;
        /**
          * Defines the value associated with the button's name when it's submitted with the form data. This value is passed to the server in params when the form is submitted using this button.
         */
        "value"?: string;
        /**
          * The style variant of the button.
          * @default 'primary'
         */
        "variant"?: ButtonVariant;
    }
    interface PButtonPure {
        /**
          * Display button in active state.
          * @default false
         */
        "active"?: boolean;
        /**
          * Aligns the label.
          * @default 'end'
         */
        "alignLabel"?: BreakpointCustomizable<ButtonPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonPureAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the button should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown.
          * @default 'arrow-right'
         */
        "icon"?: ButtonPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
          * @default false
         */
        "loading"?: boolean;
        /**
          * The name of the button, submitted as a pair with the button's value as part of the form data, when that button is used to submit the form.
         */
        "name"?: string;
        /**
          * Size of the button.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<ButtonPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
          * @default false
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Specifies the type of the button.
          * @default 'submit'
         */
        "type"?: ButtonPureType;
        /**
          * Shows an underline under the label.
          * @default false
         */
        "underline"?: boolean;
        /**
          * Defines the value associated with the button's name when it's submitted with the form data. This value is passed to the server in params when the form is submitted using this button.
         */
        "value"?: string;
    }
    interface PButtonTile {
        /**
          * Alignment of button and description.
          * @default 'bottom'
         */
        "align"?: ButtonTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonTileAriaAttribute>;
        /**
          * Aspect ratio of the button-tile.
          * @default '4/3'
         */
        "aspectRatio"?: BreakpointCustomizable<ButtonTileAspectRatio>;
        /**
          * Displays the button-tile as compact version with description and button icon only.
          * @default false
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description"?: string;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Show gradient.
          * @default false
         */
        "gradient"?: boolean;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
          * @default 'none'
         */
        "icon"?: ButtonTileIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Label of the button.
         */
        "label"?: string;
        /**
          * Disables the button-tile and shows a loading indicator. No events will be triggered while loading state is active.
          * @default false
         */
        "loading"?: boolean;
        /**
          * Font size of the description.
          * @default 'medium'
         */
        "size"?: BreakpointCustomizable<ButtonTileSize>;
        /**
          * Specifies the type of the button.
          * @default 'submit'
         */
        "type"?: ButtonTileType;
        /**
          * Font weight of the description.
          * @default 'semi-bold'
         */
        "weight"?: BreakpointCustomizable<ButtonTileWeight>;
    }
    /**
     * @experimental 
     */
    interface PCanvas {
        /**
          * Defines the background color of the main section and auto adjust it for the sidebar
          * @default 'canvas'
         */
        "background"?: CanvasBackground;
        /**
          * Emitted when the sidebar end requests to be dismissed.
         */
        "onSidebarEndDismiss"?: (event: PCanvasCustomEvent<void>) => void;
        /**
          * Emitted when the sidebar start requests to be opened or dismissed.
         */
        "onSidebarStartUpdate"?: (event: PCanvasCustomEvent<CanvasSidebarStartUpdateEventDetail>) => void;
        /**
          * Open the sidebar on the end side
          * @default false
         */
        "sidebarEndOpen"?: boolean;
        /**
          * Open the sidebar on the start side
          * @default false
         */
        "sidebarStartOpen"?: boolean;
    }
    /**
     * @controlled { "props": ["activeSlideIndex"], "event": "update", "isInternallyMutated": true }
     */
    interface PCarousel {
        /**
          * Defines which slide to be active (zero-based numbering).
          * @default 0
         */
        "activeSlideIndex"?: number;
        /**
          * Alignment of slotted controls
          * @default 'auto'
         */
        "alignControls"?: CarouselAlignControls;
        /**
          * Alignment of heading and description
          * @default 'start'
         */
        "alignHeader"?: CarouselAlignHeader;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<CarouselAriaAttribute>;
        /**
          * Defines the description used in the carousel.
         */
        "description"?: string;
        /**
          * Indicates whether focus should be set on the center slide. If true, the carousel loops by individual slide; otherwise, it loops by page.
          * @default false
         */
        "focusOnCenterSlide"?: boolean;
        /**
          * Fades the slides out.
          * @default false
         */
        "gradient"?: boolean;
        /**
          * Defines the heading used in the carousel.
         */
        "heading"?: string;
        /**
          * Defines the heading size used in the carousel.
          * @default 'x-large'
         */
        "headingSize"?: CarouselHeadingSize;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev buttons and pagination.
         */
        "intl"?: CarouselInternationalization;
        /**
          * Emitted when carousel's content slides.
         */
        "onUpdate"?: (event: PCarouselCustomEvent<CarouselUpdateEventDetail>) => void;
        /**
          * If false, the carousel will not show pagination bullets at the bottom.
          * @default false
         */
        "pagination"?: BreakpointCustomizable<boolean>;
        /**
          * Whether the slides should rewind from last to first slide and vice versa.
          * @default false
         */
        "rewind"?: boolean;
        /**
          * Defines target of skip link (to skip carousel entries).
         */
        "skipLinkTarget"?: string;
        /**
          * Sets the amount of slides visible at the same time. Can be set to `auto` if you want to define different widths per slide via CSS.
          * @default 1
         */
        "slidesPerPage"?: BreakpointCustomizable<CarouselSlidesPerPage>;
        /**
          * Determines whether to trim spaces before/after the carousel if `focusOnCenterSlide` option is true.
          * @default false
         */
        "trimSpace"?: boolean;
        /**
          * Defines the outer spacings between the carousel and the left and right screen sides.
          * @default 'basic'
         */
        "width"?: CarouselWidth;
    }
    interface PCheckbox {
        /**
          * Reflects the checkbox current checked state and allows setting the initial checked state.
          * @default false
         */
        "checked"?: boolean;
        /**
          * Displays as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Marks the checkbox as disabled.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the checkbox should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility, it's recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Marks the checkbox as indeterminate.
          * @default false
         */
        "indeterminate"?: boolean;
        /**
          * The label text.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Disables the checkbox and shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
          * @default ''
         */
        "message"?: string;
        /**
          * The name of the checkbox.
          * @default ''
         */
        "name"?: string;
        /**
          * Emitted when the checkbox has lost focus.
         */
        "onBlur"?: (event: PCheckboxCustomEvent<CheckboxBlurEventDetail>) => void;
        /**
          * Emitted when checkbox checked property is changed.
         */
        "onChange"?: (event: PCheckboxCustomEvent<CheckboxChangeEventDetail>) => void;
        /**
          * Marks the checkbox as required.
          * @default false
         */
        "required"?: boolean;
        /**
          * The validation state.
          * @default 'none'
         */
        "state"?: CheckboxState;
        /**
          * The checkbox value. When a form is submitted, only a checkbox which is currently checked is included in the submission.
          * @default 'on'
         */
        "value"?: string;
    }
    interface PCrest {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<CrestAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Target attribute where the link should be opened.
          * @default '_self'
         */
        "target"?: CrestTarget;
    }
    interface PDisplay {
        /**
          * Text alignment of the component.
          * @default 'start'
         */
        "align"?: DisplayAlign;
        /**
          * Basic text color variations.
          * @default 'primary'
         */
        "color"?: DisplayColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
          * @default false
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "medium", l: "large"}. You always need to provide a base value when doing this.
          * @default 'large'
         */
        "size"?: BreakpointCustomizable<DisplaySize>;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
         */
        "tag"?: DisplayTag;
    }
    interface PDivider {
        /**
          * Defines color.
          * @default 'contrast-lower'
         */
        "color"?: DividerColor;
        /**
          * Defines direction.
          * @default 'horizontal'
         */
        "direction"?: BreakpointCustomizable<DividerDirection>;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     * @controlled {"props": ["activeIdentifier"], "event": "update"}
     * @experimental 
     */
    interface PDrilldown {
        /**
          * Defines which drilldown-item to be visualized as opened.
         */
        "activeIdentifier"?: string | undefined;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<DrilldownAriaAttribute>;
        /**
          * Emitted when the component requests to be dismissed.
         */
        "onDismiss"?: (event: PDrilldownCustomEvent<void>) => void;
        /**
          * Emitted when activeIdentifier is changed.
         */
        "onUpdate"?: (event: PDrilldownCustomEvent<DrilldownUpdateEventDetail>) => void;
        /**
          * If true, the drilldown is visualized as opened.
          * @default false
         */
        "open"?: boolean;
    }
    /**
     * @experimental 
     */
    interface PDrilldownItem {
        /**
          * Private property set by the component itself.
          * @default false
         */
        "cascade"?: boolean;
        /**
          * Unique identifier which controls if this item should be shown when the active-identifier on the drilldown is set to this value.
         */
        "identifier"?: string;
        /**
          * Renders back button, header section on mobile view and cascade button to reach a deeper level of the navigation structure.
         */
        "label"?: string;
        /**
          * Private property set by the component itself.
          * @default false
         */
        "primary"?: boolean;
        /**
          * Private property set by the component itself.
          * @default false
         */
        "secondary"?: boolean;
    }
    /**
     * @experimental 
     */
    interface PDrilldownLink {
        /**
          * Display link in active state.
          * @default false
         */
        "active"?: boolean;
        /**
          * Add ARIA attributes (only has effect when `href` is defined and no slotted anchor is used).
         */
        "aria"?: SelectedAriaAttributes<DrilldownLinkAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file (only has effect when `href` is defined and no slotted anchor is used).
         */
        "download"?: string;
        /**
          * When providing an url then the component will be rendered as `<a>` otherwise the component expects a slotted anchor.
         */
        "href"?: string;
        /**
          * Specifies the relationship of the target object to the link object (only has effect when `href` is defined and no slotted anchor is used).
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened (only has effect when `href` is defined and no slotted anchor is used).
          * @default '_self'
         */
        "target"?: DrilldownLinkTarget;
    }
    interface PFieldset {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaRole<'radiogroup'>;
        /**
          * The label text.
          * @default ''
         */
        "label"?: string;
        /**
          * The size of the label text.
          * @default 'medium'
         */
        "labelSize"?: FieldsetLabelSize;
        /**
          * The message styled depending on validation state.
          * @default ''
         */
        "message"?: string;
        /**
          * Marks the Fieldset as required.
          * @default false
         */
        "required"?: boolean;
        /**
          * The validation state.
          * @default 'none'
         */
        "state"?: FieldsetState;
    }
    interface PFlag {
        /**
          * A map of ARIA attributes to enhance the flag's accessibility. For example, use `{ 'aria-label': 'German flag' }` to provide a descriptive label for screen readers.
         */
        "aria"?: SelectedAriaAttributes<FlagAriaAttribute>;
        /**
          * Specifies the country flag to display. Use the two-letter ISO 3166-1 alpha-2 country code. For example, use `us` for the United States, `de` for Germany, `gb` for Great Britain.
          * @default 'de'
         */
        "name"?: FlagName;
        /**
          * The size of the flag. Pre-defined sizes are aligned with the Porsche Next typescale. Available values are `small`, `medium`, `large`, etc.
          * @default 'small'
         */
        "size"?: FlagSize;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PFlyout {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<FlyoutAriaAttribute>;
        /**
          * Defines the backdrop, 'blur' (should be used when the underlying content is not relevant for users) and 'shading' (should be used when the user still needs a visual connection to the underlying content).
          * @default 'blur'
         */
        "backdrop"?: FlyoutBackdrop;
        /**
          * Defines the background color
          * @default 'canvas'
         */
        "background"?: FlyoutBackground;
        /**
          * If true, the flyout will not be closable via backdrop click.
          * @default false
         */
        "disableBackdropClick"?: boolean;
        /**
          * Determines the footer's position behavior. When set to "fixed," the flyout content stretches to fill the full height, keeping the footer permanently at the bottom. When set to "sticky," the footer flows beneath the content and only becomes fixed if the content overflows.
          * @default 'sticky'
         */
        "footerBehavior"?: FlyoutFooterBehavior;
        /**
          * Emitted when the component requests to be dismissed.
         */
        "onDismiss"?: (event: PFlyoutCustomEvent<void>) => void;
        /**
          * Emitted when the flyout is closed and the transition is finished.
         */
        "onMotionHiddenEnd"?: (event: PFlyoutCustomEvent<FlyoutMotionHiddenEndEventDetail>) => void;
        /**
          * Emitted when the flyout is opened and the transition is finished.
         */
        "onMotionVisibleEnd"?: (event: PFlyoutCustomEvent<FlyoutMotionVisibleEndEventDetail>) => void;
        /**
          * If true, the flyout is open.
          * @default false
         */
        "open"?: boolean;
        /**
          * The position of the flyout
          * @default 'end'
         */
        "position"?: FlyoutPosition;
    }
    interface PHeading {
        /**
          * Text alignment of the component.
          * @default 'start'
         */
        "align"?: HeadingAlign;
        /**
          * Basic text color variations.
          * @default 'primary'
         */
        "color"?: HeadingColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
          * @default false
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
          * @default 'xx-large'
         */
        "size"?: BreakpointCustomizable<HeadingSize>;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
         */
        "tag"?: HeadingTag;
    }
    interface PIcon {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<IconAriaAttribute>;
        /**
          * Basic color variations.
          * @default 'primary'
         */
        "color"?: IconColor;
        /**
          * Specifies which icon to use.
          * @default 'arrow-right'
         */
        "name"?: IconName;
        /**
          * The size of the icon.
          * @default 'small'
         */
        "size"?: IconSize;
        /**
          * Specifies a whole icon path which can be used for custom icons.
         */
        "source"?: string;
    }
    interface PInlineNotification {
        /**
          * Action icon of the inline-notification.
          * @default 'arrow-right'
         */
        "actionIcon"?: InlineNotificationActionIcon;
        /**
          * Action label of the inline-notification.
         */
        "actionLabel"?: string;
        /**
          * Disables the action button and shows a loading indicator. No events will be triggered while loading state is active.
          * @default false
         */
        "actionLoading"?: boolean;
        /**
          * Description of the inline-notification.
          * @default ''
         */
        "description"?: string;
        /**
          * If false, the inline-notification will not have a dismiss button.
          * @default true
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the inline-notification.
          * @default ''
         */
        "heading"?: string;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
          * @default 'h5'
         */
        "headingTag"?: InlineNotificationHeadingTag;
        /**
          * Emitted when the action button is clicked.
         */
        "onAction"?: (event: PInlineNotificationCustomEvent<void>) => void;
        /**
          * Emitted when the close button is clicked.
         */
        "onDismiss"?: (event: PInlineNotificationCustomEvent<void>) => void;
        /**
          * State of the inline-notification.
          * @default 'info'
         */
        "state"?: InlineNotificationState;
    }
    interface PInputDate {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., auto-complete='bday' for a birthday).
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * Specifies the latest date that can be selected. The value must be a date string in YYYY-MM-DD format (e.g., max='2024-12-31').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * Specifies the earliest date that can be selected. The value must be a date string in YYYY-MM-DD format (e.g., min='2023-01-01').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the number input has lost focus.
         */
        "onBlur"?: (event: PInputDateCustomEvent<InputDateBlurEventDetail>) => void;
        /**
          * Emitted when the number input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputDateCustomEvent<InputDateChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputDateCustomEvent<InputDateInputEventDetail>) => void;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputDateState;
        /**
          * Defines the granularity of the date input. This value is given in days. The default is 1 (one day).
          * @default 1
         */
        "step"?: number;
        /**
          * The default date value for the input, in YYYY-MM-DD format (e.g., value='2025-07-02').
          * @default ''
         */
        "value"?: string;
    }
    interface PInputEmail {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='email').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Controls the visibility of the email icon.
          * @default false
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * A boolean value that, if present, it allows the user to enter a list of multiple email addresses, separated by commas (and optional whitespace). The browser will validate each email address in the list.
          * @default false
         */
        "multiple"?: boolean;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the email input has lost focus.
         */
        "onBlur"?: (event: PInputEmailCustomEvent<InputEmailBlurEventDetail>) => void;
        /**
          * Emitted when the email input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputEmailCustomEvent<InputEmailChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputEmailCustomEvent<InputEmailInputEventDetail>) => void;
        /**
          * Specifies a regular expression that the input's value must match for the value to pass constraint validation. This allows for more specific email validation rules than the browser's default (e.g., restricting to a specific domain). If provided, it overrides the browser's default email validation.
         */
        "pattern"?: string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='you@example.com'). This text is displayed when the input field is empty.
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputEmailState;
        /**
          * The default email address (or comma-separated list of addresses) for the input.
          * @default ''
         */
        "value"?: string;
    }
    interface PInputMonth {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features.
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * Specifies the latest month that can be selected. The value must be a month string in YYYY-MM format(e.g., max='2024-12').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * Specifies the earliest month that can be selected. The value must be a month string in YYYY-MM format (e.g., min='2023-01').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the number input has lost focus.
         */
        "onBlur"?: (event: PInputMonthCustomEvent<InputMonthBlurEventDetail>) => void;
        /**
          * Emitted when the number input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputMonthCustomEvent<InputMonthChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputMonthCustomEvent<InputMonthInputEventDetail>) => void;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputMonthState;
        /**
          * Defines the stepping interval in months. For example, step="1" increments by 1 month, step="12" by 1 year. The default is 1 month.
          * @default 1
         */
        "step"?: number;
        /**
          * The default month value for the input, in YYYY-MM format (e.g., value='2025-07').
          * @default ''
         */
        "value"?: string;
    }
    interface PInputNumber {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='postal-code').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Show or hide the increment/decrement stepper controls.
          * @default false
         */
        "controls"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * The max value of the number input.
         */
        "max"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * The min value of the number input.
         */
        "min"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the number input has lost focus.
         */
        "onBlur"?: (event: PInputNumberCustomEvent<InputNumberBlurEventDetail>) => void;
        /**
          * Emitted when the number input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputNumberCustomEvent<InputNumberChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputNumberCustomEvent<InputNumberInputEventDetail>) => void;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Enter a number'). This text is displayed when the input field is empty.
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputNumberState;
        /**
          * The granularity that the value must adhere to.
          * @default 1
         */
        "step"?: number;
        /**
          * The number input value.
          * @default ''
         */
        "value"?: string;
    }
    interface PInputPassword {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='current-password', autocomplete='new-password').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the password input has lost focus.
         */
        "onBlur"?: (event: PInputPasswordCustomEvent<InputPasswordBlurEventDetail>) => void;
        /**
          * Emitted when the password input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputPasswordCustomEvent<InputPasswordChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputPasswordCustomEvent<InputPasswordInputEventDetail>) => void;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Enter your password'). This text is displayed when the input field is empty.
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputPasswordState;
        /**
          * Show or hide password toggle for `input type="password"`.
          * @default false
         */
        "toggle"?: boolean;
        /**
          * The password input value.
          * @default ''
         */
        "value"?: string;
    }
    interface PInputSearch {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='on').
         */
        "autoComplete"?: string;
        /**
          * Show clear input value button
          * @default false
         */
        "clear"?: boolean;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Show search indicator icon
          * @default false
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the search input has lost focus.
         */
        "onBlur"?: (event: PInputSearchCustomEvent<InputSearchBlurEventDetail>) => void;
        /**
          * Emitted when the search input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputSearchCustomEvent<InputSearchChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputSearchCustomEvent<InputSearchInputEventDetail>) => void;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Search...'). This text is displayed when the input field is empty.
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputSearchState;
        /**
          * The search input value.
          * @default ''
         */
        "value"?: string;
    }
    interface PInputTel {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='tel').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Controls the visibility of the phone icon.
          * @default false
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the tel input has lost focus.
         */
        "onBlur"?: (event: PInputTelCustomEvent<InputTelBlurEventDetail>) => void;
        /**
          * Emitted when the tel input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputTelCustomEvent<InputTelChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputTelCustomEvent<InputTelInputEventDetail>) => void;
        /**
          * Specifies a regular expression that the input's value must match for the value to pass constraint validation. This allows for more specific tel validation rules than the browser's default. If provided, it overrides the browser's default tel validation.
         */
        "pattern"?: string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='(123) 456-7890')
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputTelState;
        /**
          * The tel input value.
          * @default ''
         */
        "value"?: string;
    }
    interface PInputText {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='name').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Show or hide the character counter.
          * @default false
         */
        "counter"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the text input has lost focus.
         */
        "onBlur"?: (event: PInputTextCustomEvent<InputTextBlurEventDetail>) => void;
        /**
          * Emitted when the text input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputTextCustomEvent<InputTextChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputTextCustomEvent<InputTextInputEventDetail>) => void;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Enter your full name'). This text is displayed when the input field is empty.
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicate whether to enable spell-checking.
         */
        "spellCheck"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputTextState;
        /**
          * The text input value.
          * @default ''
         */
        "value"?: string;
    }
    interface PInputTime {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., auto-complete='on').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * Specifies the latest time that can be selected. The value must be a time string in hh:mm or hh:mm:ss format (e.g., max='17:30').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * Specifies the earliest time that can be selected. The value must be a time string in hh:mm or hh:mm:ss format (e.g., min='09:00').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the number input has lost focus.
         */
        "onBlur"?: (event: PInputTimeCustomEvent<InputTimeBlurEventDetail>) => void;
        /**
          * Emitted when the number input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputTimeCustomEvent<InputTimeChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputTimeCustomEvent<InputTimeInputEventDetail>) => void;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputTimeState;
        /**
          * efines the granularity of the time input. The step value is given in seconds. The default is 60 (one minute). You can also specify smaller increments (e.g., step='1' for seconds, step='0.001' for milliseconds).
          * @default 60
         */
        "step"?: number;
        /**
          * The default time value for the input, in hh:mm or hh:mm:ss format (e.g., value='14:00').
          * @default ''
         */
        "value"?: string;
    }
    interface PInputUrl {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='url').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Controls the visibility of the url icon.
          * @default false
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the url input has lost focus.
         */
        "onBlur"?: (event: PInputUrlCustomEvent<InputUrlBlurEventDetail>) => void;
        /**
          * Emitted when the url input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputUrlCustomEvent<InputUrlChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputUrlCustomEvent<InputUrlInputEventDetail>) => void;
        /**
          * Specifies a regular expression that the input's value must match for the value to pass constraint validation. This allows for more specific url validation rules than the browser's default. If provided, it overrides the browser's default tel validation.
         */
        "pattern"?: string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='https://porsche.com/')
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputUrlState;
        /**
          * The url input value.
          * @default ''
         */
        "value"?: string;
    }
    interface PInputWeek {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features.
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * Specifies the latest week that can be selected. The value must be a week string in YYYY-Www format (e.g., max='2024-W52').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * Specifies the earliest week that can be selected. The value must be a week string in YYYY-Www format (e.g., min='2024-W01').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the number input has lost focus.
         */
        "onBlur"?: (event: PInputWeekCustomEvent<InputWeekBlurEventDetail>) => void;
        /**
          * Emitted when the number input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputWeekCustomEvent<InputWeekChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputWeekCustomEvent<InputWeekInputEventDetail>) => void;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
          * @default 'none'
         */
        "state"?: InputWeekState;
        /**
          * Defines the stepping interval in weeks. For example, step="1" increments by 1 week. The default is 1 month.
          * @default 1
         */
        "step"?: number;
        /**
          * The default week value for the input, in YYYY-Www format (e.g., value='2025-W27')
          * @default ''
         */
        "value"?: string;
    }
    interface PLink {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkAriaAttribute>;
        /**
          * Displays as compact version.
          * @default false
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
          * @default 'none'
         */
        "icon"?: LinkIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
          * @default '_self'
         */
        "target"?: LinkTarget;
        /**
          * The style variant of the link.
          * @default 'primary'
         */
        "variant"?: LinkVariant;
    }
    interface PLinkPure {
        /**
          * Display link in active state.
          * @default false
         */
        "active"?: boolean;
        /**
          * Aligns the label.
          * @default 'end'
         */
        "alignLabel"?: BreakpointCustomizable<LinkPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkPureAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed
          * @default 'arrow-right'
         */
        "icon"?: LinkPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Size of the link.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<LinkPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
          * @default false
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Target attribute where the link should be opened.
          * @default '_self'
         */
        "target"?: LinkPureTarget;
        /**
          * Shows an underline under the label.
          * @default false
         */
        "underline"?: boolean;
    }
    interface PLinkTile {
        /**
          * Alignment of link and description.
          * @default 'bottom'
         */
        "align"?: LinkTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkTileAriaAttribute>;
        /**
          * Aspect ratio of the link-tile.
          * @default '4/3'
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileAspectRatio>;
        /**
          * Displays the link-tile as compact version with description and link icon only.
          * @default false
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description"?: string;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show gradient.
          * @default false
         */
        "gradient"?: boolean;
        /**
          * href of the `<a>`.
         */
        "href"?: string;
        /**
          * Label of the <a />.
         */
        "label"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Font size of the description.
          * @default 'medium'
         */
        "size"?: BreakpointCustomizable<LinkTileSize>;
        /**
          * Target attribute where the link should be opened.
          * @default '_self'
         */
        "target"?: LinkTileTarget;
        /**
          * Font weight of the description.
          * @default 'semi-bold'
         */
        "weight"?: BreakpointCustomizable<LinkTileWeight>;
    }
    /**
     * @controlled {"props": ["liked"], "event": "like"}
     * @experimental 
     */
    interface PLinkTileProduct {
        /**
          * Aspect ratio of the link-tile-product.
          * @default '3/4'
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileProductAspectRatio>;
        /**
          * Additional product description.
         */
        "description"?: string;
        /**
          * Product heading.
         */
        "heading"?: string;
        /**
          * href of the `<a>`.
         */
        "href"?: string;
        /**
          * A Boolean attribute indicating that a like button should be shown.
          * @default true
         */
        "likeButton"?: boolean;
        /**
          * A Boolean attribute indicating that a product is liked.
          * @default false
         */
        "liked"?: boolean;
        /**
          * Emitted when the like button is clicked.
         */
        "onLike"?: (event: PLinkTileProductCustomEvent<LinkTileProductLikeEventDetail>) => void;
        /**
          * Product retail price (with or without discount).
         */
        "price"?: string;
        /**
          * Shows original price (recommended retail price) with line-through. Needs prop "price" to be defined, otherwise this prop has no effect.
         */
        "priceOriginal"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
          * @default '_self'
         */
        "target"?: LinkTileProductTarget;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PModal {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ModalAriaAttribute>;
        /**
          * Defines the backdrop, 'blur' (should be used when Modal is opened by user interaction, e.g. after a click on a button) and 'shading' (should be used when Modal gets opened automatically, e.g. Cookie Consent).
          * @default 'blur'
         */
        "backdrop"?: ModalBackdrop;
        /**
          * Defines the background color
          * @default 'canvas'
         */
        "background"?: ModalBackground;
        /**
          * If true, the modal will not be closable via backdrop click.
          * @default false
         */
        "disableBackdropClick"?: boolean;
        /**
          * If false, the modal will not have a dismiss button.
          * @default true
         */
        "dismissButton"?: boolean;
        /**
          * If true the modal uses max viewport height and width. Should only be used for mobile.
          * @default false
         */
        "fullscreen"?: BreakpointCustomizable<boolean>;
        /**
          * Emitted when the component requests to be dismissed.
         */
        "onDismiss"?: (event: PModalCustomEvent<void>) => void;
        /**
          * Emitted when the modal is closed and the transition is finished.
         */
        "onMotionHiddenEnd"?: (event: PModalCustomEvent<ModalMotionHiddenEndEventDetail>) => void;
        /**
          * Emitted when the modal is opened and the transition is finished.
         */
        "onMotionVisibleEnd"?: (event: PModalCustomEvent<ModalMotionVisibleEndEventDetail>) => void;
        /**
          * If true, the modal is open.
          * @default false
         */
        "open"?: boolean;
    }
    interface PModelSignature {
        /**
          * Adapts the color of the component.
          * @default 'primary'
         */
        "color"?: ModelSignatureColor;
        /**
          * Defines the fetch priority of the model signature. In the end it is just a recommendation to the browser, but it defines the priority on its own.
          * @default 'auto'
         */
        "fetchPriority"?: ModelSignatureFetchPriority;
        /**
          * Defines whether the model signature is always loaded or only loaded when it is in the viewport (this feature may not work reliably).
          * @default false
         */
        "lazy"?: boolean;
        /**
          * Adapts the model of the component.
          * @default '911'
         */
        "model"?: ModelSignatureModel;
        /**
          * When set to `true`, then all model signatures are visually aligned with each other. When set to `false` the model signature comes without any safe zone.
          * @default true
         */
        "safeZone"?: boolean;
        /**
          * Adapts the size of the component. When set to `inherit` a CSS `width` or `height` needs to be defined on the host but not both.
          * @default 'small'
         */
        "size"?: ModelSignatureSize;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PMultiSelect {
        /**
          * Displays as compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * The description text.
          * @default ''
         */
        "description"?: string;
        /**
          * Disables the multi-select
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Changes the direction to which the dropdown list appears.
          * @default 'auto'
         */
        "dropdownDirection"?: MultiSelectDropdownDirection;
        /**
          * The id of a form element the multi-select should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
          * @default ''
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
          * @default ''
         */
        "message"?: string;
        /**
          * The name of the control.
         */
        "name"?: string;
        /**
          * Emitted when the multi-select has lost focus.
         */
        "onBlur"?: (event: PMultiSelectCustomEvent<void>) => void;
        /**
          * Emitted when the selection is changed.
         */
        "onChange"?: (event: PMultiSelectCustomEvent<MultiSelectChangeEventDetail>) => void;
        /**
          * Emitted when the dropdown is toggled.
         */
        "onToggle"?: (event: PMultiSelectCustomEvent<MultiSelectToggleEventDetail>) => void;
        /**
          * A Boolean attribute indicating that an option with a non-empty string value must be selected.
          * @default false
         */
        "required"?: boolean;
        /**
          * The validation state.
          * @default 'none'
         */
        "state"?: MultiSelectState;
        /**
          * The selected values.
          * @default []
         */
        "value"?: string[];
    }
    interface PMultiSelectOption {
        /**
          * Disables the option.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The option value.
         */
        "value"?: string;
    }
    interface POptgroup {
        /**
          * Disables the optgroup.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The optgroup label.
         */
        "label"?: string;
    }
    /**
     * @controlled { "props": ["activePage"], "event": "update", "isInternallyMutated": true }
     */
    interface PPagination {
        /**
          * Index of the currently active page.
          * @default 1
         */
        "activePage"?: number;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev and page buttons.
          * @default {     root: 'Pagination',     prev: 'Previous page',     next: 'Next page',     page: 'Page',   }
         */
        "intl"?: PaginationInternationalization;
        /**
          * The total count of items which should be shown per page.
          * @default 1
         */
        "itemsPerPage"?: number;
        /**
          * Emitted when the page changes.
         */
        "onUpdate"?: (event: PPaginationCustomEvent<PaginationUpdateEventDetail>) => void;
        /**
          * Show or hide the button to jump to the last page.
          * @default true
         */
        "showLastPage"?: boolean;
        /**
          * The total count of items.
          * @default 1
         */
        "totalItemsCount"?: number;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PPinCode {
        /**
          * A boolean value that, if present, renders the pin-code as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * The description text.
          * @default ''
         */
        "description"?: string;
        /**
          * Disables the Pin Code. No events will be triggered while disabled state is active.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the pin-code should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label and description text. For better accessibility it is recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
          * @default ''
         */
        "label"?: string;
        /**
          * Number of characters of the Pin Code.
          * @default 4
         */
        "length"?: PinCodeLength;
        /**
          * Disables the Pin Code and shows a loading indicator. No events will be triggered while loading state is active.
          * @default false
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
          * @default ''
         */
        "message"?: string;
        /**
          * Name of the control.
         */
        "name"?: string;
        /**
          * Emitted when the pin-code has lost focus.
         */
        "onBlur"?: (event: PPinCodeCustomEvent<void>) => void;
        /**
          * Emitted when the input is changed.
         */
        "onChange"?: (event: PPinCodeCustomEvent<PinCodeChangeEventDetail>) => void;
        /**
          * Marks the Pin Code as required.
          * @default false
         */
        "required"?: boolean;
        /**
          * The validation state.
          * @default 'none'
         */
        "state"?: PinCodeState;
        /**
          * Pin Code type.
          * @default 'number'
         */
        "type"?: PinCodeType;
        /**
          * Sets the initial value of the Pin Code.
          * @default ''
         */
        "value"?: string;
    }
    interface PPopover {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<PopoverAriaAttribute>;
        /**
          * Descriptive text to show additional information when popover is open
         */
        "description"?: string;
        /**
          * Preferred direction in which popover should open, given there is enough space in viewport. Otherwise, it will be opened in the direction with most available space.
          * @default 'bottom'
         */
        "direction"?: PopoverDirection;
    }
    interface PRadioGroup {
        /**
          * A boolean value that, if present, renders the radio group as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the radio group.
          * @default ''
         */
        "description"?: string;
        /**
          * Defines the direction of the main and cross axis. The default is 'column' showing options vertically stacked. You always need to provide a base value when using breakpoints.
          * @default 'column'
         */
        "direction"?: BreakpointCustomizable<RadioGroupDirection>;
        /**
          * A boolean value that, if present, makes the radio group unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the radio group belongs to (useful if the radio group is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * The name of the group of radio buttons, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the radio-group has lost focus.
         */
        "onBlur"?: (event: PRadioGroupCustomEvent<void>) => void;
        /**
          * Emitted when the selected option is changed.
         */
        "onChange"?: (event: PRadioGroupCustomEvent<RadioGroupChangeEventDetail>) => void;
        /**
          * A boolean value that specifies a selection must be made from the group before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the radio group component.
          * @default 'none'
         */
        "state"?: RadioGroupState;
        /**
          * The default value for the radio-group.
          * @default ''
         */
        "value"?: string;
    }
    interface PRadioGroupOption {
        /**
          * A boolean value that, if present, makes the radio group option unusable and unclickable.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
          * @default false
         */
        "loading"?: boolean;
        /**
          * The value for the input.
         */
        "value"?: string;
    }
    interface PScroller {
        /**
          * Sets the vertical position of scroll indicator.
          * @default 'center'
         */
        "alignScrollIndicator"?: ScrollerAlignScrollIndicator;
        /**
          * Add ARIA role.
         */
        "aria"?: SelectedAriaAttributes<ScrollerAriaAttribute>;
        /**
          * Scrolls the scroll area to the left either smooth or immediately.
         */
        "scrollToPosition"?: ScrollerScrollToPosition;
        /**
          * Specifies if scrollbar should be shown.
          * @default false
         */
        "scrollbar"?: boolean;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PSegmentedControl {
        /**
          * Sets the amount of columns.
          * @default 'auto'
         */
        "columns"?: BreakpointCustomizable<SegmentedControlColumns>;
        /**
          * A boolean value that, if present, renders the segmented-control as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the segmented-control.
          * @default ''
         */
        "description"?: string;
        /**
          * Disables the segmented-control.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the segmented-control should be associated with.
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * The name of the segmented-control.
         */
        "name"?: string;
        /**
          * Emitted when the segmented-control has lost focus.
         */
        "onBlur"?: (event: PSegmentedControlCustomEvent<void>) => void;
        /**
          * Emitted when the selection is changed.
         */
        "onChange"?: (event: PSegmentedControlCustomEvent<SegmentedControlChangeEventDetail>) => void;
        /**
          * A boolean value that specifies a selection must be made from the group before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the component.
          * @default 'none'
         */
        "state"?: SegmentedControlState;
        /**
          * Sets the initial value of the segmented-control.
         */
        "value"?: string | number;
    }
    interface PSegmentedControlItem {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SegmentedControlItemAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The icon shown.
         */
        "icon"?: SegmentedControlItemIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The value of this item which is emitted by the parent element if it becomes selected. This property is **required**.
         */
        "value"?: string | number;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PSelect {
        /**
          * Displays as compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * The description text.
          * @default ''
         */
        "description"?: string;
        /**
          * Disables the select.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Changes the direction to which the dropdown list appears.
          * @default 'auto'
         */
        "dropdownDirection"?: SelectDropdownDirection;
        /**
          * Shows an input in the dropdown allowing options to be filtered. Will be ignored if the `filter` slot is used.
          * @default false
         */
        "filter"?: boolean;
        /**
          * The id of a form element the select should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
          * @default ''
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
          * @default ''
         */
        "message"?: string;
        /**
          * The name of the control.
         */
        "name"?: string;
        /**
          * Emitted when the select has lost focus.
         */
        "onBlur"?: (event: PSelectCustomEvent<void>) => void;
        /**
          * Emitted when the selection is changed.
         */
        "onChange"?: (event: PSelectCustomEvent<SelectChangeEventDetail>) => void;
        /**
          * Emitted when the dropdown is toggled.
         */
        "onToggle"?: (event: PSelectCustomEvent<SelectToggleEventDetail>) => void;
        /**
          * A Boolean attribute indicating that an option with a non-empty string value must be selected.
          * @default false
         */
        "required"?: boolean;
        /**
          * The validation state.
          * @default 'none'
         */
        "state"?: SelectState;
        /**
          * The selected value.
         */
        "value"?: string;
    }
    interface PSelectOption {
        /**
          * Disables the option.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The option value.
         */
        "value"?: string;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PSheet {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SheetAriaAttribute>;
        /**
          * Defines the background color
          * @default 'canvas'
         */
        "background"?: SheetBackground;
        /**
          * If true, the sheet will not be closable via backdrop click.
          * @default false
         */
        "disableBackdropClick"?: boolean;
        /**
          * If false, the sheet will not have a dismiss button.
          * @default true
         */
        "dismissButton"?: boolean;
        /**
          * Emitted when the component requests to be dismissed.
         */
        "onDismiss"?: (event: PSheetCustomEvent<void>) => void;
        /**
          * Emitted when the sheet is closed and the transition is finished.
         */
        "onMotionHiddenEnd"?: (event: PSheetCustomEvent<SheetMotionHiddenEndEventDetail>) => void;
        /**
          * Emitted when the sheet is opened and the transition is finished.
         */
        "onMotionVisibleEnd"?: (event: PSheetCustomEvent<SheetMotionVisibleEndEventDetail>) => void;
        /**
          * If true, the sheet is open.
          * @default false
         */
        "open"?: boolean;
    }
    interface PSpinner {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SpinnerAriaAttribute>;
        /**
          * Size of the spinner.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<SpinnerSize>;
    }
    interface PStepperHorizontal {
        /**
          * Emitted when active step is changed.
         */
        "onUpdate"?: (event: PStepperHorizontalCustomEvent<StepperHorizontalUpdateEventDetail>) => void;
        /**
          * The text size.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<StepperHorizontalSize>;
    }
    interface PStepperHorizontalItem {
        /**
          * Disables the stepper-horizontal-item. No events will be triggered while disabled state is active.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * The validation state.
         */
        "state"?: StepperHorizontalItemState;
    }
    /**
     * @controlled {"props": ["checked"], "event": "update"}
     */
    interface PSwitch {
        /**
          * Aligns the label.
          * @default 'end'
         */
        "alignLabel"?: BreakpointCustomizable<SwitchAlignLabel>;
        /**
          * Visualize the switch with on/off status.
          * @default false
         */
        "checked"?: boolean;
        /**
          * Displays as compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Disables the switch. No events will be triggered while disabled state is active.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Disables the switch and shows a loading indicator. No events will be triggered while loading state is active.
          * @default false
         */
        "loading"?: boolean;
        /**
          * Emitted when checked status is changed.
         */
        "onUpdate"?: (event: PSwitchCustomEvent<SwitchUpdateEventDetail>) => void;
        /**
          * Stretches the contents to max available space.
          * @default false
         */
        "stretch"?: BreakpointCustomizable<boolean>;
    }
    interface PTable {
        /**
          * A caption describing the contents of the table for accessibility only. This won't be visible in the browser. Use an element with an attribute of `slot="caption"` for a visible caption.
         */
        "caption"?: string;
        /**
          * Displays as compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Controls the layout behavior of the table.
          * @default 'auto'
         */
        "layout"?: TableLayout;
        /**
          * Emitted when sorting is changed.
         */
        "onUpdate"?: (event: PTableCustomEvent<TableUpdateEventDetail>) => void;
    }
    interface PTableBody {
    }
    interface PTableCell {
        /**
          * Displays slotted text multiline or forced into a single line.
          * @default false
         */
        "multiline"?: boolean;
    }
    interface PTableHead {
    }
    interface PTableHeadCell {
        /**
          * Hides the label but stays accessible for screen readers. This property only takes effect when sort property is not defined.
          * @default false
         */
        "hideLabel"?: boolean;
        /**
          * Displays slotted text multiline or forced into a single line.
          * @default false
         */
        "multiline"?: boolean;
        /**
          * Defines sortability properties.
         */
        "sort"?: TableHeadCellSort;
    }
    interface PTableHeadRow {
    }
    interface PTableRow {
    }
    /**
     * @controlled { "props": ["activeTabIndex"], "event": "update", "isInternallyMutated": true }
     */
    interface PTabs {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering).
          * @default 0
         */
        "activeTabIndex"?: number;
        /**
          * Emitted when active tab is changed.
         */
        "onUpdate"?: (event: PTabsCustomEvent<TabsUpdateEventDetail>) => void;
        /**
          * The text size.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<TabsSize>;
        /**
          * The text weight.
          * @default 'regular'
         */
        "weight"?: TabsWeight;
    }
    /**
     * @controlled {"props": ["activeTabIndex"], "event": "update"}
     */
    interface PTabsBar {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering), undefined if none should be selected.
         */
        "activeTabIndex"?: number | undefined;
        /**
          * Emitted when active tab is changed.
         */
        "onUpdate"?: (event: PTabsBarCustomEvent<TabsBarUpdateEventDetail>) => void;
        /**
          * The text size.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<TabsBarSize>;
        /**
          * The text weight.
          * @default 'regular'
         */
        "weight"?: TabsBarWeight;
    }
    interface PTabsItem {
        /**
          * Defines the label used in tabs.
         */
        "label"?: string;
    }
    interface PTag {
        /**
          * Displays as compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * The icon shown.
          * @default 'none'
         */
        "icon"?: TagIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Background color variations.
          * @default 'secondary'
         */
        "variant"?: TagVariant;
    }
    interface PTagDismissible {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<TagDismissibleAriaAttribute>;
        /**
          * A boolean value that, if present, renders the tag dismissible as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * The label text.
         */
        "label"?: string;
    }
    interface PText {
        /**
          * Text alignment of the component.
          * @default 'start'
         */
        "align"?: TextAlign;
        /**
          * Basic text color variations.
          * @default 'primary'
         */
        "color"?: TextColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
          * @default false
         */
        "ellipsis"?: boolean;
        /**
          * Size of the text. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
          * @default 'small'
         */
        "size"?: BreakpointCustomizable<TextSize>;
        /**
          * Sets a custom HTML tag depending on the usage of the text component.
          * @default 'p'
         */
        "tag"?: TextTag;
        /**
          * The weight of the text.
          * @default 'regular'
         */
        "weight"?: TextWeight;
    }
    interface PTextList {
        /**
          * The list style type.
          * @default 'unordered'
         */
        "type"?: TextListType;
    }
    interface PTextListItem {
    }
    interface PTextarea {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='on').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the textarea as a compact version.
          * @default false
         */
        "compact"?: boolean;
        /**
          * Show or hide the character counter.
          * @default false
         */
        "counter"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the textarea.
          * @default ''
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the textarea unusable and unclickable. The value will not be submitted with the form.
          * @default false
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the textarea belongs to (useful if the textarea is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
          * @default false
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
          * @default ''
         */
        "label"?: string;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the textarea.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
          * @default ''
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the textarea's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the textarea, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the textarea has lost focus.
         */
        "onBlur"?: (event: PTextareaCustomEvent<TextareaBlurEventDetail>) => void;
        /**
          * Emitted when the textarea loses focus after its value was changed.
         */
        "onChange"?: (event: PTextareaCustomEvent<TextareaChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PTextareaCustomEvent<TextareaInputEventDetail>) => void;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Write your message here...'). This text is displayed when the textarea is empty.
          * @default ''
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the textarea uneditable by the user, but its value will still be submitted with the form.
          * @default false
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the textarea must be filled out before the form can be submitted.
          * @default false
         */
        "required"?: boolean;
        /**
          * Controls whether the textarea is resizable and in which direction.
          * @default 'vertical'
         */
        "resize"?: TextareaResize;
        /**
          * The number of rows. Has no effect when field-sizing CSS Variable '--p-textarea-field-sizing' is set to 'content'.
          * @default 7
         */
        "rows"?: number;
        /**
          * Specifies whether the textarea should have its spelling and grammar checked
         */
        "spellCheck"?: boolean;
        /**
          * Indicates the validation or overall status of the textarea component.
          * @default 'none'
         */
        "state"?: TextareaState;
        /**
          * The textarea value.
          * @default ''
         */
        "value"?: string;
        /**
          * Handles wrapping behavior of elements.
          * @default 'soft'
         */
        "wrap"?: TextareaWrap;
    }
    interface PToast {
    }
    interface PToastItem {
        /**
          * Emitted when the close button is clicked.
         */
        "onDismiss"?: (event: PToastItemCustomEvent<void>) => void;
        /**
          * State of the toast-item.
          * @default 'info'
         */
        "state"?: ToastState;
        /**
          * Text of the toast-item.
          * @default ''
         */
        "text"?: string;
    }
    interface PWordmark {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<WordmarkAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Adapts sizing of wordmark.
          * @default 'small'
         */
        "size"?: WordmarkSize;
        /**
          * Target attribute where the link should be opened.
          * @default '_self'
         */
        "target"?: WordmarkTarget;
    }

    interface PAccordionAttributes {
        "size": BreakpointCustomizable<AccordionSize>;
        "heading": string;
        "headingTag": AccordionHeadingTag;
        "open": boolean;
        "compact": boolean;
        "sticky": boolean;
    }
    interface PBannerAttributes {
        "open": boolean;
        "heading": string;
        "headingTag": BannerHeadingTag;
        "description": string;
        "state": BannerState;
        "dismissButton": boolean;
    }
    interface PButtonAttributes {
        "type": ButtonType;
        "name": string;
        "value": string;
        "disabled": boolean;
        "loading": boolean;
        "variant": ButtonVariant;
        "icon": ButtonIcon;
        "iconSource": string;
        "hideLabel": string;
        "compact": string;
        "aria": SelectedAriaAttributes<ButtonAriaAttribute>;
        "form": string;
    }
    interface PButtonPureAttributes {
        "type": ButtonPureType;
        "name": string;
        "value": string;
        "disabled": boolean;
        "loading": boolean;
        "size": BreakpointCustomizable<ButtonPureSize>;
        "icon": ButtonPureIcon;
        "iconSource": string;
        "underline": boolean;
        "active": boolean;
        "hideLabel": string;
        "alignLabel": BreakpointCustomizable<ButtonPureAlignLabel>;
        "stretch": string;
        "aria": SelectedAriaAttributes<ButtonPureAriaAttribute>;
        "form": string;
    }
    interface PButtonTileAttributes {
        "size": BreakpointCustomizable<ButtonTileSize>;
        "weight": BreakpointCustomizable<ButtonTileWeight>;
        "aspectRatio": BreakpointCustomizable<ButtonTileAspectRatio>;
        "label": string;
        "description": string;
        "align": ButtonTileAlign;
        "gradient": boolean;
        "compact": string;
        "type": ButtonTileType;
        "disabled": boolean;
        "loading": boolean;
        "icon": ButtonTileIcon;
        "iconSource": string;
        "aria": SelectedAriaAttributes<ButtonTileAriaAttribute>;
    }
    interface PCanvasAttributes {
        "sidebarStartOpen": boolean;
        "sidebarEndOpen": boolean;
        "background": CanvasBackground;
    }
    interface PCarouselAttributes {
        "heading": string;
        "headingSize": CarouselHeadingSize;
        "description": string;
        "alignHeader": CarouselAlignHeader;
        "alignControls": CarouselAlignControls;
        "rewind": boolean;
        "width": CarouselWidth;
        "slidesPerPage": string;
        "pagination": string;
        "aria": SelectedAriaAttributes<CarouselAriaAttribute>;
        "intl": CarouselInternationalization;
        "activeSlideIndex": number;
        "skipLinkTarget": string;
        "focusOnCenterSlide": boolean;
        "gradient": boolean;
        "trimSpace": boolean;
    }
    interface PCheckboxAttributes {
        "name": string;
        "required": boolean;
        "disabled": boolean;
        "indeterminate": boolean;
        "checked": boolean;
        "form": string;
        "value": string;
        "label": string;
        "state": CheckboxState;
        "message": string;
        "hideLabel": string;
        "loading": boolean;
        "compact": boolean;
    }
    interface PCrestAttributes {
        "href": string;
        "target": CrestTarget;
        "aria": SelectedAriaAttributes<CrestAriaAttribute>;
    }
    interface PDisplayAttributes {
        "tag": DisplayTag;
        "size": BreakpointCustomizable<DisplaySize>;
        "align": DisplayAlign;
        "color": DisplayColor;
        "ellipsis": boolean;
    }
    interface PDividerAttributes {
        "color": DividerColor;
        "direction": BreakpointCustomizable<DividerDirection>;
    }
    interface PDrilldownAttributes {
        "open": boolean;
        "activeIdentifier": string | undefined;
        "aria": SelectedAriaAttributes<DrilldownAriaAttribute>;
    }
    interface PDrilldownItemAttributes {
        "label": string;
        "identifier": string;
        "primary": boolean;
        "secondary": boolean;
        "cascade": boolean;
    }
    interface PDrilldownLinkAttributes {
        "href": string;
        "active": boolean;
        "target": DrilldownLinkTarget;
        "download": string;
        "rel": string;
        "aria": SelectedAriaAttributes<DrilldownLinkAriaAttribute>;
    }
    interface PFieldsetAttributes {
        "label": string;
        "labelSize": FieldsetLabelSize;
        "required": boolean;
        "state": FieldsetState;
        "message": string;
    }
    interface PFlagAttributes {
        "name": FlagName;
        "size": FlagSize;
        "aria": SelectedAriaAttributes<FlagAriaAttribute>;
    }
    interface PFlyoutAttributes {
        "open": boolean;
        "position": FlyoutPosition;
        "disableBackdropClick": boolean;
        "background": FlyoutBackground;
        "backdrop": FlyoutBackdrop;
        "footerBehavior": FlyoutFooterBehavior;
        "aria": SelectedAriaAttributes<FlyoutAriaAttribute>;
    }
    interface PHeadingAttributes {
        "tag": HeadingTag;
        "size": BreakpointCustomizable<HeadingSize>;
        "align": HeadingAlign;
        "color": HeadingColor;
        "ellipsis": boolean;
    }
    interface PIconAttributes {
        "name": IconName;
        "source": string;
        "color": IconColor;
        "size": IconSize;
        "aria": SelectedAriaAttributes<IconAriaAttribute>;
    }
    interface PInlineNotificationAttributes {
        "heading": string;
        "headingTag": InlineNotificationHeadingTag;
        "description": string;
        "state": InlineNotificationState;
        "dismissButton": boolean;
        "actionLabel": string;
        "actionLoading": boolean;
        "actionIcon": InlineNotificationActionIcon;
    }
    interface PInputDateAttributes {
        "label": string;
        "step": number;
        "description": string;
        "compact": boolean;
        "name": string;
        "value": string;
        "autoComplete": string;
        "readOnly": boolean;
        "form": string;
        "max": string;
        "min": string;
        "disabled": boolean;
        "required": boolean;
        "loading": boolean;
        "state": InputDateState;
        "message": string;
        "hideLabel": string;
    }
    interface PInputEmailAttributes {
        "label": string;
        "description": string;
        "compact": boolean;
        "name": string;
        "value": string;
        "autoComplete": string;
        "readOnly": boolean;
        "form": string;
        "maxLength": number;
        "minLength": number;
        "placeholder": string;
        "disabled": boolean;
        "required": boolean;
        "loading": boolean;
        "state": InputEmailState;
        "indicator": boolean;
        "message": string;
        "hideLabel": string;
        "multiple": boolean;
        "pattern": string;
    }
    interface PInputMonthAttributes {
        "label": string;
        "step": number;
        "description": string;
        "compact": boolean;
        "name": string;
        "value": string;
        "autoComplete": string;
        "readOnly": boolean;
        "form": string;
        "max": string;
        "min": string;
        "disabled": boolean;
        "required": boolean;
        "loading": boolean;
        "state": InputMonthState;
        "message": string;
        "hideLabel": string;
    }
    interface PInputNumberAttributes {
        "label": string;
        "step": number;
        "description": string;
        "compact": boolean;
        "name": string;
        "value": string;
        "autoComplete": string;
        "readOnly": boolean;
        "form": string;
        "max": number;
        "min": number;
        "placeholder": string;
        "disabled": boolean;
        "required": boolean;
        "loading": boolean;
        "state": InputNumberState;
        "message": string;
        "hideLabel": string;
        "controls": boolean;
    }
    interface PInputPasswordAttributes {
        "label": string;
        "description": string;
        "compact": boolean;
        "name": string;
        "value": string;
        "autoComplete": string;
        "readOnly": boolean;
        "form": string;
        "maxLength": number;
        "minLength": number;
        "placeholder": string;
        "disabled": boolean;
        "required": boolean;
        "loading": boolean;
        "state": InputPasswordState;
        "message": string;
        "hideLabel": string;
        "toggle": boolean;
    }
    interface PInputSearchAttributes {
        "label": string;
        "description": string;
        "compact": boolean;
        "name": string;
        "value": string;
        "autoComplete": string;
        "clear": boolean;
        "indicator": boolean;
        "readOnly": boolean;
        "form": string;
        "maxLength": number;
        "minLength": number;
        "placeholder": string;
        "disabled": boolean;
        "required": boolean;
        "loading": boolean;
        "state": InputSearchState;
        "message": string;
        "hideLabel": string;
    }
    interface PInputTelAttributes {
        "label": string;
        "description": string;
        "compact": boolean;
        "name": string;
        "value": string;
        "autoComplete": string;
        "readOnly": boolean;
        "form": string;
        "maxLength": number;
        "minLength": number;
        "placeholder": string;
        "disabled": boolean;
        "required": boolean;
        "loading": boolean;
        "state": InputTelState;
        "indicator": boolean;
        "message": string;
        "hideLabel": string;
        "pattern": string;
    }
    interface PInputTextAttributes {
        "label": string;
        "spellCheck": boolean;
        "description": string;
        "compact": boolean;
        "name": string;
        "value": string;
        "autoComplete": string;
        "readOnly": boolean;
        "form": string;
        "maxLength": number;
        "minLength": number;
        "placeholder": string;
        "disabled": boolean;
        "required": boolean;
        "loading": boolean;
        "state": InputTextState;
        "message": string;
        "hideLabel": string;
        "counter": boolean;
    }
    interface PInputTimeAttributes {
        "label": string;
        "step": number;
        "description": string;
        "compact": boolean;
        "name": string;
        "value": string;
        "autoComplete": string;
        "readOnly": boolean;
        "form": string;
        "max": string;
        "min": string;
        "disabled": boolean;
        "required": boolean;
        "loading": boolean;
        "state": InputTimeState;
        "message": string;
        "hideLabel": string;
    }
    interface PInputUrlAttributes {
        "label": string;
        "description": string;
        "compact": boolean;
        "name": string;
        "value": string;
        "autoComplete": string;
        "readOnly": boolean;
        "form": string;
        "maxLength": number;
        "minLength": number;
        "placeholder": string;
        "disabled": boolean;
        "required": boolean;
        "loading": boolean;
        "state": InputUrlState;
        "indicator": boolean;
        "message": string;
        "hideLabel": string;
        "pattern": string;
    }
    interface PInputWeekAttributes {
        "label": string;
        "step": number;
        "description": string;
        "compact": boolean;
        "name": string;
        "value": string;
        "autoComplete": string;
        "readOnly": boolean;
        "form": string;
        "max": string;
        "min": string;
        "disabled": boolean;
        "required": boolean;
        "loading": boolean;
        "state": InputWeekState;
        "message": string;
        "hideLabel": string;
    }
    interface PLinkAttributes {
        "variant": LinkVariant;
        "icon": LinkIcon;
        "iconSource": string;
        "href": string;
        "target": LinkTarget;
        "download": string;
        "rel": string;
        "hideLabel": string;
        "compact": string;
        "aria": SelectedAriaAttributes<LinkAriaAttribute>;
    }
    interface PLinkPureAttributes {
        "alignLabel": BreakpointCustomizable<LinkPureAlignLabel>;
        "stretch": string;
        "size": BreakpointCustomizable<LinkPureSize>;
        "icon": LinkPureIcon;
        "iconSource": string;
        "underline": boolean;
        "href": string;
        "active": boolean;
        "hideLabel": string;
        "target": LinkPureTarget;
        "download": string;
        "rel": string;
        "aria": SelectedAriaAttributes<LinkPureAriaAttribute>;
    }
    interface PLinkTileAttributes {
        "size": BreakpointCustomizable<LinkTileSize>;
        "weight": BreakpointCustomizable<LinkTileWeight>;
        "aspectRatio": BreakpointCustomizable<LinkTileAspectRatio>;
        "label": string;
        "description": string;
        "align": LinkTileAlign;
        "gradient": boolean;
        "compact": string;
        "href": string;
        "target": LinkTileTarget;
        "download": string;
        "rel": string;
        "aria": SelectedAriaAttributes<LinkTileAriaAttribute>;
    }
    interface PLinkTileProductAttributes {
        "heading": string;
        "price": string;
        "priceOriginal": string;
        "description": string;
        "likeButton": boolean;
        "liked": boolean;
        "href": string;
        "aspectRatio": BreakpointCustomizable<LinkTileProductAspectRatio>;
        "target": LinkTileProductTarget;
        "rel": string;
    }
    interface PModalAttributes {
        "open": boolean;
        "dismissButton": boolean;
        "disableBackdropClick": boolean;
        "backdrop": ModalBackdrop;
        "background": ModalBackground;
        "fullscreen": string;
        "aria": SelectedAriaAttributes<ModalAriaAttribute>;
    }
    interface PModelSignatureAttributes {
        "model": ModelSignatureModel;
        "safeZone": boolean;
        "fetchPriority": ModelSignatureFetchPriority;
        "lazy": boolean;
        "size": ModelSignatureSize;
        "color": ModelSignatureColor;
    }
    interface PMultiSelectAttributes {
        "label": string;
        "description": string;
        "name": string;
        "state": MultiSelectState;
        "message": string;
        "hideLabel": string;
        "disabled": boolean;
        "required": boolean;
        "dropdownDirection": MultiSelectDropdownDirection;
        "compact": boolean;
        "form": string;
    }
    interface PMultiSelectOptionAttributes {
        "value": string;
        "disabled": boolean;
    }
    interface POptgroupAttributes {
        "label": string;
        "disabled": boolean;
    }
    interface PPaginationAttributes {
        "totalItemsCount": number;
        "itemsPerPage": number;
        "activePage": number;
        "showLastPage": boolean;
        "intl": PaginationInternationalization;
    }
    interface PPinCodeAttributes {
        "label": string;
        "description": string;
        "name": string;
        "length": PinCodeLength;
        "hideLabel": string;
        "state": PinCodeState;
        "disabled": boolean;
        "loading": boolean;
        "required": boolean;
        "message": string;
        "type": PinCodeType;
        "value": string;
        "compact": boolean;
        "form": string;
    }
    interface PPopoverAttributes {
        "direction": PopoverDirection;
        "description": string;
        "aria": SelectedAriaAttributes<PopoverAriaAttribute>;
    }
    interface PRadioGroupAttributes {
        "label": string;
        "description": string;
        "compact": boolean;
        "direction": BreakpointCustomizable<RadioGroupDirection>;
        "name": string;
        "value": string;
        "form": string;
        "disabled": boolean;
        "required": boolean;
        "loading": boolean;
        "state": RadioGroupState;
        "message": string;
        "hideLabel": string;
    }
    interface PRadioGroupOptionAttributes {
        "value": string;
        "label": string;
        "disabled": boolean;
        "loading": boolean;
    }
    interface PScrollerAttributes {
        "scrollToPosition": ScrollerScrollToPosition;
        "alignScrollIndicator": ScrollerAlignScrollIndicator;
        "scrollbar": boolean;
        "aria": SelectedAriaAttributes<ScrollerAriaAttribute>;
    }
    interface PSegmentedControlAttributes {
        "label": string;
        "description": string;
        "value": string;
        "name": string;
        "compact": boolean;
        "state": SegmentedControlState;
        "required": boolean;
        "message": string;
        "hideLabel": string;
        "columns": string;
        "form": string;
        "disabled": boolean;
    }
    interface PSegmentedControlItemAttributes {
        "value": string;
        "disabled": boolean;
        "label": string;
        "icon": SegmentedControlItemIcon;
        "iconSource": string;
        "aria": SelectedAriaAttributes<SegmentedControlItemAriaAttribute>;
    }
    interface PSelectAttributes {
        "label": string;
        "description": string;
        "name": string;
        "value": string;
        "state": SelectState;
        "message": string;
        "hideLabel": string;
        "disabled": boolean;
        "required": boolean;
        "dropdownDirection": SelectDropdownDirection;
        "filter": boolean;
        "compact": boolean;
        "form": string;
    }
    interface PSelectOptionAttributes {
        "value": string;
        "disabled": boolean;
    }
    interface PSheetAttributes {
        "open": boolean;
        "dismissButton": boolean;
        "disableBackdropClick": boolean;
        "background": SheetBackground;
        "aria": SelectedAriaAttributes<SheetAriaAttribute>;
    }
    interface PSpinnerAttributes {
        "size": BreakpointCustomizable<SpinnerSize>;
        "aria": SelectedAriaAttributes<SpinnerAriaAttribute>;
    }
    interface PStepperHorizontalAttributes {
        "size": BreakpointCustomizable<StepperHorizontalSize>;
    }
    interface PStepperHorizontalItemAttributes {
        "state": StepperHorizontalItemState;
        "disabled": boolean;
    }
    interface PSwitchAttributes {
        "alignLabel": BreakpointCustomizable<SwitchAlignLabel>;
        "hideLabel": string;
        "stretch": string;
        "checked": boolean;
        "disabled": boolean;
        "loading": boolean;
        "compact": boolean;
    }
    interface PTableAttributes {
        "caption": string;
        "compact": boolean;
        "layout": TableLayout;
    }
    interface PTableCellAttributes {
        "multiline": boolean;
    }
    interface PTableHeadCellAttributes {
        "hideLabel": boolean;
        "multiline": boolean;
    }
    interface PTabsAttributes {
        "size": BreakpointCustomizable<TabsSize>;
        "weight": TabsWeight;
        "activeTabIndex": number;
    }
    interface PTabsBarAttributes {
        "size": BreakpointCustomizable<TabsBarSize>;
        "weight": TabsBarWeight;
        "activeTabIndex": number | undefined;
    }
    interface PTabsItemAttributes {
        "label": string;
    }
    interface PTagAttributes {
        "variant": TagVariant;
        "icon": TagIcon;
        "iconSource": string;
        "compact": boolean;
    }
    interface PTagDismissibleAttributes {
        "label": string;
        "aria": SelectedAriaAttributes<TagDismissibleAriaAttribute>;
        "compact": boolean;
    }
    interface PTextAttributes {
        "tag": TextTag;
        "size": BreakpointCustomizable<TextSize>;
        "weight": TextWeight;
        "align": TextAlign;
        "color": TextColor;
        "ellipsis": boolean;
    }
    interface PTextListAttributes {
        "type": TextListType;
    }
    interface PTextareaAttributes {
        "label": string;
        "description": string;
        "compact": boolean;
        "name": string;
        "value": string;
        "state": TextareaState;
        "message": string;
        "hideLabel": string;
        "counter": boolean;
        "placeholder": string;
        "required": boolean;
        "disabled": boolean;
        "maxLength": number;
        "minLength": number;
        "form": string;
        "rows": number;
        "autoComplete": string;
        "spellCheck": boolean;
        "wrap": TextareaWrap;
        "resize": TextareaResize;
        "readOnly": boolean;
    }
    interface PToastItemAttributes {
        "text": string;
        "state": ToastState;
    }
    interface PWordmarkAttributes {
        "size": WordmarkSize;
        "href": string;
        "target": WordmarkTarget;
        "aria": SelectedAriaAttributes<WordmarkAriaAttribute>;
    }

    interface IntrinsicElements {
        "p-accordion": Omit<PAccordion, keyof PAccordionAttributes> & { [K in keyof PAccordion & keyof PAccordionAttributes]?: PAccordion[K] } & { [K in keyof PAccordion & keyof PAccordionAttributes as `attr:${K}`]?: PAccordionAttributes[K] } & { [K in keyof PAccordion & keyof PAccordionAttributes as `prop:${K}`]?: PAccordion[K] };
        "p-banner": Omit<PBanner, keyof PBannerAttributes> & { [K in keyof PBanner & keyof PBannerAttributes]?: PBanner[K] } & { [K in keyof PBanner & keyof PBannerAttributes as `attr:${K}`]?: PBannerAttributes[K] } & { [K in keyof PBanner & keyof PBannerAttributes as `prop:${K}`]?: PBanner[K] };
        "p-button": Omit<PButton, keyof PButtonAttributes> & { [K in keyof PButton & keyof PButtonAttributes]?: PButton[K] } & { [K in keyof PButton & keyof PButtonAttributes as `attr:${K}`]?: PButtonAttributes[K] } & { [K in keyof PButton & keyof PButtonAttributes as `prop:${K}`]?: PButton[K] };
        "p-button-pure": Omit<PButtonPure, keyof PButtonPureAttributes> & { [K in keyof PButtonPure & keyof PButtonPureAttributes]?: PButtonPure[K] } & { [K in keyof PButtonPure & keyof PButtonPureAttributes as `attr:${K}`]?: PButtonPureAttributes[K] } & { [K in keyof PButtonPure & keyof PButtonPureAttributes as `prop:${K}`]?: PButtonPure[K] };
        "p-button-tile": Omit<PButtonTile, keyof PButtonTileAttributes> & { [K in keyof PButtonTile & keyof PButtonTileAttributes]?: PButtonTile[K] } & { [K in keyof PButtonTile & keyof PButtonTileAttributes as `attr:${K}`]?: PButtonTileAttributes[K] } & { [K in keyof PButtonTile & keyof PButtonTileAttributes as `prop:${K}`]?: PButtonTile[K] };
        "p-canvas": Omit<PCanvas, keyof PCanvasAttributes> & { [K in keyof PCanvas & keyof PCanvasAttributes]?: PCanvas[K] } & { [K in keyof PCanvas & keyof PCanvasAttributes as `attr:${K}`]?: PCanvasAttributes[K] } & { [K in keyof PCanvas & keyof PCanvasAttributes as `prop:${K}`]?: PCanvas[K] };
        "p-carousel": Omit<PCarousel, keyof PCarouselAttributes> & { [K in keyof PCarousel & keyof PCarouselAttributes]?: PCarousel[K] } & { [K in keyof PCarousel & keyof PCarouselAttributes as `attr:${K}`]?: PCarouselAttributes[K] } & { [K in keyof PCarousel & keyof PCarouselAttributes as `prop:${K}`]?: PCarousel[K] };
        "p-checkbox": Omit<PCheckbox, keyof PCheckboxAttributes> & { [K in keyof PCheckbox & keyof PCheckboxAttributes]?: PCheckbox[K] } & { [K in keyof PCheckbox & keyof PCheckboxAttributes as `attr:${K}`]?: PCheckboxAttributes[K] } & { [K in keyof PCheckbox & keyof PCheckboxAttributes as `prop:${K}`]?: PCheckbox[K] };
        "p-crest": Omit<PCrest, keyof PCrestAttributes> & { [K in keyof PCrest & keyof PCrestAttributes]?: PCrest[K] } & { [K in keyof PCrest & keyof PCrestAttributes as `attr:${K}`]?: PCrestAttributes[K] } & { [K in keyof PCrest & keyof PCrestAttributes as `prop:${K}`]?: PCrest[K] };
        "p-display": Omit<PDisplay, keyof PDisplayAttributes> & { [K in keyof PDisplay & keyof PDisplayAttributes]?: PDisplay[K] } & { [K in keyof PDisplay & keyof PDisplayAttributes as `attr:${K}`]?: PDisplayAttributes[K] } & { [K in keyof PDisplay & keyof PDisplayAttributes as `prop:${K}`]?: PDisplay[K] };
        "p-divider": Omit<PDivider, keyof PDividerAttributes> & { [K in keyof PDivider & keyof PDividerAttributes]?: PDivider[K] } & { [K in keyof PDivider & keyof PDividerAttributes as `attr:${K}`]?: PDividerAttributes[K] } & { [K in keyof PDivider & keyof PDividerAttributes as `prop:${K}`]?: PDivider[K] };
        "p-drilldown": Omit<PDrilldown, keyof PDrilldownAttributes> & { [K in keyof PDrilldown & keyof PDrilldownAttributes]?: PDrilldown[K] } & { [K in keyof PDrilldown & keyof PDrilldownAttributes as `attr:${K}`]?: PDrilldownAttributes[K] } & { [K in keyof PDrilldown & keyof PDrilldownAttributes as `prop:${K}`]?: PDrilldown[K] };
        "p-drilldown-item": Omit<PDrilldownItem, keyof PDrilldownItemAttributes> & { [K in keyof PDrilldownItem & keyof PDrilldownItemAttributes]?: PDrilldownItem[K] } & { [K in keyof PDrilldownItem & keyof PDrilldownItemAttributes as `attr:${K}`]?: PDrilldownItemAttributes[K] } & { [K in keyof PDrilldownItem & keyof PDrilldownItemAttributes as `prop:${K}`]?: PDrilldownItem[K] };
        "p-drilldown-link": Omit<PDrilldownLink, keyof PDrilldownLinkAttributes> & { [K in keyof PDrilldownLink & keyof PDrilldownLinkAttributes]?: PDrilldownLink[K] } & { [K in keyof PDrilldownLink & keyof PDrilldownLinkAttributes as `attr:${K}`]?: PDrilldownLinkAttributes[K] } & { [K in keyof PDrilldownLink & keyof PDrilldownLinkAttributes as `prop:${K}`]?: PDrilldownLink[K] };
        "p-fieldset": Omit<PFieldset, keyof PFieldsetAttributes> & { [K in keyof PFieldset & keyof PFieldsetAttributes]?: PFieldset[K] } & { [K in keyof PFieldset & keyof PFieldsetAttributes as `attr:${K}`]?: PFieldsetAttributes[K] } & { [K in keyof PFieldset & keyof PFieldsetAttributes as `prop:${K}`]?: PFieldset[K] };
        "p-flag": Omit<PFlag, keyof PFlagAttributes> & { [K in keyof PFlag & keyof PFlagAttributes]?: PFlag[K] } & { [K in keyof PFlag & keyof PFlagAttributes as `attr:${K}`]?: PFlagAttributes[K] } & { [K in keyof PFlag & keyof PFlagAttributes as `prop:${K}`]?: PFlag[K] };
        "p-flyout": Omit<PFlyout, keyof PFlyoutAttributes> & { [K in keyof PFlyout & keyof PFlyoutAttributes]?: PFlyout[K] } & { [K in keyof PFlyout & keyof PFlyoutAttributes as `attr:${K}`]?: PFlyoutAttributes[K] } & { [K in keyof PFlyout & keyof PFlyoutAttributes as `prop:${K}`]?: PFlyout[K] };
        "p-heading": Omit<PHeading, keyof PHeadingAttributes> & { [K in keyof PHeading & keyof PHeadingAttributes]?: PHeading[K] } & { [K in keyof PHeading & keyof PHeadingAttributes as `attr:${K}`]?: PHeadingAttributes[K] } & { [K in keyof PHeading & keyof PHeadingAttributes as `prop:${K}`]?: PHeading[K] };
        "p-icon": Omit<PIcon, keyof PIconAttributes> & { [K in keyof PIcon & keyof PIconAttributes]?: PIcon[K] } & { [K in keyof PIcon & keyof PIconAttributes as `attr:${K}`]?: PIconAttributes[K] } & { [K in keyof PIcon & keyof PIconAttributes as `prop:${K}`]?: PIcon[K] };
        "p-inline-notification": Omit<PInlineNotification, keyof PInlineNotificationAttributes> & { [K in keyof PInlineNotification & keyof PInlineNotificationAttributes]?: PInlineNotification[K] } & { [K in keyof PInlineNotification & keyof PInlineNotificationAttributes as `attr:${K}`]?: PInlineNotificationAttributes[K] } & { [K in keyof PInlineNotification & keyof PInlineNotificationAttributes as `prop:${K}`]?: PInlineNotification[K] };
        "p-input-date": Omit<PInputDate, keyof PInputDateAttributes> & { [K in keyof PInputDate & keyof PInputDateAttributes]?: PInputDate[K] } & { [K in keyof PInputDate & keyof PInputDateAttributes as `attr:${K}`]?: PInputDateAttributes[K] } & { [K in keyof PInputDate & keyof PInputDateAttributes as `prop:${K}`]?: PInputDate[K] };
        "p-input-email": Omit<PInputEmail, keyof PInputEmailAttributes> & { [K in keyof PInputEmail & keyof PInputEmailAttributes]?: PInputEmail[K] } & { [K in keyof PInputEmail & keyof PInputEmailAttributes as `attr:${K}`]?: PInputEmailAttributes[K] } & { [K in keyof PInputEmail & keyof PInputEmailAttributes as `prop:${K}`]?: PInputEmail[K] };
        "p-input-month": Omit<PInputMonth, keyof PInputMonthAttributes> & { [K in keyof PInputMonth & keyof PInputMonthAttributes]?: PInputMonth[K] } & { [K in keyof PInputMonth & keyof PInputMonthAttributes as `attr:${K}`]?: PInputMonthAttributes[K] } & { [K in keyof PInputMonth & keyof PInputMonthAttributes as `prop:${K}`]?: PInputMonth[K] };
        "p-input-number": Omit<PInputNumber, keyof PInputNumberAttributes> & { [K in keyof PInputNumber & keyof PInputNumberAttributes]?: PInputNumber[K] } & { [K in keyof PInputNumber & keyof PInputNumberAttributes as `attr:${K}`]?: PInputNumberAttributes[K] } & { [K in keyof PInputNumber & keyof PInputNumberAttributes as `prop:${K}`]?: PInputNumber[K] };
        "p-input-password": Omit<PInputPassword, keyof PInputPasswordAttributes> & { [K in keyof PInputPassword & keyof PInputPasswordAttributes]?: PInputPassword[K] } & { [K in keyof PInputPassword & keyof PInputPasswordAttributes as `attr:${K}`]?: PInputPasswordAttributes[K] } & { [K in keyof PInputPassword & keyof PInputPasswordAttributes as `prop:${K}`]?: PInputPassword[K] };
        "p-input-search": Omit<PInputSearch, keyof PInputSearchAttributes> & { [K in keyof PInputSearch & keyof PInputSearchAttributes]?: PInputSearch[K] } & { [K in keyof PInputSearch & keyof PInputSearchAttributes as `attr:${K}`]?: PInputSearchAttributes[K] } & { [K in keyof PInputSearch & keyof PInputSearchAttributes as `prop:${K}`]?: PInputSearch[K] };
        "p-input-tel": Omit<PInputTel, keyof PInputTelAttributes> & { [K in keyof PInputTel & keyof PInputTelAttributes]?: PInputTel[K] } & { [K in keyof PInputTel & keyof PInputTelAttributes as `attr:${K}`]?: PInputTelAttributes[K] } & { [K in keyof PInputTel & keyof PInputTelAttributes as `prop:${K}`]?: PInputTel[K] };
        "p-input-text": Omit<PInputText, keyof PInputTextAttributes> & { [K in keyof PInputText & keyof PInputTextAttributes]?: PInputText[K] } & { [K in keyof PInputText & keyof PInputTextAttributes as `attr:${K}`]?: PInputTextAttributes[K] } & { [K in keyof PInputText & keyof PInputTextAttributes as `prop:${K}`]?: PInputText[K] };
        "p-input-time": Omit<PInputTime, keyof PInputTimeAttributes> & { [K in keyof PInputTime & keyof PInputTimeAttributes]?: PInputTime[K] } & { [K in keyof PInputTime & keyof PInputTimeAttributes as `attr:${K}`]?: PInputTimeAttributes[K] } & { [K in keyof PInputTime & keyof PInputTimeAttributes as `prop:${K}`]?: PInputTime[K] };
        "p-input-url": Omit<PInputUrl, keyof PInputUrlAttributes> & { [K in keyof PInputUrl & keyof PInputUrlAttributes]?: PInputUrl[K] } & { [K in keyof PInputUrl & keyof PInputUrlAttributes as `attr:${K}`]?: PInputUrlAttributes[K] } & { [K in keyof PInputUrl & keyof PInputUrlAttributes as `prop:${K}`]?: PInputUrl[K] };
        "p-input-week": Omit<PInputWeek, keyof PInputWeekAttributes> & { [K in keyof PInputWeek & keyof PInputWeekAttributes]?: PInputWeek[K] } & { [K in keyof PInputWeek & keyof PInputWeekAttributes as `attr:${K}`]?: PInputWeekAttributes[K] } & { [K in keyof PInputWeek & keyof PInputWeekAttributes as `prop:${K}`]?: PInputWeek[K] };
        "p-link": Omit<PLink, keyof PLinkAttributes> & { [K in keyof PLink & keyof PLinkAttributes]?: PLink[K] } & { [K in keyof PLink & keyof PLinkAttributes as `attr:${K}`]?: PLinkAttributes[K] } & { [K in keyof PLink & keyof PLinkAttributes as `prop:${K}`]?: PLink[K] };
        "p-link-pure": Omit<PLinkPure, keyof PLinkPureAttributes> & { [K in keyof PLinkPure & keyof PLinkPureAttributes]?: PLinkPure[K] } & { [K in keyof PLinkPure & keyof PLinkPureAttributes as `attr:${K}`]?: PLinkPureAttributes[K] } & { [K in keyof PLinkPure & keyof PLinkPureAttributes as `prop:${K}`]?: PLinkPure[K] };
        "p-link-tile": Omit<PLinkTile, keyof PLinkTileAttributes> & { [K in keyof PLinkTile & keyof PLinkTileAttributes]?: PLinkTile[K] } & { [K in keyof PLinkTile & keyof PLinkTileAttributes as `attr:${K}`]?: PLinkTileAttributes[K] } & { [K in keyof PLinkTile & keyof PLinkTileAttributes as `prop:${K}`]?: PLinkTile[K] };
        "p-link-tile-product": Omit<PLinkTileProduct, keyof PLinkTileProductAttributes> & { [K in keyof PLinkTileProduct & keyof PLinkTileProductAttributes]?: PLinkTileProduct[K] } & { [K in keyof PLinkTileProduct & keyof PLinkTileProductAttributes as `attr:${K}`]?: PLinkTileProductAttributes[K] } & { [K in keyof PLinkTileProduct & keyof PLinkTileProductAttributes as `prop:${K}`]?: PLinkTileProduct[K] };
        "p-modal": Omit<PModal, keyof PModalAttributes> & { [K in keyof PModal & keyof PModalAttributes]?: PModal[K] } & { [K in keyof PModal & keyof PModalAttributes as `attr:${K}`]?: PModalAttributes[K] } & { [K in keyof PModal & keyof PModalAttributes as `prop:${K}`]?: PModal[K] };
        "p-model-signature": Omit<PModelSignature, keyof PModelSignatureAttributes> & { [K in keyof PModelSignature & keyof PModelSignatureAttributes]?: PModelSignature[K] } & { [K in keyof PModelSignature & keyof PModelSignatureAttributes as `attr:${K}`]?: PModelSignatureAttributes[K] } & { [K in keyof PModelSignature & keyof PModelSignatureAttributes as `prop:${K}`]?: PModelSignature[K] };
        "p-multi-select": Omit<PMultiSelect, keyof PMultiSelectAttributes> & { [K in keyof PMultiSelect & keyof PMultiSelectAttributes]?: PMultiSelect[K] } & { [K in keyof PMultiSelect & keyof PMultiSelectAttributes as `attr:${K}`]?: PMultiSelectAttributes[K] } & { [K in keyof PMultiSelect & keyof PMultiSelectAttributes as `prop:${K}`]?: PMultiSelect[K] };
        "p-multi-select-option": Omit<PMultiSelectOption, keyof PMultiSelectOptionAttributes> & { [K in keyof PMultiSelectOption & keyof PMultiSelectOptionAttributes]?: PMultiSelectOption[K] } & { [K in keyof PMultiSelectOption & keyof PMultiSelectOptionAttributes as `attr:${K}`]?: PMultiSelectOptionAttributes[K] } & { [K in keyof PMultiSelectOption & keyof PMultiSelectOptionAttributes as `prop:${K}`]?: PMultiSelectOption[K] };
        "p-optgroup": Omit<POptgroup, keyof POptgroupAttributes> & { [K in keyof POptgroup & keyof POptgroupAttributes]?: POptgroup[K] } & { [K in keyof POptgroup & keyof POptgroupAttributes as `attr:${K}`]?: POptgroupAttributes[K] } & { [K in keyof POptgroup & keyof POptgroupAttributes as `prop:${K}`]?: POptgroup[K] };
        "p-pagination": Omit<PPagination, keyof PPaginationAttributes> & { [K in keyof PPagination & keyof PPaginationAttributes]?: PPagination[K] } & { [K in keyof PPagination & keyof PPaginationAttributes as `attr:${K}`]?: PPaginationAttributes[K] } & { [K in keyof PPagination & keyof PPaginationAttributes as `prop:${K}`]?: PPagination[K] };
        "p-pin-code": Omit<PPinCode, keyof PPinCodeAttributes> & { [K in keyof PPinCode & keyof PPinCodeAttributes]?: PPinCode[K] } & { [K in keyof PPinCode & keyof PPinCodeAttributes as `attr:${K}`]?: PPinCodeAttributes[K] } & { [K in keyof PPinCode & keyof PPinCodeAttributes as `prop:${K}`]?: PPinCode[K] };
        "p-popover": Omit<PPopover, keyof PPopoverAttributes> & { [K in keyof PPopover & keyof PPopoverAttributes]?: PPopover[K] } & { [K in keyof PPopover & keyof PPopoverAttributes as `attr:${K}`]?: PPopoverAttributes[K] } & { [K in keyof PPopover & keyof PPopoverAttributes as `prop:${K}`]?: PPopover[K] };
        "p-radio-group": Omit<PRadioGroup, keyof PRadioGroupAttributes> & { [K in keyof PRadioGroup & keyof PRadioGroupAttributes]?: PRadioGroup[K] } & { [K in keyof PRadioGroup & keyof PRadioGroupAttributes as `attr:${K}`]?: PRadioGroupAttributes[K] } & { [K in keyof PRadioGroup & keyof PRadioGroupAttributes as `prop:${K}`]?: PRadioGroup[K] };
        "p-radio-group-option": Omit<PRadioGroupOption, keyof PRadioGroupOptionAttributes> & { [K in keyof PRadioGroupOption & keyof PRadioGroupOptionAttributes]?: PRadioGroupOption[K] } & { [K in keyof PRadioGroupOption & keyof PRadioGroupOptionAttributes as `attr:${K}`]?: PRadioGroupOptionAttributes[K] } & { [K in keyof PRadioGroupOption & keyof PRadioGroupOptionAttributes as `prop:${K}`]?: PRadioGroupOption[K] };
        "p-scroller": Omit<PScroller, keyof PScrollerAttributes> & { [K in keyof PScroller & keyof PScrollerAttributes]?: PScroller[K] } & { [K in keyof PScroller & keyof PScrollerAttributes as `attr:${K}`]?: PScrollerAttributes[K] } & { [K in keyof PScroller & keyof PScrollerAttributes as `prop:${K}`]?: PScroller[K] };
        "p-segmented-control": Omit<PSegmentedControl, keyof PSegmentedControlAttributes> & { [K in keyof PSegmentedControl & keyof PSegmentedControlAttributes]?: PSegmentedControl[K] } & { [K in keyof PSegmentedControl & keyof PSegmentedControlAttributes as `attr:${K}`]?: PSegmentedControlAttributes[K] } & { [K in keyof PSegmentedControl & keyof PSegmentedControlAttributes as `prop:${K}`]?: PSegmentedControl[K] };
        "p-segmented-control-item": Omit<PSegmentedControlItem, keyof PSegmentedControlItemAttributes> & { [K in keyof PSegmentedControlItem & keyof PSegmentedControlItemAttributes]?: PSegmentedControlItem[K] } & { [K in keyof PSegmentedControlItem & keyof PSegmentedControlItemAttributes as `attr:${K}`]?: PSegmentedControlItemAttributes[K] } & { [K in keyof PSegmentedControlItem & keyof PSegmentedControlItemAttributes as `prop:${K}`]?: PSegmentedControlItem[K] };
        "p-select": Omit<PSelect, keyof PSelectAttributes> & { [K in keyof PSelect & keyof PSelectAttributes]?: PSelect[K] } & { [K in keyof PSelect & keyof PSelectAttributes as `attr:${K}`]?: PSelectAttributes[K] } & { [K in keyof PSelect & keyof PSelectAttributes as `prop:${K}`]?: PSelect[K] };
        "p-select-option": Omit<PSelectOption, keyof PSelectOptionAttributes> & { [K in keyof PSelectOption & keyof PSelectOptionAttributes]?: PSelectOption[K] } & { [K in keyof PSelectOption & keyof PSelectOptionAttributes as `attr:${K}`]?: PSelectOptionAttributes[K] } & { [K in keyof PSelectOption & keyof PSelectOptionAttributes as `prop:${K}`]?: PSelectOption[K] };
        "p-sheet": Omit<PSheet, keyof PSheetAttributes> & { [K in keyof PSheet & keyof PSheetAttributes]?: PSheet[K] } & { [K in keyof PSheet & keyof PSheetAttributes as `attr:${K}`]?: PSheetAttributes[K] } & { [K in keyof PSheet & keyof PSheetAttributes as `prop:${K}`]?: PSheet[K] };
        "p-spinner": Omit<PSpinner, keyof PSpinnerAttributes> & { [K in keyof PSpinner & keyof PSpinnerAttributes]?: PSpinner[K] } & { [K in keyof PSpinner & keyof PSpinnerAttributes as `attr:${K}`]?: PSpinnerAttributes[K] } & { [K in keyof PSpinner & keyof PSpinnerAttributes as `prop:${K}`]?: PSpinner[K] };
        "p-stepper-horizontal": Omit<PStepperHorizontal, keyof PStepperHorizontalAttributes> & { [K in keyof PStepperHorizontal & keyof PStepperHorizontalAttributes]?: PStepperHorizontal[K] } & { [K in keyof PStepperHorizontal & keyof PStepperHorizontalAttributes as `attr:${K}`]?: PStepperHorizontalAttributes[K] } & { [K in keyof PStepperHorizontal & keyof PStepperHorizontalAttributes as `prop:${K}`]?: PStepperHorizontal[K] };
        "p-stepper-horizontal-item": Omit<PStepperHorizontalItem, keyof PStepperHorizontalItemAttributes> & { [K in keyof PStepperHorizontalItem & keyof PStepperHorizontalItemAttributes]?: PStepperHorizontalItem[K] } & { [K in keyof PStepperHorizontalItem & keyof PStepperHorizontalItemAttributes as `attr:${K}`]?: PStepperHorizontalItemAttributes[K] } & { [K in keyof PStepperHorizontalItem & keyof PStepperHorizontalItemAttributes as `prop:${K}`]?: PStepperHorizontalItem[K] };
        "p-switch": Omit<PSwitch, keyof PSwitchAttributes> & { [K in keyof PSwitch & keyof PSwitchAttributes]?: PSwitch[K] } & { [K in keyof PSwitch & keyof PSwitchAttributes as `attr:${K}`]?: PSwitchAttributes[K] } & { [K in keyof PSwitch & keyof PSwitchAttributes as `prop:${K}`]?: PSwitch[K] };
        "p-table": Omit<PTable, keyof PTableAttributes> & { [K in keyof PTable & keyof PTableAttributes]?: PTable[K] } & { [K in keyof PTable & keyof PTableAttributes as `attr:${K}`]?: PTableAttributes[K] } & { [K in keyof PTable & keyof PTableAttributes as `prop:${K}`]?: PTable[K] };
        "p-table-body": PTableBody;
        "p-table-cell": Omit<PTableCell, keyof PTableCellAttributes> & { [K in keyof PTableCell & keyof PTableCellAttributes]?: PTableCell[K] } & { [K in keyof PTableCell & keyof PTableCellAttributes as `attr:${K}`]?: PTableCellAttributes[K] } & { [K in keyof PTableCell & keyof PTableCellAttributes as `prop:${K}`]?: PTableCell[K] };
        "p-table-head": PTableHead;
        "p-table-head-cell": Omit<PTableHeadCell, keyof PTableHeadCellAttributes> & { [K in keyof PTableHeadCell & keyof PTableHeadCellAttributes]?: PTableHeadCell[K] } & { [K in keyof PTableHeadCell & keyof PTableHeadCellAttributes as `attr:${K}`]?: PTableHeadCellAttributes[K] } & { [K in keyof PTableHeadCell & keyof PTableHeadCellAttributes as `prop:${K}`]?: PTableHeadCell[K] };
        "p-table-head-row": PTableHeadRow;
        "p-table-row": PTableRow;
        "p-tabs": Omit<PTabs, keyof PTabsAttributes> & { [K in keyof PTabs & keyof PTabsAttributes]?: PTabs[K] } & { [K in keyof PTabs & keyof PTabsAttributes as `attr:${K}`]?: PTabsAttributes[K] } & { [K in keyof PTabs & keyof PTabsAttributes as `prop:${K}`]?: PTabs[K] };
        "p-tabs-bar": Omit<PTabsBar, keyof PTabsBarAttributes> & { [K in keyof PTabsBar & keyof PTabsBarAttributes]?: PTabsBar[K] } & { [K in keyof PTabsBar & keyof PTabsBarAttributes as `attr:${K}`]?: PTabsBarAttributes[K] } & { [K in keyof PTabsBar & keyof PTabsBarAttributes as `prop:${K}`]?: PTabsBar[K] };
        "p-tabs-item": Omit<PTabsItem, keyof PTabsItemAttributes> & { [K in keyof PTabsItem & keyof PTabsItemAttributes]?: PTabsItem[K] } & { [K in keyof PTabsItem & keyof PTabsItemAttributes as `attr:${K}`]?: PTabsItemAttributes[K] } & { [K in keyof PTabsItem & keyof PTabsItemAttributes as `prop:${K}`]?: PTabsItem[K] };
        "p-tag": Omit<PTag, keyof PTagAttributes> & { [K in keyof PTag & keyof PTagAttributes]?: PTag[K] } & { [K in keyof PTag & keyof PTagAttributes as `attr:${K}`]?: PTagAttributes[K] } & { [K in keyof PTag & keyof PTagAttributes as `prop:${K}`]?: PTag[K] };
        "p-tag-dismissible": Omit<PTagDismissible, keyof PTagDismissibleAttributes> & { [K in keyof PTagDismissible & keyof PTagDismissibleAttributes]?: PTagDismissible[K] } & { [K in keyof PTagDismissible & keyof PTagDismissibleAttributes as `attr:${K}`]?: PTagDismissibleAttributes[K] } & { [K in keyof PTagDismissible & keyof PTagDismissibleAttributes as `prop:${K}`]?: PTagDismissible[K] };
        "p-text": Omit<PText, keyof PTextAttributes> & { [K in keyof PText & keyof PTextAttributes]?: PText[K] } & { [K in keyof PText & keyof PTextAttributes as `attr:${K}`]?: PTextAttributes[K] } & { [K in keyof PText & keyof PTextAttributes as `prop:${K}`]?: PText[K] };
        "p-text-list": Omit<PTextList, keyof PTextListAttributes> & { [K in keyof PTextList & keyof PTextListAttributes]?: PTextList[K] } & { [K in keyof PTextList & keyof PTextListAttributes as `attr:${K}`]?: PTextListAttributes[K] } & { [K in keyof PTextList & keyof PTextListAttributes as `prop:${K}`]?: PTextList[K] };
        "p-text-list-item": PTextListItem;
        "p-textarea": Omit<PTextarea, keyof PTextareaAttributes> & { [K in keyof PTextarea & keyof PTextareaAttributes]?: PTextarea[K] } & { [K in keyof PTextarea & keyof PTextareaAttributes as `attr:${K}`]?: PTextareaAttributes[K] } & { [K in keyof PTextarea & keyof PTextareaAttributes as `prop:${K}`]?: PTextarea[K] };
        "p-toast": PToast;
        "p-toast-item": Omit<PToastItem, keyof PToastItemAttributes> & { [K in keyof PToastItem & keyof PToastItemAttributes]?: PToastItem[K] } & { [K in keyof PToastItem & keyof PToastItemAttributes as `attr:${K}`]?: PToastItemAttributes[K] } & { [K in keyof PToastItem & keyof PToastItemAttributes as `prop:${K}`]?: PToastItem[K] };
        "p-wordmark": Omit<PWordmark, keyof PWordmarkAttributes> & { [K in keyof PWordmark & keyof PWordmarkAttributes]?: PWordmark[K] } & { [K in keyof PWordmark & keyof PWordmarkAttributes as `attr:${K}`]?: PWordmarkAttributes[K] } & { [K in keyof PWordmark & keyof PWordmarkAttributes as `prop:${K}`]?: PWordmark[K] };
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * @controlled {"props": ["open"], "event": "update"}
             */
            "p-accordion": LocalJSX.IntrinsicElements["p-accordion"] & JSXBase.HTMLAttributes<HTMLPAccordionElement>;
            /**
             * @controlled {"props": ["open"], "event": "dismiss"}
             */
            "p-banner": LocalJSX.IntrinsicElements["p-banner"] & JSXBase.HTMLAttributes<HTMLPBannerElement>;
            "p-button": LocalJSX.IntrinsicElements["p-button"] & JSXBase.HTMLAttributes<HTMLPButtonElement>;
            "p-button-pure": LocalJSX.IntrinsicElements["p-button-pure"] & JSXBase.HTMLAttributes<HTMLPButtonPureElement>;
            "p-button-tile": LocalJSX.IntrinsicElements["p-button-tile"] & JSXBase.HTMLAttributes<HTMLPButtonTileElement>;
            /**
             * @experimental 
             */
            "p-canvas": LocalJSX.IntrinsicElements["p-canvas"] & JSXBase.HTMLAttributes<HTMLPCanvasElement>;
            /**
             * @controlled { "props": ["activeSlideIndex"], "event": "update", "isInternallyMutated": true }
             */
            "p-carousel": LocalJSX.IntrinsicElements["p-carousel"] & JSXBase.HTMLAttributes<HTMLPCarouselElement>;
            "p-checkbox": LocalJSX.IntrinsicElements["p-checkbox"] & JSXBase.HTMLAttributes<HTMLPCheckboxElement>;
            "p-crest": LocalJSX.IntrinsicElements["p-crest"] & JSXBase.HTMLAttributes<HTMLPCrestElement>;
            "p-display": LocalJSX.IntrinsicElements["p-display"] & JSXBase.HTMLAttributes<HTMLPDisplayElement>;
            "p-divider": LocalJSX.IntrinsicElements["p-divider"] & JSXBase.HTMLAttributes<HTMLPDividerElement>;
            /**
             * @controlled {"props": ["open"], "event": "dismiss"}
             * @controlled {"props": ["activeIdentifier"], "event": "update"}
             * @experimental 
             */
            "p-drilldown": LocalJSX.IntrinsicElements["p-drilldown"] & JSXBase.HTMLAttributes<HTMLPDrilldownElement>;
            /**
             * @experimental 
             */
            "p-drilldown-item": LocalJSX.IntrinsicElements["p-drilldown-item"] & JSXBase.HTMLAttributes<HTMLPDrilldownItemElement>;
            /**
             * @experimental 
             */
            "p-drilldown-link": LocalJSX.IntrinsicElements["p-drilldown-link"] & JSXBase.HTMLAttributes<HTMLPDrilldownLinkElement>;
            "p-fieldset": LocalJSX.IntrinsicElements["p-fieldset"] & JSXBase.HTMLAttributes<HTMLPFieldsetElement>;
            "p-flag": LocalJSX.IntrinsicElements["p-flag"] & JSXBase.HTMLAttributes<HTMLPFlagElement>;
            /**
             * @controlled {"props": ["open"], "event": "dismiss"}
             */
            "p-flyout": LocalJSX.IntrinsicElements["p-flyout"] & JSXBase.HTMLAttributes<HTMLPFlyoutElement>;
            "p-heading": LocalJSX.IntrinsicElements["p-heading"] & JSXBase.HTMLAttributes<HTMLPHeadingElement>;
            "p-icon": LocalJSX.IntrinsicElements["p-icon"] & JSXBase.HTMLAttributes<HTMLPIconElement>;
            "p-inline-notification": LocalJSX.IntrinsicElements["p-inline-notification"] & JSXBase.HTMLAttributes<HTMLPInlineNotificationElement>;
            "p-input-date": LocalJSX.IntrinsicElements["p-input-date"] & JSXBase.HTMLAttributes<HTMLPInputDateElement>;
            "p-input-email": LocalJSX.IntrinsicElements["p-input-email"] & JSXBase.HTMLAttributes<HTMLPInputEmailElement>;
            "p-input-month": LocalJSX.IntrinsicElements["p-input-month"] & JSXBase.HTMLAttributes<HTMLPInputMonthElement>;
            "p-input-number": LocalJSX.IntrinsicElements["p-input-number"] & JSXBase.HTMLAttributes<HTMLPInputNumberElement>;
            "p-input-password": LocalJSX.IntrinsicElements["p-input-password"] & JSXBase.HTMLAttributes<HTMLPInputPasswordElement>;
            "p-input-search": LocalJSX.IntrinsicElements["p-input-search"] & JSXBase.HTMLAttributes<HTMLPInputSearchElement>;
            "p-input-tel": LocalJSX.IntrinsicElements["p-input-tel"] & JSXBase.HTMLAttributes<HTMLPInputTelElement>;
            "p-input-text": LocalJSX.IntrinsicElements["p-input-text"] & JSXBase.HTMLAttributes<HTMLPInputTextElement>;
            "p-input-time": LocalJSX.IntrinsicElements["p-input-time"] & JSXBase.HTMLAttributes<HTMLPInputTimeElement>;
            "p-input-url": LocalJSX.IntrinsicElements["p-input-url"] & JSXBase.HTMLAttributes<HTMLPInputUrlElement>;
            "p-input-week": LocalJSX.IntrinsicElements["p-input-week"] & JSXBase.HTMLAttributes<HTMLPInputWeekElement>;
            "p-link": LocalJSX.IntrinsicElements["p-link"] & JSXBase.HTMLAttributes<HTMLPLinkElement>;
            "p-link-pure": LocalJSX.IntrinsicElements["p-link-pure"] & JSXBase.HTMLAttributes<HTMLPLinkPureElement>;
            "p-link-tile": LocalJSX.IntrinsicElements["p-link-tile"] & JSXBase.HTMLAttributes<HTMLPLinkTileElement>;
            /**
             * @controlled {"props": ["liked"], "event": "like"}
             * @experimental 
             */
            "p-link-tile-product": LocalJSX.IntrinsicElements["p-link-tile-product"] & JSXBase.HTMLAttributes<HTMLPLinkTileProductElement>;
            /**
             * @controlled {"props": ["open"], "event": "dismiss"}
             */
            "p-modal": LocalJSX.IntrinsicElements["p-modal"] & JSXBase.HTMLAttributes<HTMLPModalElement>;
            "p-model-signature": LocalJSX.IntrinsicElements["p-model-signature"] & JSXBase.HTMLAttributes<HTMLPModelSignatureElement>;
            /**
             * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
             */
            "p-multi-select": LocalJSX.IntrinsicElements["p-multi-select"] & JSXBase.HTMLAttributes<HTMLPMultiSelectElement>;
            "p-multi-select-option": LocalJSX.IntrinsicElements["p-multi-select-option"] & JSXBase.HTMLAttributes<HTMLPMultiSelectOptionElement>;
            "p-optgroup": LocalJSX.IntrinsicElements["p-optgroup"] & JSXBase.HTMLAttributes<HTMLPOptgroupElement>;
            /**
             * @controlled { "props": ["activePage"], "event": "update", "isInternallyMutated": true }
             */
            "p-pagination": LocalJSX.IntrinsicElements["p-pagination"] & JSXBase.HTMLAttributes<HTMLPPaginationElement>;
            /**
             * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
             */
            "p-pin-code": LocalJSX.IntrinsicElements["p-pin-code"] & JSXBase.HTMLAttributes<HTMLPPinCodeElement>;
            "p-popover": LocalJSX.IntrinsicElements["p-popover"] & JSXBase.HTMLAttributes<HTMLPPopoverElement>;
            "p-radio-group": LocalJSX.IntrinsicElements["p-radio-group"] & JSXBase.HTMLAttributes<HTMLPRadioGroupElement>;
            "p-radio-group-option": LocalJSX.IntrinsicElements["p-radio-group-option"] & JSXBase.HTMLAttributes<HTMLPRadioGroupOptionElement>;
            "p-scroller": LocalJSX.IntrinsicElements["p-scroller"] & JSXBase.HTMLAttributes<HTMLPScrollerElement>;
            /**
             * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
             */
            "p-segmented-control": LocalJSX.IntrinsicElements["p-segmented-control"] & JSXBase.HTMLAttributes<HTMLPSegmentedControlElement>;
            "p-segmented-control-item": LocalJSX.IntrinsicElements["p-segmented-control-item"] & JSXBase.HTMLAttributes<HTMLPSegmentedControlItemElement>;
            /**
             * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
             */
            "p-select": LocalJSX.IntrinsicElements["p-select"] & JSXBase.HTMLAttributes<HTMLPSelectElement>;
            "p-select-option": LocalJSX.IntrinsicElements["p-select-option"] & JSXBase.HTMLAttributes<HTMLPSelectOptionElement>;
            /**
             * @controlled {"props": ["open"], "event": "dismiss"}
             */
            "p-sheet": LocalJSX.IntrinsicElements["p-sheet"] & JSXBase.HTMLAttributes<HTMLPSheetElement>;
            "p-spinner": LocalJSX.IntrinsicElements["p-spinner"] & JSXBase.HTMLAttributes<HTMLPSpinnerElement>;
            "p-stepper-horizontal": LocalJSX.IntrinsicElements["p-stepper-horizontal"] & JSXBase.HTMLAttributes<HTMLPStepperHorizontalElement>;
            "p-stepper-horizontal-item": LocalJSX.IntrinsicElements["p-stepper-horizontal-item"] & JSXBase.HTMLAttributes<HTMLPStepperHorizontalItemElement>;
            /**
             * @controlled {"props": ["checked"], "event": "update"}
             */
            "p-switch": LocalJSX.IntrinsicElements["p-switch"] & JSXBase.HTMLAttributes<HTMLPSwitchElement>;
            "p-table": LocalJSX.IntrinsicElements["p-table"] & JSXBase.HTMLAttributes<HTMLPTableElement>;
            "p-table-body": LocalJSX.IntrinsicElements["p-table-body"] & JSXBase.HTMLAttributes<HTMLPTableBodyElement>;
            "p-table-cell": LocalJSX.IntrinsicElements["p-table-cell"] & JSXBase.HTMLAttributes<HTMLPTableCellElement>;
            "p-table-head": LocalJSX.IntrinsicElements["p-table-head"] & JSXBase.HTMLAttributes<HTMLPTableHeadElement>;
            "p-table-head-cell": LocalJSX.IntrinsicElements["p-table-head-cell"] & JSXBase.HTMLAttributes<HTMLPTableHeadCellElement>;
            "p-table-head-row": LocalJSX.IntrinsicElements["p-table-head-row"] & JSXBase.HTMLAttributes<HTMLPTableHeadRowElement>;
            "p-table-row": LocalJSX.IntrinsicElements["p-table-row"] & JSXBase.HTMLAttributes<HTMLPTableRowElement>;
            /**
             * @controlled { "props": ["activeTabIndex"], "event": "update", "isInternallyMutated": true }
             */
            "p-tabs": LocalJSX.IntrinsicElements["p-tabs"] & JSXBase.HTMLAttributes<HTMLPTabsElement>;
            /**
             * @controlled {"props": ["activeTabIndex"], "event": "update"}
             */
            "p-tabs-bar": LocalJSX.IntrinsicElements["p-tabs-bar"] & JSXBase.HTMLAttributes<HTMLPTabsBarElement>;
            "p-tabs-item": LocalJSX.IntrinsicElements["p-tabs-item"] & JSXBase.HTMLAttributes<HTMLPTabsItemElement>;
            "p-tag": LocalJSX.IntrinsicElements["p-tag"] & JSXBase.HTMLAttributes<HTMLPTagElement>;
            "p-tag-dismissible": LocalJSX.IntrinsicElements["p-tag-dismissible"] & JSXBase.HTMLAttributes<HTMLPTagDismissibleElement>;
            "p-text": LocalJSX.IntrinsicElements["p-text"] & JSXBase.HTMLAttributes<HTMLPTextElement>;
            "p-text-list": LocalJSX.IntrinsicElements["p-text-list"] & JSXBase.HTMLAttributes<HTMLPTextListElement>;
            "p-text-list-item": LocalJSX.IntrinsicElements["p-text-list-item"] & JSXBase.HTMLAttributes<HTMLPTextListItemElement>;
            "p-textarea": LocalJSX.IntrinsicElements["p-textarea"] & JSXBase.HTMLAttributes<HTMLPTextareaElement>;
            "p-toast": LocalJSX.IntrinsicElements["p-toast"] & JSXBase.HTMLAttributes<HTMLPToastElement>;
            "p-toast-item": LocalJSX.IntrinsicElements["p-toast-item"] & JSXBase.HTMLAttributes<HTMLPToastItemElement>;
            "p-wordmark": LocalJSX.IntrinsicElements["p-wordmark"] & JSXBase.HTMLAttributes<HTMLPWordmarkElement>;
        }
    }
}
