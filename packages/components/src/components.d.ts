/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { BreakpointCustomizable, ButtonAriaAttribute, ButtonType, ButtonVariant, IconName, LinkTarget, LinkVariant, SelectedAriaAttributes, TextAlign, TextColor, TextSize, TextWeight, Theme } from "./types";
import { AccordionSize, AccordionTag, AccordionUpdateEvent } from "./components/accordion/accordion-utils";
import { BannerState, BannerWidth } from "./components/banner/banner-utils";
import { ButtonIcon } from "./components/button/button-utils";
import { ButtonGroupDirection } from "./components/button-group/button-group-utils";
import { ButtonPureAlignLabel, ButtonPureAriaAttribute, ButtonPureIcon, ButtonPureSize, ButtonPureType, ButtonPureWeight } from "./components/button-pure/button-pure-utils";
import { ButtonTileAlign, ButtonTileAriaAttribute, ButtonTileAspectRatio, ButtonTileIcon, ButtonTileSize, ButtonTileType, ButtonTileWeight } from "./components/button-tile/button-tile-utils";
import { CarouselAlignHeader, CarouselInternationalization, CarouselUpdateEvent, CarouselWidth } from "./components/carousel/carousel-utils";
import { CheckboxWrapperState } from "./components/checkbox-wrapper/checkbox-wrapper-utils";
import { ContentWrapperBackgroundColor, ContentWrapperWidth } from "./components/content-wrapper/content-wrapper-utils";
import { CrestAriaAttribute, CrestTarget } from "./components/crest/crest-utils";
import { DisplayAlign, DisplayColor, DisplaySize, DisplayTag } from "./components/display/display-utils";
import { DividerColor, DividerDirection, DividerOrientation } from "./components/divider/divider-utils";
import { FieldsetLabelSize, FieldsetState } from "./components/fieldset/fieldset-utils";
import { FieldsetWrapperLabelSize, FieldsetWrapperState } from "./components/fieldset-wrapper/fieldset-wrapper-utils";
import { FlexAlignContent, FlexAlignItems, FlexDirection, FlexInline, FlexJustifyContent, FlexWrap } from "./components/flex/flex/flex-utils";
import { FlexItemAlignSelf, FlexItemFlex, FlexItemGrow, FlexItemOffset, FlexItemShrink, FlexItemWidth } from "./components/flex/flex-item/flex-item-utils";
import { FlyoutAriaAttribute, FlyoutPosition } from "./components/flyout/flyout-utils";
import { GridDirection, GridGutter, GridWrap } from "./components/grid/grid/grid-utils";
import { GridItemOffset, GridItemSize } from "./components/grid/grid-item/grid-item-utils";
import { HeadingTag } from "./components/heading/heading-tag";
import { HeadingAlign, HeadingColor, HeadingSize } from "./components/heading/heading-utils";
import { HeadlineAlign, HeadlineColor, HeadlineTag, HeadlineVariant } from "./components/headline/headline-utils";
import { IconAriaAttribute, IconColor, IconSize } from "./components/icon/icon-utils";
import { InlineNotificationActionIcon, InlineNotificationState } from "./components/inline-notification/inline-notification-utils";
import { LinkAriaAttribute, LinkIcon } from "./components/link/link-utils";
import { LinkPureAlignLabel, LinkPureAriaAttribute, LinkPureIcon, LinkPureSize, LinkPureTarget, LinkPureWeight } from "./components/link-pure/link-pure-utils";
import { LinkSocialIcon, LinkSocialTarget } from "./components/link-social/link-social-utils";
import { LinkTileAlign, LinkTileAriaAttribute, LinkTileAspectRatio, LinkTileSize, LinkTileTarget, LinkTileWeight } from "./components/link-tile/link-tile-utils";
import { LinkTileModelSignatureAspectRatio, LinkTileModelSignatureHeadingTag, LinkTileModelSignatureLinkDirection, LinkTileModelSignatureModel, LinkTileModelSignatureWeight } from "./components/link-tile-model-signature/link-tile-model-signature-utils";
import { MarqueAriaAttribute, MarqueTarget, MarqueVariant } from "./components/marque/marque-utils";
import { MarqueSize } from "./components/marque/marque-size";
import { ModalAriaAttribute } from "./components/modal/modal-utils";
import { ModelSignatureColor, ModelSignatureModel, ModelSignatureSize } from "./components/model-signature/model-signature-utils";
import { PaginationInternationalization, PaginationMaxNumberOfPageLinks, PaginationUpdateEvent } from "./components/pagination/pagination-utils";
import { PopoverAriaAttribute, PopoverDirection } from "./components/popover/popover-utils";
import { RadioButtonWrapperState } from "./components/radio-button-wrapper/radio-button-wrapper-utils";
import { ScrollerAlignScrollIndicator, ScrollerAriaAttribute, ScrollerGradientColor, ScrollerGradientColorScheme, ScrollerScrollIndicatorPosition, ScrollerScrollToPosition } from "./components/scroller/scroller-utils";
import { SegmentedControlBackgroundColor, SegmentedControlUpdateEvent } from "./components/segmented-control/segmented-control/segmented-control-utils";
import { SegmentedControlItemIcon } from "./components/segmented-control/segmented-control-item/segmented-control-item-utils";
import { SelectWrapperDropdownDirection, SelectWrapperState } from "./components/select-wrapper/select-wrapper/select-wrapper-utils";
import { SpinnerAriaAttribute, SpinnerSize } from "./components/spinner/spinner-utils";
import { StepperHorizontalSize, StepperHorizontalUpdateEvent } from "./components/stepper-horizontal/stepper-horizontal/stepper-horizontal-utils";
import { StepperHorizontalItemState } from "./components/stepper-horizontal/stepper-horizontal-item/stepper-horizontal-item-utils";
import { SwitchAlignLabel, SwitchUpdateEvent } from "./components/switch/switch-utils";
import { TableHeadCellSort, TableUpdateEvent } from "./components/table/table/table-utils";
import { TabsGradientColor, TabsGradientColorScheme, TabsSize, TabsUpdateEvent, TabsWeight } from "./components/tabs/tabs/tabs-utils";
import { TabsBarGradientColor, TabsBarGradientColorScheme, TabsBarSize, TabsBarUpdateEvent, TabsBarWeight } from "./components/tabs-bar/tabs-bar-utils";
import { TagColor, TagIcon } from "./components/tag/tag-utils";
import { TagDismissibleAriaAttribute, TagDismissibleColor } from "./components/tag-dismissible/tag-dismissible-utils";
import { TextTag } from "./components/text/text-utils";
import { TextFieldWrapperActionIcon, TextFieldWrapperState, TextFieldWrapperUnitPosition } from "./components/text-field-wrapper/text-field-wrapper-utils";
import { TextListListType, TextListOrderType, TextListType } from "./components/text-list/text-list/text-list-utils";
import { TextareaWrapperState } from "./components/textarea-wrapper/textarea-wrapper-utils";
import { ToastMessage } from "./components/toast/toast/toast-manager";
import { ToastState } from "./components/toast/toast/toast-utils";
import { WordmarkAriaAttribute, WordmarkSize, WordmarkTarget } from "./components/wordmark/wordmark-utils";
export { BreakpointCustomizable, ButtonAriaAttribute, ButtonType, ButtonVariant, IconName, LinkTarget, LinkVariant, SelectedAriaAttributes, TextAlign, TextColor, TextSize, TextWeight, Theme } from "./types";
export { AccordionSize, AccordionTag, AccordionUpdateEvent } from "./components/accordion/accordion-utils";
export { BannerState, BannerWidth } from "./components/banner/banner-utils";
export { ButtonIcon } from "./components/button/button-utils";
export { ButtonGroupDirection } from "./components/button-group/button-group-utils";
export { ButtonPureAlignLabel, ButtonPureAriaAttribute, ButtonPureIcon, ButtonPureSize, ButtonPureType, ButtonPureWeight } from "./components/button-pure/button-pure-utils";
export { ButtonTileAlign, ButtonTileAriaAttribute, ButtonTileAspectRatio, ButtonTileIcon, ButtonTileSize, ButtonTileType, ButtonTileWeight } from "./components/button-tile/button-tile-utils";
export { CarouselAlignHeader, CarouselInternationalization, CarouselUpdateEvent, CarouselWidth } from "./components/carousel/carousel-utils";
export { CheckboxWrapperState } from "./components/checkbox-wrapper/checkbox-wrapper-utils";
export { ContentWrapperBackgroundColor, ContentWrapperWidth } from "./components/content-wrapper/content-wrapper-utils";
export { CrestAriaAttribute, CrestTarget } from "./components/crest/crest-utils";
export { DisplayAlign, DisplayColor, DisplaySize, DisplayTag } from "./components/display/display-utils";
export { DividerColor, DividerDirection, DividerOrientation } from "./components/divider/divider-utils";
export { FieldsetLabelSize, FieldsetState } from "./components/fieldset/fieldset-utils";
export { FieldsetWrapperLabelSize, FieldsetWrapperState } from "./components/fieldset-wrapper/fieldset-wrapper-utils";
export { FlexAlignContent, FlexAlignItems, FlexDirection, FlexInline, FlexJustifyContent, FlexWrap } from "./components/flex/flex/flex-utils";
export { FlexItemAlignSelf, FlexItemFlex, FlexItemGrow, FlexItemOffset, FlexItemShrink, FlexItemWidth } from "./components/flex/flex-item/flex-item-utils";
export { FlyoutAriaAttribute, FlyoutPosition } from "./components/flyout/flyout-utils";
export { GridDirection, GridGutter, GridWrap } from "./components/grid/grid/grid-utils";
export { GridItemOffset, GridItemSize } from "./components/grid/grid-item/grid-item-utils";
export { HeadingTag } from "./components/heading/heading-tag";
export { HeadingAlign, HeadingColor, HeadingSize } from "./components/heading/heading-utils";
export { HeadlineAlign, HeadlineColor, HeadlineTag, HeadlineVariant } from "./components/headline/headline-utils";
export { IconAriaAttribute, IconColor, IconSize } from "./components/icon/icon-utils";
export { InlineNotificationActionIcon, InlineNotificationState } from "./components/inline-notification/inline-notification-utils";
export { LinkAriaAttribute, LinkIcon } from "./components/link/link-utils";
export { LinkPureAlignLabel, LinkPureAriaAttribute, LinkPureIcon, LinkPureSize, LinkPureTarget, LinkPureWeight } from "./components/link-pure/link-pure-utils";
export { LinkSocialIcon, LinkSocialTarget } from "./components/link-social/link-social-utils";
export { LinkTileAlign, LinkTileAriaAttribute, LinkTileAspectRatio, LinkTileSize, LinkTileTarget, LinkTileWeight } from "./components/link-tile/link-tile-utils";
export { LinkTileModelSignatureAspectRatio, LinkTileModelSignatureHeadingTag, LinkTileModelSignatureLinkDirection, LinkTileModelSignatureModel, LinkTileModelSignatureWeight } from "./components/link-tile-model-signature/link-tile-model-signature-utils";
export { MarqueAriaAttribute, MarqueTarget, MarqueVariant } from "./components/marque/marque-utils";
export { MarqueSize } from "./components/marque/marque-size";
export { ModalAriaAttribute } from "./components/modal/modal-utils";
export { ModelSignatureColor, ModelSignatureModel, ModelSignatureSize } from "./components/model-signature/model-signature-utils";
export { PaginationInternationalization, PaginationMaxNumberOfPageLinks, PaginationUpdateEvent } from "./components/pagination/pagination-utils";
export { PopoverAriaAttribute, PopoverDirection } from "./components/popover/popover-utils";
export { RadioButtonWrapperState } from "./components/radio-button-wrapper/radio-button-wrapper-utils";
export { ScrollerAlignScrollIndicator, ScrollerAriaAttribute, ScrollerGradientColor, ScrollerGradientColorScheme, ScrollerScrollIndicatorPosition, ScrollerScrollToPosition } from "./components/scroller/scroller-utils";
export { SegmentedControlBackgroundColor, SegmentedControlUpdateEvent } from "./components/segmented-control/segmented-control/segmented-control-utils";
export { SegmentedControlItemIcon } from "./components/segmented-control/segmented-control-item/segmented-control-item-utils";
export { SelectWrapperDropdownDirection, SelectWrapperState } from "./components/select-wrapper/select-wrapper/select-wrapper-utils";
export { SpinnerAriaAttribute, SpinnerSize } from "./components/spinner/spinner-utils";
export { StepperHorizontalSize, StepperHorizontalUpdateEvent } from "./components/stepper-horizontal/stepper-horizontal/stepper-horizontal-utils";
export { StepperHorizontalItemState } from "./components/stepper-horizontal/stepper-horizontal-item/stepper-horizontal-item-utils";
export { SwitchAlignLabel, SwitchUpdateEvent } from "./components/switch/switch-utils";
export { TableHeadCellSort, TableUpdateEvent } from "./components/table/table/table-utils";
export { TabsGradientColor, TabsGradientColorScheme, TabsSize, TabsUpdateEvent, TabsWeight } from "./components/tabs/tabs/tabs-utils";
export { TabsBarGradientColor, TabsBarGradientColorScheme, TabsBarSize, TabsBarUpdateEvent, TabsBarWeight } from "./components/tabs-bar/tabs-bar-utils";
export { TagColor, TagIcon } from "./components/tag/tag-utils";
export { TagDismissibleAriaAttribute, TagDismissibleColor } from "./components/tag-dismissible/tag-dismissible-utils";
export { TextTag } from "./components/text/text-utils";
export { TextFieldWrapperActionIcon, TextFieldWrapperState, TextFieldWrapperUnitPosition } from "./components/text-field-wrapper/text-field-wrapper-utils";
export { TextListListType, TextListOrderType, TextListType } from "./components/text-list/text-list/text-list-utils";
export { TextareaWrapperState } from "./components/textarea-wrapper/textarea-wrapper-utils";
export { ToastMessage } from "./components/toast/toast/toast-manager";
export { ToastState } from "./components/toast/toast/toast-utils";
export { WordmarkAriaAttribute, WordmarkSize, WordmarkTarget } from "./components/wordmark/wordmark-utils";
export namespace Components {
    interface PAccordion {
        /**
          * Displays the Accordion as compact version with thinner border and smaller paddings.
         */
        "compact"?: boolean;
        /**
          * Defines the heading used in accordion.
         */
        "heading"?: string;
        /**
          * Defines if accordion is open.
         */
        "open"?: boolean;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<AccordionSize>;
        /**
          * Sets a headline tag, so it fits correctly within the outline of the page.
         */
        "tag"?: AccordionTag;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PBanner {
        /**
          * Description of the banner.
         */
        "description"?: string;
        /**
          * If false, the banner will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the banner.
         */
        "heading"?: string;
        /**
          * If true, the banner is open.
         */
        "open": boolean;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `dismissButton` instead. Defines if the banner can be closed/removed by the user.
         */
        "persistent"?: boolean;
        /**
          * State of the banner.
         */
        "state"?: BannerState;
        /**
          * Adapts the banner color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "width"?: BannerWidth;
    }
    interface PButton {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: ButtonIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonType;
        /**
          * The style variant of the button.
         */
        "variant"?: ButtonVariant;
    }
    interface PButtonGroup {
        /**
          * Defines the direction of the main and cross axis. The default is ’{base: ‘column’, xs: ‘row’}' showing buttons vertically stacked on mobile viewports and side-by-side in a horizontal row from breakpoint ‘xs’. You always need to provide a base value when using breakpoints.
         */
        "direction"?: BreakpointCustomizable<ButtonGroupDirection>;
    }
    interface PButtonPure {
        /**
          * Display button in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<ButtonPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonPureAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown.
         */
        "icon"?: ButtonPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Size of the button.
         */
        "size"?: BreakpointCustomizable<ButtonPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonPureType;
        /**
          * The weight of the text (only has effect with visible label).
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "weight"?: ButtonPureWeight;
    }
    interface PButtonTile {
        /**
          * Alignment of button and description.
         */
        "align"?: ButtonTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonTileAriaAttribute>;
        /**
          * Aspect ratio of the button-tile.
         */
        "aspectRatio"?: BreakpointCustomizable<ButtonTileAspectRatio>;
        /**
          * Displays the button-tile as compact version with description and button icon only.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description": string;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show gradient.
         */
        "gradient"?: boolean;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: ButtonTileIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Label of the button.
         */
        "label": string;
        /**
          * Disables the button-tile and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Font size of the description.
         */
        "size"?: BreakpointCustomizable<ButtonTileSize>;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonTileType;
        /**
          * Font weight of the description.
         */
        "weight"?: BreakpointCustomizable<ButtonTileWeight>;
    }
    interface PCarousel {
        /**
          * Defines which slide to be active (zero-based numbering).
         */
        "activeSlideIndex"?: number;
        /**
          * Alignment of heading and description
         */
        "alignHeader"?: CarouselAlignHeader;
        /**
          * Defines the description used in the carousel.
         */
        "description"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `pagination` instead. If true, the carousel will not show pagination bullets at the bottom.
         */
        "disablePagination"?: BreakpointCustomizable<boolean>;
        /**
          * Defines the heading used in the carousel.
         */
        "heading"?: string;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev buttons and pagination.
         */
        "intl"?: CarouselInternationalization;
        /**
          * If false, the carousel will not show pagination bullets at the bottom.
         */
        "pagination"?: BreakpointCustomizable<boolean>;
        /**
          * Whether the slides should rewind from last to first slide and vice versa.
         */
        "rewind"?: boolean;
        /**
          * Sets the amount of slides visible at the same time. Can be set to `auto` if you want to define different widths per slide via CSS.
         */
        "slidesPerPage"?: BreakpointCustomizable<number> | 'auto';
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * Defines the outer spacings between the carousel and the left and right screen sides.
         */
        "width"?: CarouselWidth;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "wrapContent"?: boolean;
    }
    interface PCheckboxWrapper {
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * __Experimental__: Disables the checkbox and shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: CheckboxWrapperState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface PContentWrapper {
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "backgroundColor"?: ContentWrapperBackgroundColor;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "theme"?: Theme;
        /**
          * Defines the outer spacings between the content area and the left and right screen sides, as well as centering its content and setting a max-width.
         */
        "width"?: ContentWrapperWidth;
    }
    interface PCrest {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<CrestAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: CrestTarget;
    }
    interface PDisplay {
        /**
          * Text alignment of the component.
         */
        "align"?: DisplayAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: DisplayColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "medium", l: "large"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<DisplaySize>;
        /**
          * Sets a custom HTML tag depending on the usage of the display component.
         */
        "tag"?: DisplayTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
    }
    interface PDivider {
        /**
          * Defines color depending on theme.
         */
        "color"?: DividerColor;
        /**
          * Defines direction.
         */
        "direction"?: BreakpointCustomizable<DividerDirection>;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `direction` instead. Defines orientation.
         */
        "orientation"?: BreakpointCustomizable<DividerOrientation>;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    interface PFieldset {
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The size of the label text.
         */
        "labelSize"?: FieldsetLabelSize;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Marks the Fieldset as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: FieldsetState;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-fieldset" instead.
     */
    interface PFieldsetWrapper {
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The size of the label text.
         */
        "labelSize"?: FieldsetWrapperLabelSize;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Marks the Fieldset as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: FieldsetWrapperState;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
     */
    interface PFlex {
        /**
          * This aligns a flex container's individual lines when there is extra space in the cross-axis, similar to how "justifyContent" aligns individual items along the main axis.
         */
        "alignContent"?: BreakpointCustomizable<FlexAlignContent>;
        /**
          * Defines how the flex items are aligned along the cross axis.
         */
        "alignItems"?: BreakpointCustomizable<FlexAlignItems>;
        /**
          * Defines the direction of the main and cross axis. The default "row" defines the main axis as horizontal left to right.
         */
        "direction"?: BreakpointCustomizable<FlexDirection>;
        /**
          * Defines the flex containers content flow if 2 or more containers are siblings of each other.
         */
        "inline"?: BreakpointCustomizable<FlexInline>;
        /**
          * Defines how the flex items are aligned along the main axis.
         */
        "justifyContent"?: BreakpointCustomizable<FlexJustifyContent>;
        /**
          * Handles wrapping behaviour of elements.
         */
        "wrap"?: BreakpointCustomizable<FlexWrap>;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
     */
    interface PFlexItem {
        /**
          * Defines how this flex item is aligned along the cross axis. This overwrites the cross axis alignment set by the container. Corresponds to the "alignSelf" css property.
         */
        "alignSelf"?: BreakpointCustomizable<FlexItemAlignSelf>;
        /**
          * The shorthand property for the combined definition of "shrink", "grow" and "basis"
         */
        "flex"?: BreakpointCustomizable<FlexItemFlex>;
        /**
          * The ability to allow/disallow the flex child to grow.
         */
        "grow"?: BreakpointCustomizable<FlexItemGrow>;
        /**
          * The offset of the column. You can also supply values for specific breakpoints, like {base: "none", l: "one-quarter"}. You always need to provide a base value when doing this.
         */
        "offset"?: BreakpointCustomizable<FlexItemOffset>;
        /**
          * The ability to allow/disallow the flex child to shrink.
         */
        "shrink"?: BreakpointCustomizable<FlexItemShrink>;
        /**
          * The width of the flex item. You can also supply values for specific breakpoints, like {base: "full", l: "one-quarter"}. You always need to provide a base value when doing this.
         */
        "width"?: BreakpointCustomizable<FlexItemWidth>;
    }
    interface PFlyout {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<FlyoutAriaAttribute>;
        /**
          * If true, the flyout is open.
         */
        "open": boolean;
        /**
          * The position of the flyout
         */
        "position"?: FlyoutPosition;
        /**
          * Adapts the flyout color depending on the theme.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface PGrid {
        /**
          * Defines the direction of the main and cross axis. The default "row" defines the main axis as horizontal left to right. Also defines the direction for specific breakpoints, like {base: "column", l: "row"}. You always need to provide a base value when doing this.
         */
        "direction"?: BreakpointCustomizable<GridDirection>;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "gutter"?: BreakpointCustomizable<GridGutter>;
        /**
          * Handles wrapping behaviour of elements.
         */
        "wrap"?: BreakpointCustomizable<GridWrap>;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface PGridItem {
        /**
          * The offset of the column. Can be between 0 and 11. Also defines the offset of the column for specific breakpoints, like {base: 6, l: 3}. You always need to provide a base value when doing this.
         */
        "offset"?: BreakpointCustomizable<GridItemOffset>;
        /**
          * The size of the column. Can be between 1 and 12. Also defines the size of the column for specific breakpoints, like {base: 6, l: 3}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<GridItemSize>;
    }
    interface PHeading {
        /**
          * Text alignment of the component.
         */
        "align"?: HeadingAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: HeadingColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<HeadingSize>;
        /**
          * Sets a custom HTML tag depending on the usage of the heading component.
         */
        "tag"?: HeadingTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-heading" instead.
     */
    interface PHeadline {
        /**
          * Text alignment of the component.
         */
        "align"?: HeadlineAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: HeadlineColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Sets a custom HTML tag depending on the usage of the headline component.
         */
        "tag"?: HeadlineTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
        /**
          * Predefined style of the headline.
         */
        "variant"?: HeadlineVariant;
    }
    interface PIcon {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<IconAriaAttribute>;
        /**
          * Basic color variations depending on theme property.
         */
        "color"?: IconColor;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "lazy"?: boolean;
        /**
          * Specifies which icon to use.
         */
        "name"?: IconName;
        /**
          * The size of the icon.
         */
        "size"?: IconSize;
        /**
          * Specifies a whole icon path which can be used for custom icons.
         */
        "source"?: string;
        /**
          * Adapts the color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
    }
    interface PInlineNotification {
        /**
          * Action icon of the inline-notification.
         */
        "actionIcon"?: InlineNotificationActionIcon;
        /**
          * Action label of the inline-notification.
         */
        "actionLabel"?: string;
        /**
          * Disables the action button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "actionLoading"?: boolean;
        /**
          * Description of the inline-notification.
         */
        "description"?: string;
        /**
          * If false, the inline-notification will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the inline-notification.
         */
        "heading"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `dismissButton` instead. Defines if the inline-notification can be closed/removed by the user.
         */
        "persistent"?: boolean;
        /**
          * State of the inline-notification.
         */
        "state"?: InlineNotificationState;
        /**
          * Adapts the inline-notification color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PLink {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: LinkIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTarget;
        /**
          * Adapts the link color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The style variant of the link.
         */
        "variant"?: LinkVariant;
    }
    interface PLinkPure {
        /**
          * Display link in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<LinkPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkPureAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed
         */
        "icon"?: LinkPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Size of the link.
         */
        "size"?: BreakpointCustomizable<LinkPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkPureTarget;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Shows an underline under the label.
         */
        "underline"?: boolean;
        /**
          * The weight of the text (only has effect with visible label).
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "weight"?: LinkPureWeight;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use `p-link` with corresponding social icon instead.
     */
    interface PLinkSocial {
        /**
          * Show or hide label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown.
         */
        "icon"?: LinkSocialIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkSocialTarget;
        /**
          * Adapts the link color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PLinkTile {
        /**
          * Alignment of link and description.
         */
        "align"?: LinkTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkTileAriaAttribute>;
        /**
          * Aspect ratio of the link-tile.
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileAspectRatio>;
        /**
          * Displays the link-tile as compact version with description and link icon only.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description": string;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show gradient.
         */
        "gradient"?: boolean;
        /**
          * href of the `<a>`.
         */
        "href": string;
        /**
          * Label of the <a />.
         */
        "label": string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Font size of the description.
         */
        "size"?: BreakpointCustomizable<LinkTileSize>;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTileTarget;
        /**
          * Font weight of the description.
         */
        "weight"?: BreakpointCustomizable<LinkTileWeight>;
    }
    interface PLinkTileModelSignature {
        /**
          * Aspect ratio of the link-tile-model-signature.
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileModelSignatureAspectRatio>;
        /**
          * Description text.
         */
        "description"?: string;
        /**
          * Heading text.
         */
        "heading": string;
        /**
          * Sets a custom headline tag which wraps the heading to enhance semantics.
         */
        "headingTag"?: LinkTileModelSignatureHeadingTag;
        /**
          * Defines the direction of the main and cross axis of the links. The default is '{base: ‘column’, xs: ‘row’}' showing buttons vertically stacked on mobile viewports and side-by-side in a horizontal row from breakpoint 'xs'.
         */
        "linkDirection"?: BreakpointCustomizable<LinkTileModelSignatureLinkDirection>;
        /**
          * Adapts the model of the component.
         */
        "model"?: LinkTileModelSignatureModel;
        /**
          * Adapts the font weight of the heading.
         */
        "weight"?: BreakpointCustomizable<LinkTileModelSignatureWeight>;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-wordmark" instead.
     */
    interface PMarque {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<MarqueAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Adapts sizing of marque.
         */
        "size"?: MarqueSize;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: MarqueTarget;
        /**
          * Show/hide trademark sign (only has effect when variant is set to default).
         */
        "trademark"?: boolean;
        /**
          * Shows marque in special editions
         */
        "variant"?: MarqueVariant;
    }
    interface PModal {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ModalAriaAttribute>;
        /**
          * If true, the modal will not be closable via backdrop click.
         */
        "disableBackdropClick"?: boolean;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `dismissButton` instead. If true, the modal will not have a dismiss button.
         */
        "disableCloseButton"?: boolean;
        /**
          * If false, the modal will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * If true the modal uses max viewport height and width. Should only be used for mobile.
         */
        "fullscreen"?: BreakpointCustomizable<boolean>;
        /**
          * The title of the modal
         */
        "heading"?: string;
        /**
          * If true, the modal is open.
         */
        "open": boolean;
    }
    interface PModelSignature {
        /**
          * Adapts the color of the component.
         */
        "color"?: ModelSignatureColor;
        /**
          * Adapts the model of the component.
         */
        "model"?: ModelSignatureModel;
        /**
          * Adapts the size of the component.
         */
        "size"?: ModelSignatureSize;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    interface PPagination {
        /**
          * Index of the currently active page.
         */
        "activePage"?: number;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.root` instead. Aria label what the pagination is used for.
         */
        "allyLabel"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.next` instead. Aria label for next page icon.
         */
        "allyLabelNext"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.page` instead. Aria label for page navigation.
         */
        "allyLabelPage"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.prev` instead. Aria label for previous page icon.
         */
        "allyLabelPrev"?: string;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev and page buttons.
         */
        "intl"?: PaginationInternationalization;
        /**
          * The total count of items which should be shown per page.
         */
        "itemsPerPage": number;
        /**
          * The maximum number of page links rendered
         */
        "maxNumberOfPageLinks"?: BreakpointCustomizable<PaginationMaxNumberOfPageLinks>;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The total count of items.
         */
        "totalItemsCount": number;
    }
    interface PPopover {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<PopoverAriaAttribute>;
        /**
          * Descriptive text to show additional information when popover is open
         */
        "description"?: string;
        /**
          * Preferred direction in which popover should open, given there is enough space in viewport. Otherwise, it will be opened in the direction with most available space.
         */
        "direction"?: PopoverDirection;
        /**
          * Adapts the popover color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PRadioButtonWrapper {
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: RadioButtonWrapperState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PScroller {
        /**
          * Sets the vertical position of scroll indicator.
         */
        "alignScrollIndicator"?: ScrollerAlignScrollIndicator;
        /**
          * Add ARIA role.
         */
        "aria"?: SelectedAriaAttributes<ScrollerAriaAttribute>;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColor"?: ScrollerGradientColor;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `gradientColor` instead. Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: ScrollerGradientColorScheme;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `alignScrollIndicator` instead. Sets the vertical position of scroll indicator
         */
        "scrollIndicatorPosition"?: ScrollerScrollIndicatorPosition;
        /**
          * Scrolls the scroll area to the left either smooth or immediately.
         */
        "scrollToPosition"?: ScrollerScrollToPosition;
        /**
          * Specifies if scrollbar should be shown.
         */
        "scrollbar"?: boolean;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PSegmentedControl {
        /**
          * @deprecated since v3.0.0, will be removed with next major release. Background color variations
         */
        "backgroundColor"?: SegmentedControlBackgroundColor;
        /**
          * Adapts the segmented-control color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Sets the initial value of the segmented-control.
         */
        "value"?: string | number;
    }
    interface PSegmentedControlItem {
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The icon shown.
         */
        "icon"?: SegmentedControlItemIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The value of this item which is emitted by the parent element if it becomes selected. This property is **required**.
         */
        "value": string | number;
    }
    interface PSelectWrapper {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Changes the direction to which the dropdown list appears.
         */
        "dropdownDirection"?: SelectWrapperDropdownDirection;
        /**
          * Filters select options by typing a character
         */
        "filter"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Forces rendering of native browser select dropdown
         */
        "native"?: boolean;
        /**
          * The validation state.
         */
        "state"?: SelectWrapperState;
        /**
          * Adapts the select color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PSelectWrapperDropdown {
        "description"?: string;
        "direction"?: SelectWrapperDropdownDirection;
        "disabled"?: boolean;
        "filter"?: boolean;
        "isOpenOverride"?: boolean;
        "label"?: string;
        "message"?: string;
        "onOpenChange": (isOpen: boolean) => void;
        "required"?: boolean;
        "selectRef"?: HTMLSelectElement;
        "state"?: SelectWrapperState;
        "theme"?: Theme;
    }
    interface PSpinner {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SpinnerAriaAttribute>;
        /**
          * Size of the spinner.
         */
        "size"?: BreakpointCustomizable<SpinnerSize>;
        /**
          * Adapts the spinner color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PStepperHorizontal {
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<StepperHorizontalSize>;
        /**
          * Adapts the tag color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PStepperHorizontalItem {
        /**
          * Disables the stepper-horizontal-item. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The validation state.
         */
        "state"?: StepperHorizontalItemState;
    }
    interface PSwitch {
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<SwitchAlignLabel>;
        /**
          * Visualize the switch with on/off status.
         */
        "checked"?: boolean;
        /**
          * Disables the switch. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Disables the switch and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Stretches the contents to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Adapts the switch color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PTable {
        /**
          * A caption describing the contents of the table for accessibility only. This won't be visible in the browser. Use an element with an attribute of `slot="caption"` for a visible caption.
         */
        "caption"?: string;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PTableBody {
    }
    interface PTableCell {
        /**
          * Displays slotted text multiline or forced into a single line.
         */
        "multiline"?: boolean;
    }
    interface PTableHead {
    }
    interface PTableHeadCell {
        /**
          * Hides the label but stays accessible for screen readers. This property only takes effect when sort property is not defined.
         */
        "hideLabel"?: boolean;
        /**
          * Displays slotted text multiline or forced into a single line.
         */
        "multiline"?: boolean;
        /**
          * Defines sortability properties.
         */
        "sort"?: TableHeadCellSort;
    }
    interface PTableHeadRow {
    }
    interface PTableRow {
    }
    interface PTabs {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering).
         */
        "activeTabIndex"?: number;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColor"?: TabsGradientColor;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `gradientColor` instead. Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: TabsGradientColorScheme;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabsSize>;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The text weight.
         */
        "weight"?: TabsWeight;
    }
    interface PTabsBar {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering), undefined if none should be selected.
         */
        "activeTabIndex"?: number | undefined;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColor"?: TabsBarGradientColor;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `gradientColor` instead. Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: TabsBarGradientColorScheme;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabsBarSize>;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The text weight.
         */
        "weight"?: TabsBarWeight;
    }
    interface PTabsItem {
        /**
          * Defines the label used in tabs.
         */
        "label": string;
    }
    interface PTag {
        /**
          * Background color variations depending on theme property.
         */
        "color"?: TagColor;
        /**
          * The icon shown.
         */
        "icon"?: TagIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Adapts the tag color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PTagDismissible {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<TagDismissibleAriaAttribute>;
        /**
          * Background color variations
         */
        "color"?: TagDismissibleColor;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PText {
        /**
          * Text alignment of the component.
         */
        "align"?: TextAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: TextColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the text. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<TextSize>;
        /**
          * Sets a custom HTML tag depending on the usage of the text component.
         */
        "tag"?: TextTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
        /**
          * The weight of the text.
         */
        "weight"?: TextWeight;
    }
    interface PTextFieldWrapper {
        /**
          * Action icon can be set to `locate` for `input type="search"` in order to display an action button.
         */
        "actionIcon"?: TextFieldWrapperActionIcon;
        /**
          * Disables the action button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "actionLoading"?: boolean;
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Show or hide label and description text. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `showCounter` instead. Show or hide max character count.
         */
        "showCharacterCount"?: boolean;
        /**
          * Show or hide max character count.
         */
        "showCounter"?: boolean;
        /**
          * __Experimental__: Show or hide password toggle for `input type="password"`.
         */
        "showPasswordToggle"?: boolean;
        /**
          * The validation state.
         */
        "state"?: TextFieldWrapperState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * The unit text.
         */
        "unit"?: string;
        /**
          * The unit position.
         */
        "unitPosition"?: TextFieldWrapperUnitPosition;
    }
    interface PTextList {
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `type` instead. The type of the list.
         */
        "listType"?: TextListListType;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `type` instead. The list style type of ordered list. Only has effect when list type is set to 'ordered'.
         */
        "orderType"?: TextListOrderType;
        /**
          * Adapts the text color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * The list style type.
         */
        "type"?: TextListType;
    }
    interface PTextListItem {
    }
    interface PTextareaWrapper {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `showCounter` instead. Show or hide max character count.
         */
        "showCharacterCount"?: boolean;
        /**
          * Show or hide max character count.
         */
        "showCounter"?: boolean;
        /**
          * The validation state.
         */
        "state"?: TextareaWrapperState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PToast {
        "addMessage": (message: ToastMessage) => Promise<void>;
        /**
          * Adapts the toast color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PToastItem {
        /**
          * State of the toast-item.
         */
        "state"?: ToastState;
        /**
          * Text of the toast-item.
         */
        "text"?: string;
        /**
          * Adapts the toast-item color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PWordmark {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<WordmarkAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Adapts sizing of wordmark.
         */
        "size"?: WordmarkSize;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: WordmarkTarget;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
}
export interface PAccordionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPAccordionElement;
}
export interface PBannerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPBannerElement;
}
export interface PCarouselCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPCarouselElement;
}
export interface PFlyoutCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPFlyoutElement;
}
export interface PInlineNotificationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInlineNotificationElement;
}
export interface PModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPModalElement;
}
export interface PPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPPaginationElement;
}
export interface PSegmentedControlCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPSegmentedControlElement;
}
export interface PStepperHorizontalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPStepperHorizontalElement;
}
export interface PSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPSwitchElement;
}
export interface PTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTableElement;
}
export interface PTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTabsElement;
}
export interface PTabsBarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTabsBarElement;
}
export interface PTextFieldWrapperCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTextFieldWrapperElement;
}
export interface PToastItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPToastItemElement;
}
declare global {
    interface HTMLPAccordionElement extends Components.PAccordion, HTMLStencilElement {
    }
    var HTMLPAccordionElement: {
        prototype: HTMLPAccordionElement;
        new (): HTMLPAccordionElement;
    };
    interface HTMLPBannerElement extends Components.PBanner, HTMLStencilElement {
    }
    var HTMLPBannerElement: {
        prototype: HTMLPBannerElement;
        new (): HTMLPBannerElement;
    };
    interface HTMLPButtonElement extends Components.PButton, HTMLStencilElement {
    }
    var HTMLPButtonElement: {
        prototype: HTMLPButtonElement;
        new (): HTMLPButtonElement;
    };
    interface HTMLPButtonGroupElement extends Components.PButtonGroup, HTMLStencilElement {
    }
    var HTMLPButtonGroupElement: {
        prototype: HTMLPButtonGroupElement;
        new (): HTMLPButtonGroupElement;
    };
    interface HTMLPButtonPureElement extends Components.PButtonPure, HTMLStencilElement {
    }
    var HTMLPButtonPureElement: {
        prototype: HTMLPButtonPureElement;
        new (): HTMLPButtonPureElement;
    };
    interface HTMLPButtonTileElement extends Components.PButtonTile, HTMLStencilElement {
    }
    var HTMLPButtonTileElement: {
        prototype: HTMLPButtonTileElement;
        new (): HTMLPButtonTileElement;
    };
    interface HTMLPCarouselElement extends Components.PCarousel, HTMLStencilElement {
    }
    var HTMLPCarouselElement: {
        prototype: HTMLPCarouselElement;
        new (): HTMLPCarouselElement;
    };
    interface HTMLPCheckboxWrapperElement extends Components.PCheckboxWrapper, HTMLStencilElement {
    }
    var HTMLPCheckboxWrapperElement: {
        prototype: HTMLPCheckboxWrapperElement;
        new (): HTMLPCheckboxWrapperElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface HTMLPContentWrapperElement extends Components.PContentWrapper, HTMLStencilElement {
    }
    var HTMLPContentWrapperElement: {
        prototype: HTMLPContentWrapperElement;
        new (): HTMLPContentWrapperElement;
    };
    interface HTMLPCrestElement extends Components.PCrest, HTMLStencilElement {
    }
    var HTMLPCrestElement: {
        prototype: HTMLPCrestElement;
        new (): HTMLPCrestElement;
    };
    interface HTMLPDisplayElement extends Components.PDisplay, HTMLStencilElement {
    }
    var HTMLPDisplayElement: {
        prototype: HTMLPDisplayElement;
        new (): HTMLPDisplayElement;
    };
    interface HTMLPDividerElement extends Components.PDivider, HTMLStencilElement {
    }
    var HTMLPDividerElement: {
        prototype: HTMLPDividerElement;
        new (): HTMLPDividerElement;
    };
    interface HTMLPFieldsetElement extends Components.PFieldset, HTMLStencilElement {
    }
    var HTMLPFieldsetElement: {
        prototype: HTMLPFieldsetElement;
        new (): HTMLPFieldsetElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-fieldset" instead.
     */
    interface HTMLPFieldsetWrapperElement extends Components.PFieldsetWrapper, HTMLStencilElement {
    }
    var HTMLPFieldsetWrapperElement: {
        prototype: HTMLPFieldsetWrapperElement;
        new (): HTMLPFieldsetWrapperElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
     */
    interface HTMLPFlexElement extends Components.PFlex, HTMLStencilElement {
    }
    var HTMLPFlexElement: {
        prototype: HTMLPFlexElement;
        new (): HTMLPFlexElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
     */
    interface HTMLPFlexItemElement extends Components.PFlexItem, HTMLStencilElement {
    }
    var HTMLPFlexItemElement: {
        prototype: HTMLPFlexItemElement;
        new (): HTMLPFlexItemElement;
    };
    interface HTMLPFlyoutElement extends Components.PFlyout, HTMLStencilElement {
    }
    var HTMLPFlyoutElement: {
        prototype: HTMLPFlyoutElement;
        new (): HTMLPFlyoutElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface HTMLPGridElement extends Components.PGrid, HTMLStencilElement {
    }
    var HTMLPGridElement: {
        prototype: HTMLPGridElement;
        new (): HTMLPGridElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface HTMLPGridItemElement extends Components.PGridItem, HTMLStencilElement {
    }
    var HTMLPGridItemElement: {
        prototype: HTMLPGridItemElement;
        new (): HTMLPGridItemElement;
    };
    interface HTMLPHeadingElement extends Components.PHeading, HTMLStencilElement {
    }
    var HTMLPHeadingElement: {
        prototype: HTMLPHeadingElement;
        new (): HTMLPHeadingElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-heading" instead.
     */
    interface HTMLPHeadlineElement extends Components.PHeadline, HTMLStencilElement {
    }
    var HTMLPHeadlineElement: {
        prototype: HTMLPHeadlineElement;
        new (): HTMLPHeadlineElement;
    };
    interface HTMLPIconElement extends Components.PIcon, HTMLStencilElement {
    }
    var HTMLPIconElement: {
        prototype: HTMLPIconElement;
        new (): HTMLPIconElement;
    };
    interface HTMLPInlineNotificationElement extends Components.PInlineNotification, HTMLStencilElement {
    }
    var HTMLPInlineNotificationElement: {
        prototype: HTMLPInlineNotificationElement;
        new (): HTMLPInlineNotificationElement;
    };
    interface HTMLPLinkElement extends Components.PLink, HTMLStencilElement {
    }
    var HTMLPLinkElement: {
        prototype: HTMLPLinkElement;
        new (): HTMLPLinkElement;
    };
    interface HTMLPLinkPureElement extends Components.PLinkPure, HTMLStencilElement {
    }
    var HTMLPLinkPureElement: {
        prototype: HTMLPLinkPureElement;
        new (): HTMLPLinkPureElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use `p-link` with corresponding social icon instead.
     */
    interface HTMLPLinkSocialElement extends Components.PLinkSocial, HTMLStencilElement {
    }
    var HTMLPLinkSocialElement: {
        prototype: HTMLPLinkSocialElement;
        new (): HTMLPLinkSocialElement;
    };
    interface HTMLPLinkTileElement extends Components.PLinkTile, HTMLStencilElement {
    }
    var HTMLPLinkTileElement: {
        prototype: HTMLPLinkTileElement;
        new (): HTMLPLinkTileElement;
    };
    interface HTMLPLinkTileModelSignatureElement extends Components.PLinkTileModelSignature, HTMLStencilElement {
    }
    var HTMLPLinkTileModelSignatureElement: {
        prototype: HTMLPLinkTileModelSignatureElement;
        new (): HTMLPLinkTileModelSignatureElement;
    };
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-wordmark" instead.
     */
    interface HTMLPMarqueElement extends Components.PMarque, HTMLStencilElement {
    }
    var HTMLPMarqueElement: {
        prototype: HTMLPMarqueElement;
        new (): HTMLPMarqueElement;
    };
    interface HTMLPModalElement extends Components.PModal, HTMLStencilElement {
    }
    var HTMLPModalElement: {
        prototype: HTMLPModalElement;
        new (): HTMLPModalElement;
    };
    interface HTMLPModelSignatureElement extends Components.PModelSignature, HTMLStencilElement {
    }
    var HTMLPModelSignatureElement: {
        prototype: HTMLPModelSignatureElement;
        new (): HTMLPModelSignatureElement;
    };
    interface HTMLPPaginationElement extends Components.PPagination, HTMLStencilElement {
    }
    var HTMLPPaginationElement: {
        prototype: HTMLPPaginationElement;
        new (): HTMLPPaginationElement;
    };
    interface HTMLPPopoverElement extends Components.PPopover, HTMLStencilElement {
    }
    var HTMLPPopoverElement: {
        prototype: HTMLPPopoverElement;
        new (): HTMLPPopoverElement;
    };
    interface HTMLPRadioButtonWrapperElement extends Components.PRadioButtonWrapper, HTMLStencilElement {
    }
    var HTMLPRadioButtonWrapperElement: {
        prototype: HTMLPRadioButtonWrapperElement;
        new (): HTMLPRadioButtonWrapperElement;
    };
    interface HTMLPScrollerElement extends Components.PScroller, HTMLStencilElement {
    }
    var HTMLPScrollerElement: {
        prototype: HTMLPScrollerElement;
        new (): HTMLPScrollerElement;
    };
    interface HTMLPSegmentedControlElement extends Components.PSegmentedControl, HTMLStencilElement {
    }
    var HTMLPSegmentedControlElement: {
        prototype: HTMLPSegmentedControlElement;
        new (): HTMLPSegmentedControlElement;
    };
    interface HTMLPSegmentedControlItemElement extends Components.PSegmentedControlItem, HTMLStencilElement {
    }
    var HTMLPSegmentedControlItemElement: {
        prototype: HTMLPSegmentedControlItemElement;
        new (): HTMLPSegmentedControlItemElement;
    };
    interface HTMLPSelectWrapperElement extends Components.PSelectWrapper, HTMLStencilElement {
    }
    var HTMLPSelectWrapperElement: {
        prototype: HTMLPSelectWrapperElement;
        new (): HTMLPSelectWrapperElement;
    };
    interface HTMLPSelectWrapperDropdownElement extends Components.PSelectWrapperDropdown, HTMLStencilElement {
    }
    var HTMLPSelectWrapperDropdownElement: {
        prototype: HTMLPSelectWrapperDropdownElement;
        new (): HTMLPSelectWrapperDropdownElement;
    };
    interface HTMLPSpinnerElement extends Components.PSpinner, HTMLStencilElement {
    }
    var HTMLPSpinnerElement: {
        prototype: HTMLPSpinnerElement;
        new (): HTMLPSpinnerElement;
    };
    interface HTMLPStepperHorizontalElement extends Components.PStepperHorizontal, HTMLStencilElement {
    }
    var HTMLPStepperHorizontalElement: {
        prototype: HTMLPStepperHorizontalElement;
        new (): HTMLPStepperHorizontalElement;
    };
    interface HTMLPStepperHorizontalItemElement extends Components.PStepperHorizontalItem, HTMLStencilElement {
    }
    var HTMLPStepperHorizontalItemElement: {
        prototype: HTMLPStepperHorizontalItemElement;
        new (): HTMLPStepperHorizontalItemElement;
    };
    interface HTMLPSwitchElement extends Components.PSwitch, HTMLStencilElement {
    }
    var HTMLPSwitchElement: {
        prototype: HTMLPSwitchElement;
        new (): HTMLPSwitchElement;
    };
    interface HTMLPTableElement extends Components.PTable, HTMLStencilElement {
    }
    var HTMLPTableElement: {
        prototype: HTMLPTableElement;
        new (): HTMLPTableElement;
    };
    interface HTMLPTableBodyElement extends Components.PTableBody, HTMLStencilElement {
    }
    var HTMLPTableBodyElement: {
        prototype: HTMLPTableBodyElement;
        new (): HTMLPTableBodyElement;
    };
    interface HTMLPTableCellElement extends Components.PTableCell, HTMLStencilElement {
    }
    var HTMLPTableCellElement: {
        prototype: HTMLPTableCellElement;
        new (): HTMLPTableCellElement;
    };
    interface HTMLPTableHeadElement extends Components.PTableHead, HTMLStencilElement {
    }
    var HTMLPTableHeadElement: {
        prototype: HTMLPTableHeadElement;
        new (): HTMLPTableHeadElement;
    };
    interface HTMLPTableHeadCellElement extends Components.PTableHeadCell, HTMLStencilElement {
    }
    var HTMLPTableHeadCellElement: {
        prototype: HTMLPTableHeadCellElement;
        new (): HTMLPTableHeadCellElement;
    };
    interface HTMLPTableHeadRowElement extends Components.PTableHeadRow, HTMLStencilElement {
    }
    var HTMLPTableHeadRowElement: {
        prototype: HTMLPTableHeadRowElement;
        new (): HTMLPTableHeadRowElement;
    };
    interface HTMLPTableRowElement extends Components.PTableRow, HTMLStencilElement {
    }
    var HTMLPTableRowElement: {
        prototype: HTMLPTableRowElement;
        new (): HTMLPTableRowElement;
    };
    interface HTMLPTabsElement extends Components.PTabs, HTMLStencilElement {
    }
    var HTMLPTabsElement: {
        prototype: HTMLPTabsElement;
        new (): HTMLPTabsElement;
    };
    interface HTMLPTabsBarElement extends Components.PTabsBar, HTMLStencilElement {
    }
    var HTMLPTabsBarElement: {
        prototype: HTMLPTabsBarElement;
        new (): HTMLPTabsBarElement;
    };
    interface HTMLPTabsItemElement extends Components.PTabsItem, HTMLStencilElement {
    }
    var HTMLPTabsItemElement: {
        prototype: HTMLPTabsItemElement;
        new (): HTMLPTabsItemElement;
    };
    interface HTMLPTagElement extends Components.PTag, HTMLStencilElement {
    }
    var HTMLPTagElement: {
        prototype: HTMLPTagElement;
        new (): HTMLPTagElement;
    };
    interface HTMLPTagDismissibleElement extends Components.PTagDismissible, HTMLStencilElement {
    }
    var HTMLPTagDismissibleElement: {
        prototype: HTMLPTagDismissibleElement;
        new (): HTMLPTagDismissibleElement;
    };
    interface HTMLPTextElement extends Components.PText, HTMLStencilElement {
    }
    var HTMLPTextElement: {
        prototype: HTMLPTextElement;
        new (): HTMLPTextElement;
    };
    interface HTMLPTextFieldWrapperElement extends Components.PTextFieldWrapper, HTMLStencilElement {
    }
    var HTMLPTextFieldWrapperElement: {
        prototype: HTMLPTextFieldWrapperElement;
        new (): HTMLPTextFieldWrapperElement;
    };
    interface HTMLPTextListElement extends Components.PTextList, HTMLStencilElement {
    }
    var HTMLPTextListElement: {
        prototype: HTMLPTextListElement;
        new (): HTMLPTextListElement;
    };
    interface HTMLPTextListItemElement extends Components.PTextListItem, HTMLStencilElement {
    }
    var HTMLPTextListItemElement: {
        prototype: HTMLPTextListItemElement;
        new (): HTMLPTextListItemElement;
    };
    interface HTMLPTextareaWrapperElement extends Components.PTextareaWrapper, HTMLStencilElement {
    }
    var HTMLPTextareaWrapperElement: {
        prototype: HTMLPTextareaWrapperElement;
        new (): HTMLPTextareaWrapperElement;
    };
    interface HTMLPToastElement extends Components.PToast, HTMLStencilElement {
    }
    var HTMLPToastElement: {
        prototype: HTMLPToastElement;
        new (): HTMLPToastElement;
    };
    interface HTMLPToastItemElement extends Components.PToastItem, HTMLStencilElement {
    }
    var HTMLPToastItemElement: {
        prototype: HTMLPToastItemElement;
        new (): HTMLPToastItemElement;
    };
    interface HTMLPWordmarkElement extends Components.PWordmark, HTMLStencilElement {
    }
    var HTMLPWordmarkElement: {
        prototype: HTMLPWordmarkElement;
        new (): HTMLPWordmarkElement;
    };
    interface HTMLElementTagNameMap {
        "p-accordion": HTMLPAccordionElement;
        "p-banner": HTMLPBannerElement;
        "p-button": HTMLPButtonElement;
        "p-button-group": HTMLPButtonGroupElement;
        "p-button-pure": HTMLPButtonPureElement;
        "p-button-tile": HTMLPButtonTileElement;
        "p-carousel": HTMLPCarouselElement;
        "p-checkbox-wrapper": HTMLPCheckboxWrapperElement;
        "p-content-wrapper": HTMLPContentWrapperElement;
        "p-crest": HTMLPCrestElement;
        "p-display": HTMLPDisplayElement;
        "p-divider": HTMLPDividerElement;
        "p-fieldset": HTMLPFieldsetElement;
        "p-fieldset-wrapper": HTMLPFieldsetWrapperElement;
        "p-flex": HTMLPFlexElement;
        "p-flex-item": HTMLPFlexItemElement;
        "p-flyout": HTMLPFlyoutElement;
        "p-grid": HTMLPGridElement;
        "p-grid-item": HTMLPGridItemElement;
        "p-heading": HTMLPHeadingElement;
        "p-headline": HTMLPHeadlineElement;
        "p-icon": HTMLPIconElement;
        "p-inline-notification": HTMLPInlineNotificationElement;
        "p-link": HTMLPLinkElement;
        "p-link-pure": HTMLPLinkPureElement;
        "p-link-social": HTMLPLinkSocialElement;
        "p-link-tile": HTMLPLinkTileElement;
        "p-link-tile-model-signature": HTMLPLinkTileModelSignatureElement;
        "p-marque": HTMLPMarqueElement;
        "p-modal": HTMLPModalElement;
        "p-model-signature": HTMLPModelSignatureElement;
        "p-pagination": HTMLPPaginationElement;
        "p-popover": HTMLPPopoverElement;
        "p-radio-button-wrapper": HTMLPRadioButtonWrapperElement;
        "p-scroller": HTMLPScrollerElement;
        "p-segmented-control": HTMLPSegmentedControlElement;
        "p-segmented-control-item": HTMLPSegmentedControlItemElement;
        "p-select-wrapper": HTMLPSelectWrapperElement;
        "p-select-wrapper-dropdown": HTMLPSelectWrapperDropdownElement;
        "p-spinner": HTMLPSpinnerElement;
        "p-stepper-horizontal": HTMLPStepperHorizontalElement;
        "p-stepper-horizontal-item": HTMLPStepperHorizontalItemElement;
        "p-switch": HTMLPSwitchElement;
        "p-table": HTMLPTableElement;
        "p-table-body": HTMLPTableBodyElement;
        "p-table-cell": HTMLPTableCellElement;
        "p-table-head": HTMLPTableHeadElement;
        "p-table-head-cell": HTMLPTableHeadCellElement;
        "p-table-head-row": HTMLPTableHeadRowElement;
        "p-table-row": HTMLPTableRowElement;
        "p-tabs": HTMLPTabsElement;
        "p-tabs-bar": HTMLPTabsBarElement;
        "p-tabs-item": HTMLPTabsItemElement;
        "p-tag": HTMLPTagElement;
        "p-tag-dismissible": HTMLPTagDismissibleElement;
        "p-text": HTMLPTextElement;
        "p-text-field-wrapper": HTMLPTextFieldWrapperElement;
        "p-text-list": HTMLPTextListElement;
        "p-text-list-item": HTMLPTextListItemElement;
        "p-textarea-wrapper": HTMLPTextareaWrapperElement;
        "p-toast": HTMLPToastElement;
        "p-toast-item": HTMLPToastItemElement;
        "p-wordmark": HTMLPWordmarkElement;
    }
}
declare namespace LocalJSX {
    interface PAccordion {
        /**
          * Displays the Accordion as compact version with thinner border and smaller paddings.
         */
        "compact"?: boolean;
        /**
          * Defines the heading used in accordion.
         */
        "heading"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when accordion state is changed.
         */
        "onAccordionChange"?: (event: PAccordionCustomEvent<AccordionUpdateEvent>) => void;
        /**
          * Emitted when accordion state is changed.
         */
        "onUpdate"?: (event: PAccordionCustomEvent<AccordionUpdateEvent>) => void;
        /**
          * Defines if accordion is open.
         */
        "open"?: boolean;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<AccordionSize>;
        /**
          * Sets a headline tag, so it fits correctly within the outline of the page.
         */
        "tag"?: AccordionTag;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PBanner {
        /**
          * Description of the banner.
         */
        "description"?: string;
        /**
          * If false, the banner will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the banner.
         */
        "heading"?: string;
        /**
          * Emitted when the close button is clicked.
         */
        "onDismiss"?: (event: PBannerCustomEvent<void>) => void;
        /**
          * If true, the banner is open.
         */
        "open"?: boolean;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `dismissButton` instead. Defines if the banner can be closed/removed by the user.
         */
        "persistent"?: boolean;
        /**
          * State of the banner.
         */
        "state"?: BannerState;
        /**
          * Adapts the banner color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "width"?: BannerWidth;
    }
    interface PButton {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: ButtonIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonType;
        /**
          * The style variant of the button.
         */
        "variant"?: ButtonVariant;
    }
    interface PButtonGroup {
        /**
          * Defines the direction of the main and cross axis. The default is ’{base: ‘column’, xs: ‘row’}' showing buttons vertically stacked on mobile viewports and side-by-side in a horizontal row from breakpoint ‘xs’. You always need to provide a base value when using breakpoints.
         */
        "direction"?: BreakpointCustomizable<ButtonGroupDirection>;
    }
    interface PButtonPure {
        /**
          * Display button in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<ButtonPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonPureAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown.
         */
        "icon"?: ButtonPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Size of the button.
         */
        "size"?: BreakpointCustomizable<ButtonPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonPureType;
        /**
          * The weight of the text (only has effect with visible label).
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "weight"?: ButtonPureWeight;
    }
    interface PButtonTile {
        /**
          * Alignment of button and description.
         */
        "align"?: ButtonTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonTileAriaAttribute>;
        /**
          * Aspect ratio of the button-tile.
         */
        "aspectRatio"?: BreakpointCustomizable<ButtonTileAspectRatio>;
        /**
          * Displays the button-tile as compact version with description and button icon only.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description"?: string;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show gradient.
         */
        "gradient"?: boolean;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: ButtonTileIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Label of the button.
         */
        "label"?: string;
        /**
          * Disables the button-tile and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Font size of the description.
         */
        "size"?: BreakpointCustomizable<ButtonTileSize>;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonTileType;
        /**
          * Font weight of the description.
         */
        "weight"?: BreakpointCustomizable<ButtonTileWeight>;
    }
    interface PCarousel {
        /**
          * Defines which slide to be active (zero-based numbering).
         */
        "activeSlideIndex"?: number;
        /**
          * Alignment of heading and description
         */
        "alignHeader"?: CarouselAlignHeader;
        /**
          * Defines the description used in the carousel.
         */
        "description"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `pagination` instead. If true, the carousel will not show pagination bullets at the bottom.
         */
        "disablePagination"?: BreakpointCustomizable<boolean>;
        /**
          * Defines the heading used in the carousel.
         */
        "heading"?: string;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev buttons and pagination.
         */
        "intl"?: CarouselInternationalization;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when carousel's content slides.
         */
        "onCarouselChange"?: (event: PCarouselCustomEvent<CarouselUpdateEvent>) => void;
        /**
          * Emitted when carousel's content slides.
         */
        "onUpdate"?: (event: PCarouselCustomEvent<CarouselUpdateEvent>) => void;
        /**
          * If false, the carousel will not show pagination bullets at the bottom.
         */
        "pagination"?: BreakpointCustomizable<boolean>;
        /**
          * Whether the slides should rewind from last to first slide and vice versa.
         */
        "rewind"?: boolean;
        /**
          * Sets the amount of slides visible at the same time. Can be set to `auto` if you want to define different widths per slide via CSS.
         */
        "slidesPerPage"?: BreakpointCustomizable<number> | 'auto';
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * Defines the outer spacings between the carousel and the left and right screen sides.
         */
        "width"?: CarouselWidth;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "wrapContent"?: boolean;
    }
    interface PCheckboxWrapper {
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * __Experimental__: Disables the checkbox and shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: CheckboxWrapperState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface PContentWrapper {
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "backgroundColor"?: ContentWrapperBackgroundColor;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "theme"?: Theme;
        /**
          * Defines the outer spacings between the content area and the left and right screen sides, as well as centering its content and setting a max-width.
         */
        "width"?: ContentWrapperWidth;
    }
    interface PCrest {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<CrestAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: CrestTarget;
    }
    interface PDisplay {
        /**
          * Text alignment of the component.
         */
        "align"?: DisplayAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: DisplayColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "medium", l: "large"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<DisplaySize>;
        /**
          * Sets a custom HTML tag depending on the usage of the display component.
         */
        "tag"?: DisplayTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
    }
    interface PDivider {
        /**
          * Defines color depending on theme.
         */
        "color"?: DividerColor;
        /**
          * Defines direction.
         */
        "direction"?: BreakpointCustomizable<DividerDirection>;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `direction` instead. Defines orientation.
         */
        "orientation"?: BreakpointCustomizable<DividerOrientation>;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    interface PFieldset {
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The size of the label text.
         */
        "labelSize"?: FieldsetLabelSize;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Marks the Fieldset as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: FieldsetState;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-fieldset" instead.
     */
    interface PFieldsetWrapper {
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The size of the label text.
         */
        "labelSize"?: FieldsetWrapperLabelSize;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Marks the Fieldset as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: FieldsetWrapperState;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
     */
    interface PFlex {
        /**
          * This aligns a flex container's individual lines when there is extra space in the cross-axis, similar to how "justifyContent" aligns individual items along the main axis.
         */
        "alignContent"?: BreakpointCustomizable<FlexAlignContent>;
        /**
          * Defines how the flex items are aligned along the cross axis.
         */
        "alignItems"?: BreakpointCustomizable<FlexAlignItems>;
        /**
          * Defines the direction of the main and cross axis. The default "row" defines the main axis as horizontal left to right.
         */
        "direction"?: BreakpointCustomizable<FlexDirection>;
        /**
          * Defines the flex containers content flow if 2 or more containers are siblings of each other.
         */
        "inline"?: BreakpointCustomizable<FlexInline>;
        /**
          * Defines how the flex items are aligned along the main axis.
         */
        "justifyContent"?: BreakpointCustomizable<FlexJustifyContent>;
        /**
          * Handles wrapping behaviour of elements.
         */
        "wrap"?: BreakpointCustomizable<FlexWrap>;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
     */
    interface PFlexItem {
        /**
          * Defines how this flex item is aligned along the cross axis. This overwrites the cross axis alignment set by the container. Corresponds to the "alignSelf" css property.
         */
        "alignSelf"?: BreakpointCustomizable<FlexItemAlignSelf>;
        /**
          * The shorthand property for the combined definition of "shrink", "grow" and "basis"
         */
        "flex"?: BreakpointCustomizable<FlexItemFlex>;
        /**
          * The ability to allow/disallow the flex child to grow.
         */
        "grow"?: BreakpointCustomizable<FlexItemGrow>;
        /**
          * The offset of the column. You can also supply values for specific breakpoints, like {base: "none", l: "one-quarter"}. You always need to provide a base value when doing this.
         */
        "offset"?: BreakpointCustomizable<FlexItemOffset>;
        /**
          * The ability to allow/disallow the flex child to shrink.
         */
        "shrink"?: BreakpointCustomizable<FlexItemShrink>;
        /**
          * The width of the flex item. You can also supply values for specific breakpoints, like {base: "full", l: "one-quarter"}. You always need to provide a base value when doing this.
         */
        "width"?: BreakpointCustomizable<FlexItemWidth>;
    }
    interface PFlyout {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<FlyoutAriaAttribute>;
        /**
          * Emitted when the component requests to be dismissed.
         */
        "onDismiss"?: (event: PFlyoutCustomEvent<void>) => void;
        /**
          * If true, the flyout is open.
         */
        "open"?: boolean;
        /**
          * The position of the flyout
         */
        "position"?: FlyoutPosition;
        /**
          * Adapts the flyout color depending on the theme.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface PGrid {
        /**
          * Defines the direction of the main and cross axis. The default "row" defines the main axis as horizontal left to right. Also defines the direction for specific breakpoints, like {base: "column", l: "row"}. You always need to provide a base value when doing this.
         */
        "direction"?: BreakpointCustomizable<GridDirection>;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "gutter"?: BreakpointCustomizable<GridGutter>;
        /**
          * Handles wrapping behaviour of elements.
         */
        "wrap"?: BreakpointCustomizable<GridWrap>;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
     */
    interface PGridItem {
        /**
          * The offset of the column. Can be between 0 and 11. Also defines the offset of the column for specific breakpoints, like {base: 6, l: 3}. You always need to provide a base value when doing this.
         */
        "offset"?: BreakpointCustomizable<GridItemOffset>;
        /**
          * The size of the column. Can be between 1 and 12. Also defines the size of the column for specific breakpoints, like {base: 6, l: 3}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<GridItemSize>;
    }
    interface PHeading {
        /**
          * Text alignment of the component.
         */
        "align"?: HeadingAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: HeadingColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<HeadingSize>;
        /**
          * Sets a custom HTML tag depending on the usage of the heading component.
         */
        "tag"?: HeadingTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-heading" instead.
     */
    interface PHeadline {
        /**
          * Text alignment of the component.
         */
        "align"?: HeadlineAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: HeadlineColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Sets a custom HTML tag depending on the usage of the headline component.
         */
        "tag"?: HeadlineTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
        /**
          * Predefined style of the headline.
         */
        "variant"?: HeadlineVariant;
    }
    interface PIcon {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<IconAriaAttribute>;
        /**
          * Basic color variations depending on theme property.
         */
        "color"?: IconColor;
        /**
          * Has no effect anymore
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "lazy"?: boolean;
        /**
          * Specifies which icon to use.
         */
        "name"?: IconName;
        /**
          * The size of the icon.
         */
        "size"?: IconSize;
        /**
          * Specifies a whole icon path which can be used for custom icons.
         */
        "source"?: string;
        /**
          * Adapts the color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
    }
    interface PInlineNotification {
        /**
          * Action icon of the inline-notification.
         */
        "actionIcon"?: InlineNotificationActionIcon;
        /**
          * Action label of the inline-notification.
         */
        "actionLabel"?: string;
        /**
          * Disables the action button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "actionLoading"?: boolean;
        /**
          * Description of the inline-notification.
         */
        "description"?: string;
        /**
          * If false, the inline-notification will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the inline-notification.
         */
        "heading"?: string;
        /**
          * Emitted when the action button is clicked.
         */
        "onAction"?: (event: PInlineNotificationCustomEvent<void>) => void;
        /**
          * Emitted when the close button is clicked.
         */
        "onDismiss"?: (event: PInlineNotificationCustomEvent<void>) => void;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `dismissButton` instead. Defines if the inline-notification can be closed/removed by the user.
         */
        "persistent"?: boolean;
        /**
          * State of the inline-notification.
         */
        "state"?: InlineNotificationState;
        /**
          * Adapts the inline-notification color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PLink {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: LinkIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTarget;
        /**
          * Adapts the link color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The style variant of the link.
         */
        "variant"?: LinkVariant;
    }
    interface PLinkPure {
        /**
          * Display link in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<LinkPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkPureAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed
         */
        "icon"?: LinkPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Size of the link.
         */
        "size"?: BreakpointCustomizable<LinkPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkPureTarget;
        /**
          * Adapts the button color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Shows an underline under the label.
         */
        "underline"?: boolean;
        /**
          * The weight of the text (only has effect with visible label).
          * @deprecated since v3.0.0, will be removed with next major release
         */
        "weight"?: LinkPureWeight;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Use `p-link` with corresponding social icon instead.
     */
    interface PLinkSocial {
        /**
          * Show or hide label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown.
         */
        "icon"?: LinkSocialIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkSocialTarget;
        /**
          * Adapts the link color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PLinkTile {
        /**
          * Alignment of link and description.
         */
        "align"?: LinkTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkTileAriaAttribute>;
        /**
          * Aspect ratio of the link-tile.
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileAspectRatio>;
        /**
          * Displays the link-tile as compact version with description and link icon only.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description"?: string;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show gradient.
         */
        "gradient"?: boolean;
        /**
          * href of the `<a>`.
         */
        "href"?: string;
        /**
          * Label of the <a />.
         */
        "label"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Font size of the description.
         */
        "size"?: BreakpointCustomizable<LinkTileSize>;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTileTarget;
        /**
          * Font weight of the description.
         */
        "weight"?: BreakpointCustomizable<LinkTileWeight>;
    }
    interface PLinkTileModelSignature {
        /**
          * Aspect ratio of the link-tile-model-signature.
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileModelSignatureAspectRatio>;
        /**
          * Description text.
         */
        "description"?: string;
        /**
          * Heading text.
         */
        "heading"?: string;
        /**
          * Sets a custom headline tag which wraps the heading to enhance semantics.
         */
        "headingTag"?: LinkTileModelSignatureHeadingTag;
        /**
          * Defines the direction of the main and cross axis of the links. The default is '{base: ‘column’, xs: ‘row’}' showing buttons vertically stacked on mobile viewports and side-by-side in a horizontal row from breakpoint 'xs'.
         */
        "linkDirection"?: BreakpointCustomizable<LinkTileModelSignatureLinkDirection>;
        /**
          * Adapts the model of the component.
         */
        "model"?: LinkTileModelSignatureModel;
        /**
          * Adapts the font weight of the heading.
         */
        "weight"?: BreakpointCustomizable<LinkTileModelSignatureWeight>;
    }
    /**
     * @deprecated since v3.0.0, will be removed with next major release. Please use "p-wordmark" instead.
     */
    interface PMarque {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<MarqueAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Adapts sizing of marque.
         */
        "size"?: MarqueSize;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: MarqueTarget;
        /**
          * Show/hide trademark sign (only has effect when variant is set to default).
         */
        "trademark"?: boolean;
        /**
          * Shows marque in special editions
         */
        "variant"?: MarqueVariant;
    }
    interface PModal {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ModalAriaAttribute>;
        /**
          * If true, the modal will not be closable via backdrop click.
         */
        "disableBackdropClick"?: boolean;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `dismissButton` instead. If true, the modal will not have a dismiss button.
         */
        "disableCloseButton"?: boolean;
        /**
          * If false, the modal will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * If true the modal uses max viewport height and width. Should only be used for mobile.
         */
        "fullscreen"?: BreakpointCustomizable<boolean>;
        /**
          * The title of the modal
         */
        "heading"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `dismiss` event instead. Emitted when the component requests to be dismissed.
         */
        "onClose"?: (event: PModalCustomEvent<void>) => void;
        /**
          * Emitted when the component requests to be dismissed.
         */
        "onDismiss"?: (event: PModalCustomEvent<void>) => void;
        /**
          * If true, the modal is open.
         */
        "open"?: boolean;
    }
    interface PModelSignature {
        /**
          * Adapts the color of the component.
         */
        "color"?: ModelSignatureColor;
        /**
          * Adapts the model of the component.
         */
        "model"?: ModelSignatureModel;
        /**
          * Adapts the size of the component.
         */
        "size"?: ModelSignatureSize;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    interface PPagination {
        /**
          * Index of the currently active page.
         */
        "activePage"?: number;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.root` instead. Aria label what the pagination is used for.
         */
        "allyLabel"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.next` instead. Aria label for next page icon.
         */
        "allyLabelNext"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.page` instead. Aria label for page navigation.
         */
        "allyLabelPage"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `intl.prev` instead. Aria label for previous page icon.
         */
        "allyLabelPrev"?: string;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev and page buttons.
         */
        "intl"?: PaginationInternationalization;
        /**
          * The total count of items which should be shown per page.
         */
        "itemsPerPage"?: number;
        /**
          * The maximum number of page links rendered
         */
        "maxNumberOfPageLinks"?: BreakpointCustomizable<PaginationMaxNumberOfPageLinks>;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when the page changes.
         */
        "onPageChange"?: (event: PPaginationCustomEvent<PaginationUpdateEvent>) => void;
        /**
          * Emitted when the page changes.
         */
        "onUpdate"?: (event: PPaginationCustomEvent<PaginationUpdateEvent>) => void;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The total count of items.
         */
        "totalItemsCount"?: number;
    }
    interface PPopover {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<PopoverAriaAttribute>;
        /**
          * Descriptive text to show additional information when popover is open
         */
        "description"?: string;
        /**
          * Preferred direction in which popover should open, given there is enough space in viewport. Otherwise, it will be opened in the direction with most available space.
         */
        "direction"?: PopoverDirection;
        /**
          * Adapts the popover color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PRadioButtonWrapper {
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The validation state.
         */
        "state"?: RadioButtonWrapperState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PScroller {
        /**
          * Sets the vertical position of scroll indicator.
         */
        "alignScrollIndicator"?: ScrollerAlignScrollIndicator;
        /**
          * Add ARIA role.
         */
        "aria"?: SelectedAriaAttributes<ScrollerAriaAttribute>;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColor"?: ScrollerGradientColor;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `gradientColor` instead. Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: ScrollerGradientColorScheme;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `alignScrollIndicator` instead. Sets the vertical position of scroll indicator
         */
        "scrollIndicatorPosition"?: ScrollerScrollIndicatorPosition;
        /**
          * Scrolls the scroll area to the left either smooth or immediately.
         */
        "scrollToPosition"?: ScrollerScrollToPosition;
        /**
          * Specifies if scrollbar should be shown.
         */
        "scrollbar"?: boolean;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PSegmentedControl {
        /**
          * @deprecated since v3.0.0, will be removed with next major release. Background color variations
         */
        "backgroundColor"?: SegmentedControlBackgroundColor;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when selected element changes.
         */
        "onSegmentedControlChange"?: (event: PSegmentedControlCustomEvent<SegmentedControlUpdateEvent>) => void;
        /**
          * Emitted when selected element changes.
         */
        "onUpdate"?: (event: PSegmentedControlCustomEvent<SegmentedControlUpdateEvent>) => void;
        /**
          * Adapts the segmented-control color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * Sets the initial value of the segmented-control.
         */
        "value"?: string | number;
    }
    interface PSegmentedControlItem {
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The icon shown.
         */
        "icon"?: SegmentedControlItemIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The value of this item which is emitted by the parent element if it becomes selected. This property is **required**.
         */
        "value"?: string | number;
    }
    interface PSelectWrapper {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Changes the direction to which the dropdown list appears.
         */
        "dropdownDirection"?: SelectWrapperDropdownDirection;
        /**
          * Filters select options by typing a character
         */
        "filter"?: boolean;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Forces rendering of native browser select dropdown
         */
        "native"?: boolean;
        /**
          * The validation state.
         */
        "state"?: SelectWrapperState;
        /**
          * Adapts the select color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PSelectWrapperDropdown {
        "description"?: string;
        "direction"?: SelectWrapperDropdownDirection;
        "disabled"?: boolean;
        "filter"?: boolean;
        "isOpenOverride"?: boolean;
        "label"?: string;
        "message"?: string;
        "onOpenChange"?: (isOpen: boolean) => void;
        "required"?: boolean;
        "selectRef"?: HTMLSelectElement;
        "state"?: SelectWrapperState;
        "theme"?: Theme;
    }
    interface PSpinner {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SpinnerAriaAttribute>;
        /**
          * Size of the spinner.
         */
        "size"?: BreakpointCustomizable<SpinnerSize>;
        /**
          * Adapts the spinner color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PStepperHorizontal {
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when active step is changed.
         */
        "onStepChange"?: (event: PStepperHorizontalCustomEvent<StepperHorizontalUpdateEvent>) => void;
        /**
          * Emitted when active step is changed.
         */
        "onUpdate"?: (event: PStepperHorizontalCustomEvent<StepperHorizontalUpdateEvent>) => void;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<StepperHorizontalSize>;
        /**
          * Adapts the tag color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PStepperHorizontalItem {
        /**
          * Disables the stepper-horizontal-item. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The validation state.
         */
        "state"?: StepperHorizontalItemState;
    }
    interface PSwitch {
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<SwitchAlignLabel>;
        /**
          * Visualize the switch with on/off status.
         */
        "checked"?: boolean;
        /**
          * Disables the switch. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Disables the switch and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when checked status is changed.
         */
        "onSwitchChange"?: (event: PSwitchCustomEvent<SwitchUpdateEvent>) => void;
        /**
          * Emitted when checked status is changed.
         */
        "onUpdate"?: (event: PSwitchCustomEvent<SwitchUpdateEvent>) => void;
        /**
          * Stretches the contents to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Adapts the switch color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PTable {
        /**
          * A caption describing the contents of the table for accessibility only. This won't be visible in the browser. Use an element with an attribute of `slot="caption"` for a visible caption.
         */
        "caption"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when sorting is changed.
         */
        "onSortingChange"?: (event: PTableCustomEvent<TableUpdateEvent>) => void;
        /**
          * Emitted when sorting is changed.
         */
        "onUpdate"?: (event: PTableCustomEvent<TableUpdateEvent>) => void;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PTableBody {
    }
    interface PTableCell {
        /**
          * Displays slotted text multiline or forced into a single line.
         */
        "multiline"?: boolean;
    }
    interface PTableHead {
    }
    interface PTableHeadCell {
        /**
          * Hides the label but stays accessible for screen readers. This property only takes effect when sort property is not defined.
         */
        "hideLabel"?: boolean;
        /**
          * Displays slotted text multiline or forced into a single line.
         */
        "multiline"?: boolean;
        /**
          * Defines sortability properties.
         */
        "sort"?: TableHeadCellSort;
    }
    interface PTableHeadRow {
    }
    interface PTableRow {
    }
    interface PTabs {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering).
         */
        "activeTabIndex"?: number;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColor"?: TabsGradientColor;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `gradientColor` instead. Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: TabsGradientColorScheme;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when active tab is changed.
         */
        "onTabChange"?: (event: PTabsCustomEvent<TabsUpdateEvent>) => void;
        /**
          * Emitted when active tab is changed.
         */
        "onUpdate"?: (event: PTabsCustomEvent<TabsUpdateEvent>) => void;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabsSize>;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The text weight.
         */
        "weight"?: TabsWeight;
    }
    interface PTabsBar {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering), undefined if none should be selected.
         */
        "activeTabIndex"?: number | undefined;
        /**
          * Adapts the background gradient color of prev and next button.
         */
        "gradientColor"?: TabsBarGradientColor;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `gradientColor` instead. Adapts the background gradient color of prev and next button.
         */
        "gradientColorScheme"?: TabsBarGradientColorScheme;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `update` event instead. Emitted when active tab is changed.
         */
        "onTabChange"?: (event: PTabsBarCustomEvent<TabsBarUpdateEvent>) => void;
        /**
          * Emitted when active tab is changed.
         */
        "onUpdate"?: (event: PTabsBarCustomEvent<TabsBarUpdateEvent>) => void;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabsBarSize>;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
        /**
          * The text weight.
         */
        "weight"?: TabsBarWeight;
    }
    interface PTabsItem {
        /**
          * Defines the label used in tabs.
         */
        "label"?: string;
    }
    interface PTag {
        /**
          * Background color variations depending on theme property.
         */
        "color"?: TagColor;
        /**
          * The icon shown.
         */
        "icon"?: TagIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Adapts the tag color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PTagDismissible {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<TagDismissibleAriaAttribute>;
        /**
          * Background color variations
         */
        "color"?: TagDismissibleColor;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * Adapts the color when used on dark background.
         */
        "theme"?: Theme;
    }
    interface PText {
        /**
          * Text alignment of the component.
         */
        "align"?: TextAlign;
        /**
          * Basic text color variations depending on theme property.
         */
        "color"?: TextColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the text. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<TextSize>;
        /**
          * Sets a custom HTML tag depending on the usage of the text component.
         */
        "tag"?: TextTag;
        /**
          * Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop.
         */
        "theme"?: Theme;
        /**
          * The weight of the text.
         */
        "weight"?: TextWeight;
    }
    interface PTextFieldWrapper {
        /**
          * Action icon can be set to `locate` for `input type="search"` in order to display an action button.
         */
        "actionIcon"?: TextFieldWrapperActionIcon;
        /**
          * Disables the action button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "actionLoading"?: boolean;
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Show or hide label and description text. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Emitted when the action button is clicked.
         */
        "onAction"?: (event: PTextFieldWrapperCustomEvent<void>) => void;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `showCounter` instead. Show or hide max character count.
         */
        "showCharacterCount"?: boolean;
        /**
          * Show or hide max character count.
         */
        "showCounter"?: boolean;
        /**
          * __Experimental__: Show or hide password toggle for `input type="password"`.
         */
        "showPasswordToggle"?: boolean;
        /**
          * The validation state.
         */
        "state"?: TextFieldWrapperState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * The unit text.
         */
        "unit"?: string;
        /**
          * The unit position.
         */
        "unitPosition"?: TextFieldWrapperUnitPosition;
    }
    interface PTextList {
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `type` instead. The type of the list.
         */
        "listType"?: TextListListType;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `type` instead. The list style type of ordered list. Only has effect when list type is set to 'ordered'.
         */
        "orderType"?: TextListOrderType;
        /**
          * Adapts the text color depending on the theme.
         */
        "theme"?: Theme;
        /**
          * The list style type.
         */
        "type"?: TextListType;
    }
    interface PTextListItem {
    }
    interface PTextareaWrapper {
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * @deprecated since v3.0.0, will be removed with next major release, use `showCounter` instead. Show or hide max character count.
         */
        "showCharacterCount"?: boolean;
        /**
          * Show or hide max character count.
         */
        "showCounter"?: boolean;
        /**
          * The validation state.
         */
        "state"?: TextareaWrapperState;
        /**
          * Adapts the color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PToast {
        /**
          * Adapts the toast color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PToastItem {
        /**
          * Emitted when the close button is clicked.
         */
        "onDismiss"?: (event: PToastItemCustomEvent<void>) => void;
        /**
          * State of the toast-item.
         */
        "state"?: ToastState;
        /**
          * Text of the toast-item.
         */
        "text"?: string;
        /**
          * Adapts the toast-item color depending on the theme.
         */
        "theme"?: Theme;
    }
    interface PWordmark {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<WordmarkAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Adapts sizing of wordmark.
         */
        "size"?: WordmarkSize;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: WordmarkTarget;
        /**
          * Adapts color depending on theme.
         */
        "theme"?: Theme;
    }
    interface IntrinsicElements {
        "p-accordion": PAccordion;
        "p-banner": PBanner;
        "p-button": PButton;
        "p-button-group": PButtonGroup;
        "p-button-pure": PButtonPure;
        "p-button-tile": PButtonTile;
        "p-carousel": PCarousel;
        "p-checkbox-wrapper": PCheckboxWrapper;
        "p-content-wrapper": PContentWrapper;
        "p-crest": PCrest;
        "p-display": PDisplay;
        "p-divider": PDivider;
        "p-fieldset": PFieldset;
        "p-fieldset-wrapper": PFieldsetWrapper;
        "p-flex": PFlex;
        "p-flex-item": PFlexItem;
        "p-flyout": PFlyout;
        "p-grid": PGrid;
        "p-grid-item": PGridItem;
        "p-heading": PHeading;
        "p-headline": PHeadline;
        "p-icon": PIcon;
        "p-inline-notification": PInlineNotification;
        "p-link": PLink;
        "p-link-pure": PLinkPure;
        "p-link-social": PLinkSocial;
        "p-link-tile": PLinkTile;
        "p-link-tile-model-signature": PLinkTileModelSignature;
        "p-marque": PMarque;
        "p-modal": PModal;
        "p-model-signature": PModelSignature;
        "p-pagination": PPagination;
        "p-popover": PPopover;
        "p-radio-button-wrapper": PRadioButtonWrapper;
        "p-scroller": PScroller;
        "p-segmented-control": PSegmentedControl;
        "p-segmented-control-item": PSegmentedControlItem;
        "p-select-wrapper": PSelectWrapper;
        "p-select-wrapper-dropdown": PSelectWrapperDropdown;
        "p-spinner": PSpinner;
        "p-stepper-horizontal": PStepperHorizontal;
        "p-stepper-horizontal-item": PStepperHorizontalItem;
        "p-switch": PSwitch;
        "p-table": PTable;
        "p-table-body": PTableBody;
        "p-table-cell": PTableCell;
        "p-table-head": PTableHead;
        "p-table-head-cell": PTableHeadCell;
        "p-table-head-row": PTableHeadRow;
        "p-table-row": PTableRow;
        "p-tabs": PTabs;
        "p-tabs-bar": PTabsBar;
        "p-tabs-item": PTabsItem;
        "p-tag": PTag;
        "p-tag-dismissible": PTagDismissible;
        "p-text": PText;
        "p-text-field-wrapper": PTextFieldWrapper;
        "p-text-list": PTextList;
        "p-text-list-item": PTextListItem;
        "p-textarea-wrapper": PTextareaWrapper;
        "p-toast": PToast;
        "p-toast-item": PToastItem;
        "p-wordmark": PWordmark;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "p-accordion": LocalJSX.PAccordion & JSXBase.HTMLAttributes<HTMLPAccordionElement>;
            "p-banner": LocalJSX.PBanner & JSXBase.HTMLAttributes<HTMLPBannerElement>;
            "p-button": LocalJSX.PButton & JSXBase.HTMLAttributes<HTMLPButtonElement>;
            "p-button-group": LocalJSX.PButtonGroup & JSXBase.HTMLAttributes<HTMLPButtonGroupElement>;
            "p-button-pure": LocalJSX.PButtonPure & JSXBase.HTMLAttributes<HTMLPButtonPureElement>;
            "p-button-tile": LocalJSX.PButtonTile & JSXBase.HTMLAttributes<HTMLPButtonTileElement>;
            "p-carousel": LocalJSX.PCarousel & JSXBase.HTMLAttributes<HTMLPCarouselElement>;
            "p-checkbox-wrapper": LocalJSX.PCheckboxWrapper & JSXBase.HTMLAttributes<HTMLPCheckboxWrapperElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
             */
            "p-content-wrapper": LocalJSX.PContentWrapper & JSXBase.HTMLAttributes<HTMLPContentWrapperElement>;
            "p-crest": LocalJSX.PCrest & JSXBase.HTMLAttributes<HTMLPCrestElement>;
            "p-display": LocalJSX.PDisplay & JSXBase.HTMLAttributes<HTMLPDisplayElement>;
            "p-divider": LocalJSX.PDivider & JSXBase.HTMLAttributes<HTMLPDividerElement>;
            "p-fieldset": LocalJSX.PFieldset & JSXBase.HTMLAttributes<HTMLPFieldsetElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Please use "p-fieldset" instead.
             */
            "p-fieldset-wrapper": LocalJSX.PFieldsetWrapper & JSXBase.HTMLAttributes<HTMLPFieldsetWrapperElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
             */
            "p-flex": LocalJSX.PFlex & JSXBase.HTMLAttributes<HTMLPFlexElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Flex instead.
             */
            "p-flex-item": LocalJSX.PFlexItem & JSXBase.HTMLAttributes<HTMLPFlexItemElement>;
            "p-flyout": LocalJSX.PFlyout & JSXBase.HTMLAttributes<HTMLPFlyoutElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
             */
            "p-grid": LocalJSX.PGrid & JSXBase.HTMLAttributes<HTMLPGridElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Use native CSS Grid instead.
             */
            "p-grid-item": LocalJSX.PGridItem & JSXBase.HTMLAttributes<HTMLPGridItemElement>;
            "p-heading": LocalJSX.PHeading & JSXBase.HTMLAttributes<HTMLPHeadingElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Please use "p-heading" instead.
             */
            "p-headline": LocalJSX.PHeadline & JSXBase.HTMLAttributes<HTMLPHeadlineElement>;
            "p-icon": LocalJSX.PIcon & JSXBase.HTMLAttributes<HTMLPIconElement>;
            "p-inline-notification": LocalJSX.PInlineNotification & JSXBase.HTMLAttributes<HTMLPInlineNotificationElement>;
            "p-link": LocalJSX.PLink & JSXBase.HTMLAttributes<HTMLPLinkElement>;
            "p-link-pure": LocalJSX.PLinkPure & JSXBase.HTMLAttributes<HTMLPLinkPureElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Use `p-link` with corresponding social icon instead.
             */
            "p-link-social": LocalJSX.PLinkSocial & JSXBase.HTMLAttributes<HTMLPLinkSocialElement>;
            "p-link-tile": LocalJSX.PLinkTile & JSXBase.HTMLAttributes<HTMLPLinkTileElement>;
            "p-link-tile-model-signature": LocalJSX.PLinkTileModelSignature & JSXBase.HTMLAttributes<HTMLPLinkTileModelSignatureElement>;
            /**
             * @deprecated since v3.0.0, will be removed with next major release. Please use "p-wordmark" instead.
             */
            "p-marque": LocalJSX.PMarque & JSXBase.HTMLAttributes<HTMLPMarqueElement>;
            "p-modal": LocalJSX.PModal & JSXBase.HTMLAttributes<HTMLPModalElement>;
            "p-model-signature": LocalJSX.PModelSignature & JSXBase.HTMLAttributes<HTMLPModelSignatureElement>;
            "p-pagination": LocalJSX.PPagination & JSXBase.HTMLAttributes<HTMLPPaginationElement>;
            "p-popover": LocalJSX.PPopover & JSXBase.HTMLAttributes<HTMLPPopoverElement>;
            "p-radio-button-wrapper": LocalJSX.PRadioButtonWrapper & JSXBase.HTMLAttributes<HTMLPRadioButtonWrapperElement>;
            "p-scroller": LocalJSX.PScroller & JSXBase.HTMLAttributes<HTMLPScrollerElement>;
            "p-segmented-control": LocalJSX.PSegmentedControl & JSXBase.HTMLAttributes<HTMLPSegmentedControlElement>;
            "p-segmented-control-item": LocalJSX.PSegmentedControlItem & JSXBase.HTMLAttributes<HTMLPSegmentedControlItemElement>;
            "p-select-wrapper": LocalJSX.PSelectWrapper & JSXBase.HTMLAttributes<HTMLPSelectWrapperElement>;
            "p-select-wrapper-dropdown": LocalJSX.PSelectWrapperDropdown & JSXBase.HTMLAttributes<HTMLPSelectWrapperDropdownElement>;
            "p-spinner": LocalJSX.PSpinner & JSXBase.HTMLAttributes<HTMLPSpinnerElement>;
            "p-stepper-horizontal": LocalJSX.PStepperHorizontal & JSXBase.HTMLAttributes<HTMLPStepperHorizontalElement>;
            "p-stepper-horizontal-item": LocalJSX.PStepperHorizontalItem & JSXBase.HTMLAttributes<HTMLPStepperHorizontalItemElement>;
            "p-switch": LocalJSX.PSwitch & JSXBase.HTMLAttributes<HTMLPSwitchElement>;
            "p-table": LocalJSX.PTable & JSXBase.HTMLAttributes<HTMLPTableElement>;
            "p-table-body": LocalJSX.PTableBody & JSXBase.HTMLAttributes<HTMLPTableBodyElement>;
            "p-table-cell": LocalJSX.PTableCell & JSXBase.HTMLAttributes<HTMLPTableCellElement>;
            "p-table-head": LocalJSX.PTableHead & JSXBase.HTMLAttributes<HTMLPTableHeadElement>;
            "p-table-head-cell": LocalJSX.PTableHeadCell & JSXBase.HTMLAttributes<HTMLPTableHeadCellElement>;
            "p-table-head-row": LocalJSX.PTableHeadRow & JSXBase.HTMLAttributes<HTMLPTableHeadRowElement>;
            "p-table-row": LocalJSX.PTableRow & JSXBase.HTMLAttributes<HTMLPTableRowElement>;
            "p-tabs": LocalJSX.PTabs & JSXBase.HTMLAttributes<HTMLPTabsElement>;
            "p-tabs-bar": LocalJSX.PTabsBar & JSXBase.HTMLAttributes<HTMLPTabsBarElement>;
            "p-tabs-item": LocalJSX.PTabsItem & JSXBase.HTMLAttributes<HTMLPTabsItemElement>;
            "p-tag": LocalJSX.PTag & JSXBase.HTMLAttributes<HTMLPTagElement>;
            "p-tag-dismissible": LocalJSX.PTagDismissible & JSXBase.HTMLAttributes<HTMLPTagDismissibleElement>;
            "p-text": LocalJSX.PText & JSXBase.HTMLAttributes<HTMLPTextElement>;
            "p-text-field-wrapper": LocalJSX.PTextFieldWrapper & JSXBase.HTMLAttributes<HTMLPTextFieldWrapperElement>;
            "p-text-list": LocalJSX.PTextList & JSXBase.HTMLAttributes<HTMLPTextListElement>;
            "p-text-list-item": LocalJSX.PTextListItem & JSXBase.HTMLAttributes<HTMLPTextListItemElement>;
            "p-textarea-wrapper": LocalJSX.PTextareaWrapper & JSXBase.HTMLAttributes<HTMLPTextareaWrapperElement>;
            "p-toast": LocalJSX.PToast & JSXBase.HTMLAttributes<HTMLPToastElement>;
            "p-toast-item": LocalJSX.PToastItem & JSXBase.HTMLAttributes<HTMLPToastItemElement>;
            "p-wordmark": LocalJSX.PWordmark & JSXBase.HTMLAttributes<HTMLPWordmarkElement>;
        }
    }
}
