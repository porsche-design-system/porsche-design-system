/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { AccordionAlignIcon, AccordionBackground, AccordionUpdateEventDetail } from "./components/accordion/accordion-utils";
import { BannerHeadingTag, BannerState } from "./components/banner/banner-utils";
import { BreakpointCustomizable, ButtonAriaAttribute, ButtonType, ButtonVariant, FlagName, HeadingSize, HeadingTag, IconName, LinkAriaAttribute, LinkTarget, LinkVariant, SelectedAriaAttributes, SelectedAriaRole, TextSize } from "./types";
import { ButtonIcon } from "./components/button/button-utils";
import { ButtonPureAlignLabel, ButtonPureAriaAttribute, ButtonPureIcon, ButtonPureSize, ButtonPureType } from "./components/button-pure/button-pure-utils";
import { ButtonTileAlign, ButtonTileAriaAttribute, ButtonTileAspectRatio, ButtonTileIcon, ButtonTileSize, ButtonTileType, ButtonTileWeight } from "./components/button-tile/button-tile-utils";
import { CanvasBackground, CanvasSidebarStartUpdateEventDetail } from "./components/canvas/canvas-utils";
import { CarouselAlignControls, CarouselAlignHeader, CarouselAriaAttribute, CarouselHeadingSize, CarouselInternationalization, CarouselSlidesPerPage, CarouselUpdateEventDetail, CarouselWidth } from "./components/carousel/carousel-utils";
import { CheckboxBlurEventDetail, CheckboxChangeEventDetail, CheckboxState } from "./components/checkbox/checkbox-utils";
import { CrestAriaAttribute, CrestTarget } from "./components/crest/crest-utils";
import { DisplayAlign, DisplayColor, DisplaySize, DisplayTag } from "./components/display/display-utils";
import { DividerColor, DividerDirection } from "./components/divider/divider-utils";
import { DrilldownAriaAttribute, DrilldownUpdateEventDetail } from "./components/drilldown/drilldown/drilldown-utils";
import { DrilldownLinkAriaAttribute, DrilldownLinkTarget } from "./components/drilldown/drilldown-link/drilldown-link-utils";
import { FieldsetLabelSize, FieldsetState } from "./components/fieldset/fieldset-utils";
import { FlagAriaAttribute, FlagSize } from "./components/flag/flag-utils";
import { FlyoutAriaAttribute, FlyoutBackdrop, FlyoutBackground, FlyoutFooterBehavior, FlyoutMotionHiddenEndEventDetail, FlyoutMotionVisibleEndEventDetail, FlyoutPosition } from "./components/flyout/flyout-utils";
import { HeadingAlign, HeadingColor } from "./components/heading/heading-utils";
import { IconAriaAttribute, IconColor, IconSize } from "./components/icon/icon-utils";
import { InlineNotificationActionIcon, InlineNotificationHeadingTag, InlineNotificationState } from "./components/inline-notification/inline-notification-utils";
import { InputDateBlurEventDetail, InputDateChangeEventDetail, InputDateInputEventDetail, InputDateState } from "./components/input-date/input-date-utils";
import { InputEmailBlurEventDetail, InputEmailChangeEventDetail, InputEmailInputEventDetail, InputEmailState } from "./components/input-email/input-email-utils";
import { InputMonthBlurEventDetail, InputMonthChangeEventDetail, InputMonthInputEventDetail, InputMonthState } from "./components/input-month/input-month-utils";
import { InputNumberBlurEventDetail, InputNumberChangeEventDetail, InputNumberInputEventDetail, InputNumberState } from "./components/input-number/input-number-utils";
import { InputPasswordBlurEventDetail, InputPasswordChangeEventDetail, InputPasswordInputEventDetail, InputPasswordState } from "./components/input-password/input-password-utils";
import { InputSearchBlurEventDetail, InputSearchChangeEventDetail, InputSearchInputEventDetail, InputSearchState } from "./components/input-search/input-search-utils";
import { InputTelBlurEventDetail, InputTelChangeEventDetail, InputTelInputEventDetail, InputTelState } from "./components/input-tel/input-tel-utils";
import { InputTextBlurEventDetail, InputTextChangeEventDetail, InputTextInputEventDetail, InputTextState } from "./components/input-text/input-text-utils";
import { InputTimeBlurEventDetail, InputTimeChangeEventDetail, InputTimeInputEventDetail, InputTimeState } from "./components/input-time/input-time-utils";
import { InputUrlBlurEventDetail, InputUrlChangeEventDetail, InputUrlInputEventDetail, InputUrlState } from "./components/input-url/input-url-utils";
import { InputWeekBlurEventDetail, InputWeekChangeEventDetail, InputWeekInputEventDetail, InputWeekState } from "./components/input-week/input-week-utils";
import { LinkIcon } from "./components/link/link-utils";
import { LinkPureAlignLabel, LinkPureAriaAttribute, LinkPureIcon, LinkPureSize, LinkPureTarget } from "./components/link-pure/link-pure-utils";
import { LinkTileAlign, LinkTileAriaAttribute, LinkTileAspectRatio, LinkTileSize, LinkTileTarget, LinkTileWeight } from "./components/link-tile/link-tile-utils";
import { LinkTileProductAspectRatio, LinkTileProductLikeEventDetail, LinkTileProductTarget } from "./components/link-tile-product/link-tile-product-utils";
import { ModalAriaAttribute, ModalBackdrop, ModalBackground, ModalMotionHiddenEndEventDetail, ModalMotionVisibleEndEventDetail } from "./components/modal/modal-utils";
import { ModelSignatureColor, ModelSignatureFetchPriority, ModelSignatureModel, ModelSignatureSize } from "./components/model-signature/model-signature-utils";
import { MultiSelectChangeEventDetail, MultiSelectDropdownDirection, MultiSelectState, MultiSelectToggleEventDetail } from "./components/multi-select/multi-select/multi-select-utils";
import { PaginationInternationalization, PaginationUpdateEventDetail } from "./components/pagination/pagination-utils";
import { PinCodeChangeEventDetail, PinCodeLength, PinCodeState, PinCodeType } from "./components/pin-code/pin-code-utils";
import { PopoverAriaAttribute, PopoverDirection } from "./components/popover/popover-utils";
import { RadioGroupChangeEventDetail, RadioGroupDirection, RadioGroupState } from "./components/radio-group/radio-group/radio-group-utils";
import { ScrollerAlignScrollIndicator, ScrollerAriaAttribute, ScrollerScrollToPosition } from "./components/scroller/scroller-utils";
import { SegmentedControlChangeEventDetail, SegmentedControlColumns, SegmentedControlState } from "./components/segmented-control/segmented-control/segmented-control-utils";
import { SegmentedControlItemAriaAttribute, SegmentedControlItemIcon } from "./components/segmented-control/segmented-control-item/segmented-control-item-utils";
import { SelectChangeEventDetail, SelectDropdownDirection, SelectState, SelectToggleEventDetail } from "./components/select/select/select-utils";
import { SheetAriaAttribute, SheetBackground, SheetMotionHiddenEndEventDetail, SheetMotionVisibleEndEventDetail } from "./components/sheet/sheet-utils";
import { SpinnerAriaAttribute, SpinnerSize } from "./components/spinner/spinner-utils";
import { StepperHorizontalSize, StepperHorizontalUpdateEventDetail } from "./components/stepper-horizontal/stepper-horizontal/stepper-horizontal-utils";
import { StepperHorizontalItemState } from "./components/stepper-horizontal/stepper-horizontal-item/stepper-horizontal-item-utils";
import { SwitchAlignLabel, SwitchUpdateEventDetail } from "./components/switch/switch-utils";
import { TableHeadCellSort, TableLayout, TableUpdateEventDetail } from "./components/table/table/table-utils";
import { TabsSize, TabsUpdateEventDetail, TabsWeight } from "./components/tabs/tabs/tabs-utils";
import { TabsBarSize, TabsBarUpdateEventDetail, TabsBarWeight } from "./components/tabs-bar/tabs-bar-utils";
import { TagIcon, TagVariant } from "./components/tag/tag-utils";
import { TagDismissibleAriaAttribute } from "./components/tag-dismissible/tag-dismissible-utils";
import { TextAlign, TextColor, TextTag, TextWeight } from "./components/text/text-utils";
import { TextListType } from "./components/text-list/text-list/text-list-utils";
import { TextareaBlurEventDetail, TextareaChangeEventDetail, TextareaInputEventDetail, TextareaResize, TextareaState, TextareaWrap } from "./components/textarea/textarea-utils";
import { ToastMessage } from "./components/toast/toast/toast-manager";
import { ToastState } from "./components/toast/toast/toast-utils";
import { WordmarkAriaAttribute, WordmarkSize, WordmarkTarget } from "./components/wordmark/wordmark-utils";
export { AccordionAlignIcon, AccordionBackground, AccordionUpdateEventDetail } from "./components/accordion/accordion-utils";
export { BannerHeadingTag, BannerState } from "./components/banner/banner-utils";
export { BreakpointCustomizable, ButtonAriaAttribute, ButtonType, ButtonVariant, FlagName, HeadingSize, HeadingTag, IconName, LinkAriaAttribute, LinkTarget, LinkVariant, SelectedAriaAttributes, SelectedAriaRole, TextSize } from "./types";
export { ButtonIcon } from "./components/button/button-utils";
export { ButtonPureAlignLabel, ButtonPureAriaAttribute, ButtonPureIcon, ButtonPureSize, ButtonPureType } from "./components/button-pure/button-pure-utils";
export { ButtonTileAlign, ButtonTileAriaAttribute, ButtonTileAspectRatio, ButtonTileIcon, ButtonTileSize, ButtonTileType, ButtonTileWeight } from "./components/button-tile/button-tile-utils";
export { CanvasBackground, CanvasSidebarStartUpdateEventDetail } from "./components/canvas/canvas-utils";
export { CarouselAlignControls, CarouselAlignHeader, CarouselAriaAttribute, CarouselHeadingSize, CarouselInternationalization, CarouselSlidesPerPage, CarouselUpdateEventDetail, CarouselWidth } from "./components/carousel/carousel-utils";
export { CheckboxBlurEventDetail, CheckboxChangeEventDetail, CheckboxState } from "./components/checkbox/checkbox-utils";
export { CrestAriaAttribute, CrestTarget } from "./components/crest/crest-utils";
export { DisplayAlign, DisplayColor, DisplaySize, DisplayTag } from "./components/display/display-utils";
export { DividerColor, DividerDirection } from "./components/divider/divider-utils";
export { DrilldownAriaAttribute, DrilldownUpdateEventDetail } from "./components/drilldown/drilldown/drilldown-utils";
export { DrilldownLinkAriaAttribute, DrilldownLinkTarget } from "./components/drilldown/drilldown-link/drilldown-link-utils";
export { FieldsetLabelSize, FieldsetState } from "./components/fieldset/fieldset-utils";
export { FlagAriaAttribute, FlagSize } from "./components/flag/flag-utils";
export { FlyoutAriaAttribute, FlyoutBackdrop, FlyoutBackground, FlyoutFooterBehavior, FlyoutMotionHiddenEndEventDetail, FlyoutMotionVisibleEndEventDetail, FlyoutPosition } from "./components/flyout/flyout-utils";
export { HeadingAlign, HeadingColor } from "./components/heading/heading-utils";
export { IconAriaAttribute, IconColor, IconSize } from "./components/icon/icon-utils";
export { InlineNotificationActionIcon, InlineNotificationHeadingTag, InlineNotificationState } from "./components/inline-notification/inline-notification-utils";
export { InputDateBlurEventDetail, InputDateChangeEventDetail, InputDateInputEventDetail, InputDateState } from "./components/input-date/input-date-utils";
export { InputEmailBlurEventDetail, InputEmailChangeEventDetail, InputEmailInputEventDetail, InputEmailState } from "./components/input-email/input-email-utils";
export { InputMonthBlurEventDetail, InputMonthChangeEventDetail, InputMonthInputEventDetail, InputMonthState } from "./components/input-month/input-month-utils";
export { InputNumberBlurEventDetail, InputNumberChangeEventDetail, InputNumberInputEventDetail, InputNumberState } from "./components/input-number/input-number-utils";
export { InputPasswordBlurEventDetail, InputPasswordChangeEventDetail, InputPasswordInputEventDetail, InputPasswordState } from "./components/input-password/input-password-utils";
export { InputSearchBlurEventDetail, InputSearchChangeEventDetail, InputSearchInputEventDetail, InputSearchState } from "./components/input-search/input-search-utils";
export { InputTelBlurEventDetail, InputTelChangeEventDetail, InputTelInputEventDetail, InputTelState } from "./components/input-tel/input-tel-utils";
export { InputTextBlurEventDetail, InputTextChangeEventDetail, InputTextInputEventDetail, InputTextState } from "./components/input-text/input-text-utils";
export { InputTimeBlurEventDetail, InputTimeChangeEventDetail, InputTimeInputEventDetail, InputTimeState } from "./components/input-time/input-time-utils";
export { InputUrlBlurEventDetail, InputUrlChangeEventDetail, InputUrlInputEventDetail, InputUrlState } from "./components/input-url/input-url-utils";
export { InputWeekBlurEventDetail, InputWeekChangeEventDetail, InputWeekInputEventDetail, InputWeekState } from "./components/input-week/input-week-utils";
export { LinkIcon } from "./components/link/link-utils";
export { LinkPureAlignLabel, LinkPureAriaAttribute, LinkPureIcon, LinkPureSize, LinkPureTarget } from "./components/link-pure/link-pure-utils";
export { LinkTileAlign, LinkTileAriaAttribute, LinkTileAspectRatio, LinkTileSize, LinkTileTarget, LinkTileWeight } from "./components/link-tile/link-tile-utils";
export { LinkTileProductAspectRatio, LinkTileProductLikeEventDetail, LinkTileProductTarget } from "./components/link-tile-product/link-tile-product-utils";
export { ModalAriaAttribute, ModalBackdrop, ModalBackground, ModalMotionHiddenEndEventDetail, ModalMotionVisibleEndEventDetail } from "./components/modal/modal-utils";
export { ModelSignatureColor, ModelSignatureFetchPriority, ModelSignatureModel, ModelSignatureSize } from "./components/model-signature/model-signature-utils";
export { MultiSelectChangeEventDetail, MultiSelectDropdownDirection, MultiSelectState, MultiSelectToggleEventDetail } from "./components/multi-select/multi-select/multi-select-utils";
export { PaginationInternationalization, PaginationUpdateEventDetail } from "./components/pagination/pagination-utils";
export { PinCodeChangeEventDetail, PinCodeLength, PinCodeState, PinCodeType } from "./components/pin-code/pin-code-utils";
export { PopoverAriaAttribute, PopoverDirection } from "./components/popover/popover-utils";
export { RadioGroupChangeEventDetail, RadioGroupDirection, RadioGroupState } from "./components/radio-group/radio-group/radio-group-utils";
export { ScrollerAlignScrollIndicator, ScrollerAriaAttribute, ScrollerScrollToPosition } from "./components/scroller/scroller-utils";
export { SegmentedControlChangeEventDetail, SegmentedControlColumns, SegmentedControlState } from "./components/segmented-control/segmented-control/segmented-control-utils";
export { SegmentedControlItemAriaAttribute, SegmentedControlItemIcon } from "./components/segmented-control/segmented-control-item/segmented-control-item-utils";
export { SelectChangeEventDetail, SelectDropdownDirection, SelectState, SelectToggleEventDetail } from "./components/select/select/select-utils";
export { SheetAriaAttribute, SheetBackground, SheetMotionHiddenEndEventDetail, SheetMotionVisibleEndEventDetail } from "./components/sheet/sheet-utils";
export { SpinnerAriaAttribute, SpinnerSize } from "./components/spinner/spinner-utils";
export { StepperHorizontalSize, StepperHorizontalUpdateEventDetail } from "./components/stepper-horizontal/stepper-horizontal/stepper-horizontal-utils";
export { StepperHorizontalItemState } from "./components/stepper-horizontal/stepper-horizontal-item/stepper-horizontal-item-utils";
export { SwitchAlignLabel, SwitchUpdateEventDetail } from "./components/switch/switch-utils";
export { TableHeadCellSort, TableLayout, TableUpdateEventDetail } from "./components/table/table/table-utils";
export { TabsSize, TabsUpdateEventDetail, TabsWeight } from "./components/tabs/tabs/tabs-utils";
export { TabsBarSize, TabsBarUpdateEventDetail, TabsBarWeight } from "./components/tabs-bar/tabs-bar-utils";
export { TagIcon, TagVariant } from "./components/tag/tag-utils";
export { TagDismissibleAriaAttribute } from "./components/tag-dismissible/tag-dismissible-utils";
export { TextAlign, TextColor, TextTag, TextWeight } from "./components/text/text-utils";
export { TextListType } from "./components/text-list/text-list/text-list-utils";
export { TextareaBlurEventDetail, TextareaChangeEventDetail, TextareaInputEventDetail, TextareaResize, TextareaState, TextareaWrap } from "./components/textarea/textarea-utils";
export { ToastMessage } from "./components/toast/toast/toast-manager";
export { ToastState } from "./components/toast/toast/toast-utils";
export { WordmarkAriaAttribute, WordmarkSize, WordmarkTarget } from "./components/wordmark/wordmark-utils";
export namespace Components {
    /**
     * @controlled {"props": ["open"], "event": "update"}
     */
    interface PAccordion {
        /**
          * Aligns the icon within the summary section.
         */
        "alignIcon"?: AccordionAlignIcon;
        /**
          * Defines the background color
         */
        "background"?: AccordionBackground;
        /**
          * Displays the Accordion as compact version.
         */
        "compact"?: boolean;
        /**
          * Sets the open/closed state of the Accordion.
         */
        "open"?: boolean;
        /**
          * @experimental Sticks the Accordion heading at the top, fixed while scrolling
         */
        "sticky"?: boolean;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PBanner {
        /**
          * Description of the banner.
         */
        "description"?: string;
        /**
          * If false, the banner will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the banner.
         */
        "heading"?: string;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
         */
        "headingTag"?: BannerHeadingTag;
        /**
          * If true, the banner is open.
         */
        "open": boolean;
        /**
          * State of the banner.
         */
        "state"?: BannerState;
    }
    interface PButton {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonAriaAttribute>;
        /**
          * Displays as compact version.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the button should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: ButtonIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * The name of the button, submitted as a pair with the button's value as part of the form data, when that button is used to submit the form.
         */
        "name"?: string;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonType;
        /**
          * Defines the value associated with the button's name when it's submitted with the form data. This value is passed to the server in params when the form is submitted using this button.
         */
        "value"?: string;
        /**
          * The style variant of the button.
         */
        "variant"?: ButtonVariant;
    }
    interface PButtonPure {
        /**
          * Display button in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<ButtonPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonPureAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the button should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown.
         */
        "icon"?: ButtonPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * The name of the button, submitted as a pair with the button's value as part of the form data, when that button is used to submit the form.
         */
        "name"?: string;
        /**
          * Size of the button.
         */
        "size"?: BreakpointCustomizable<ButtonPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonPureType;
        /**
          * Shows an underline under the label.
         */
        "underline"?: boolean;
        /**
          * Defines the value associated with the button's name when it's submitted with the form data. This value is passed to the server in params when the form is submitted using this button.
         */
        "value"?: string;
    }
    interface PButtonTile {
        /**
          * Alignment of button and description.
         */
        "align"?: ButtonTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonTileAriaAttribute>;
        /**
          * Aspect ratio of the button-tile.
         */
        "aspectRatio"?: BreakpointCustomizable<ButtonTileAspectRatio>;
        /**
          * Displays the button-tile as compact version with description and button icon only.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description": string;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show gradient.
         */
        "gradient"?: boolean;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: ButtonTileIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Label of the button.
         */
        "label": string;
        /**
          * Disables the button-tile and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Font size of the description.
         */
        "size"?: BreakpointCustomizable<ButtonTileSize>;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonTileType;
        /**
          * Font weight of the description.
         */
        "weight"?: BreakpointCustomizable<ButtonTileWeight>;
    }
    /**
     * @experimental 
     */
    interface PCanvas {
        /**
          * Defines the background color of the main section and auto adjust it for the sidebar
         */
        "background"?: CanvasBackground;
        /**
          * Open the sidebar on the end side
         */
        "sidebarEndOpen"?: boolean;
        /**
          * Open the sidebar on the start side
         */
        "sidebarStartOpen"?: boolean;
    }
    /**
     * @controlled { "props": ["activeSlideIndex"], "event": "update", "isInternallyMutated": true }
     */
    interface PCarousel {
        /**
          * Defines which slide to be active (zero-based numbering).
         */
        "activeSlideIndex"?: number;
        /**
          * Alignment of slotted controls
         */
        "alignControls"?: CarouselAlignControls;
        /**
          * Alignment of heading and description
         */
        "alignHeader"?: CarouselAlignHeader;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<CarouselAriaAttribute>;
        /**
          * Defines the description used in the carousel.
         */
        "description"?: string;
        /**
          * Indicates whether focus should be set on the center slide. If true, the carousel loops by individual slide; otherwise, it loops by page.
         */
        "focusOnCenterSlide"?: boolean;
        /**
          * Fades the slides out.
         */
        "gradient"?: boolean;
        /**
          * Defines the heading used in the carousel.
         */
        "heading"?: string;
        /**
          * Defines the heading size used in the carousel.
         */
        "headingSize"?: CarouselHeadingSize;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev buttons and pagination.
         */
        "intl"?: CarouselInternationalization;
        /**
          * If false, the carousel will not show pagination bullets at the bottom.
         */
        "pagination"?: BreakpointCustomizable<boolean>;
        /**
          * Whether the slides should rewind from last to first slide and vice versa.
         */
        "rewind"?: boolean;
        /**
          * Defines target of skip link (to skip carousel entries).
         */
        "skipLinkTarget"?: string;
        /**
          * Sets the amount of slides visible at the same time. Can be set to `auto` if you want to define different widths per slide via CSS.
         */
        "slidesPerPage"?: BreakpointCustomizable<CarouselSlidesPerPage>;
        /**
          * Determines whether to trim spaces before/after the carousel if `focusOnCenterSlide` option is true.
         */
        "trimSpace"?: boolean;
        /**
          * Defines the outer spacings between the carousel and the left and right screen sides.
         */
        "width"?: CarouselWidth;
    }
    interface PCheckbox {
        /**
          * Reflects the checkbox current checked state and allows setting the initial checked state.
         */
        "checked"?: boolean;
        /**
          * Displays as a compact version.
         */
        "compact"?: boolean;
        /**
          * Marks the checkbox as disabled.
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the checkbox should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility, it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Marks the checkbox as indeterminate.
         */
        "indeterminate"?: boolean;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * @experimental Disables the checkbox and shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The name of the checkbox.
         */
        "name"?: string;
        /**
          * Marks the checkbox as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: CheckboxState;
        /**
          * The checkbox value. When a form is submitted, only a checkbox which is currently checked is included in the submission.
         */
        "value"?: string;
    }
    interface PCrest {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<CrestAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: CrestTarget;
    }
    interface PDisplay {
        /**
          * Text alignment of the component.
         */
        "align"?: DisplayAlign;
        /**
          * Basic text color variations.
         */
        "color"?: DisplayColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "medium", l: "large"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<DisplaySize>;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
         */
        "tag"?: DisplayTag;
    }
    interface PDivider {
        /**
          * Defines color.
         */
        "color"?: DividerColor;
        /**
          * Defines direction.
         */
        "direction"?: BreakpointCustomizable<DividerDirection>;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     * @controlled {"props": ["activeIdentifier"], "event": "update"}
     * @experimental 
     */
    interface PDrilldown {
        /**
          * Defines which drilldown-item to be visualized as opened.
         */
        "activeIdentifier"?: string | undefined;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<DrilldownAriaAttribute>;
        /**
          * If true, the drilldown is visualized as opened.
         */
        "open"?: boolean;
    }
    /**
     * @experimental 
     */
    interface PDrilldownItem {
        /**
          * Private property set by the component itself.
         */
        "cascade"?: boolean;
        /**
          * Unique identifier which controls if this item should be shown when the active-identifier on the drilldown is set to this value.
         */
        "identifier": string;
        /**
          * Renders back button, header section on mobile view and cascade button to reach a deeper level of the navigation structure.
         */
        "label"?: string;
        /**
          * Private property set by the component itself.
         */
        "primary"?: boolean;
        /**
          * Private property set by the component itself.
         */
        "secondary"?: boolean;
    }
    /**
     * @experimental 
     */
    interface PDrilldownLink {
        /**
          * Display link in active state.
         */
        "active"?: boolean;
        /**
          * Add ARIA attributes (only has effect when `href` is defined and no slotted anchor is used).
         */
        "aria"?: SelectedAriaAttributes<DrilldownLinkAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file (only has effect when `href` is defined and no slotted anchor is used).
         */
        "download"?: string;
        /**
          * When providing an url then the component will be rendered as `<a>` otherwise the component expects a slotted anchor.
         */
        "href"?: string;
        /**
          * Specifies the relationship of the target object to the link object (only has effect when `href` is defined and no slotted anchor is used).
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened (only has effect when `href` is defined and no slotted anchor is used).
         */
        "target"?: DrilldownLinkTarget;
    }
    interface PFieldset {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaRole<'radiogroup'>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The size of the label text.
         */
        "labelSize"?: FieldsetLabelSize;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Marks the Fieldset as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: FieldsetState;
    }
    interface PFlag {
        /**
          * A map of ARIA attributes to enhance the flag's accessibility. For example, use `{ 'aria-label': 'German flag' }` to provide a descriptive label for screen readers.
         */
        "aria"?: SelectedAriaAttributes<FlagAriaAttribute>;
        /**
          * Specifies the country flag to display. Use the two-letter ISO 3166-1 alpha-2 country code. For example, use `us` for the United States, `de` for Germany, `gb` for Great Britain.
         */
        "name"?: FlagName;
        /**
          * The size of the flag. Pre-defined sizes are aligned with the Porsche Next typescale. Available values are `small`, `medium`, `large`, etc.
         */
        "size"?: FlagSize;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PFlyout {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<FlyoutAriaAttribute>;
        /**
          * Defines the backdrop, 'blur' (should be used when the underlying content is not relevant for users) and 'shading' (should be used when the user still needs a visual connection to the underlying content).
         */
        "backdrop"?: FlyoutBackdrop;
        /**
          * Defines the background color
         */
        "background"?: FlyoutBackground;
        /**
          * If true, the flyout will not be closable via backdrop click.
         */
        "disableBackdropClick"?: boolean;
        /**
          * Determines the footer's position behavior. When set to "fixed," the flyout content stretches to fill the full height, keeping the footer permanently at the bottom. When set to "sticky," the footer flows beneath the content and only becomes fixed if the content overflows.
         */
        "footerBehavior"?: FlyoutFooterBehavior;
        /**
          * If true, the flyout is open.
         */
        "open": boolean;
        /**
          * The position of the flyout
         */
        "position"?: FlyoutPosition;
    }
    interface PHeading {
        /**
          * Text alignment of the component.
         */
        "align"?: HeadingAlign;
        /**
          * Basic text color variations.
         */
        "color"?: HeadingColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<HeadingSize>;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
         */
        "tag"?: HeadingTag;
    }
    interface PIcon {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<IconAriaAttribute>;
        /**
          * Basic color variations.
         */
        "color"?: IconColor;
        /**
          * Specifies which icon to use.
         */
        "name"?: IconName;
        /**
          * The size of the icon.
         */
        "size"?: IconSize;
        /**
          * Specifies a whole icon path which can be used for custom icons.
         */
        "source"?: string;
    }
    interface PInlineNotification {
        /**
          * Action icon of the inline-notification.
         */
        "actionIcon"?: InlineNotificationActionIcon;
        /**
          * Action label of the inline-notification.
         */
        "actionLabel"?: string;
        /**
          * Disables the action button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "actionLoading"?: boolean;
        /**
          * Description of the inline-notification.
         */
        "description"?: string;
        /**
          * If false, the inline-notification will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the inline-notification.
         */
        "heading"?: string;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
         */
        "headingTag"?: InlineNotificationHeadingTag;
        /**
          * State of the inline-notification.
         */
        "state"?: InlineNotificationState;
    }
    interface PInputDate {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., auto-complete='bday' for a birthday).
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * Specifies the latest date that can be selected. The value must be a date string in YYYY-MM-DD format (e.g., max='2024-12-31').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * Specifies the earliest date that can be selected. The value must be a date string in YYYY-MM-DD format (e.g., min='2023-01-01').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputDateState;
        /**
          * Defines the granularity of the date input. This value is given in days. The default is 1 (one day).
         */
        "step"?: number;
        /**
          * The default date value for the input, in YYYY-MM-DD format (e.g., value='2025-07-02').
         */
        "value"?: string;
    }
    interface PInputEmail {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='email').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Controls the visibility of the email icon.
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * A boolean value that, if present, it allows the user to enter a list of multiple email addresses, separated by commas (and optional whitespace). The browser will validate each email address in the list.
         */
        "multiple"?: boolean;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * Specifies a regular expression that the input's value must match for the value to pass constraint validation. This allows for more specific email validation rules than the browser's default (e.g., restricting to a specific domain). If provided, it overrides the browser's default email validation.
         */
        "pattern"?: string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='you@example.com'). This text is displayed when the input field is empty.
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputEmailState;
        /**
          * The default email address (or comma-separated list of addresses) for the input.
         */
        "value"?: string;
    }
    interface PInputMonth {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features.
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * Specifies the latest month that can be selected. The value must be a month string in YYYY-MM format(e.g., max='2024-12').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * Specifies the earliest month that can be selected. The value must be a month string in YYYY-MM format (e.g., min='2023-01').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputMonthState;
        /**
          * Defines the stepping interval in months. For example, step="1" increments by 1 month, step="12" by 1 year. The default is 1 month.
         */
        "step"?: number;
        /**
          * The default month value for the input, in YYYY-MM format (e.g., value='2025-07').
         */
        "value"?: string;
    }
    interface PInputNumber {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='postal-code').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Show or hide the increment/decrement stepper controls.
         */
        "controls"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * The max value of the number input.
         */
        "max"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * The min value of the number input.
         */
        "min"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Enter a number'). This text is displayed when the input field is empty.
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputNumberState;
        /**
          * The granularity that the value must adhere to.
         */
        "step"?: number;
        /**
          * The number input value.
         */
        "value"?: string;
    }
    interface PInputPassword {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='current-password', autocomplete='new-password').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Enter your password'). This text is displayed when the input field is empty.
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputPasswordState;
        /**
          * Show or hide password toggle for `input type="password"`.
         */
        "toggle"?: boolean;
        /**
          * The password input value.
         */
        "value"?: string;
    }
    interface PInputSearch {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='on').
         */
        "autoComplete"?: string;
        /**
          * Show clear input value button
         */
        "clear"?: boolean;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Show search indicator icon
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Search...'). This text is displayed when the input field is empty.
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputSearchState;
        /**
          * The search input value.
         */
        "value"?: string;
    }
    interface PInputTel {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='tel').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Controls the visibility of the phone icon.
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * Specifies a regular expression that the input's value must match for the value to pass constraint validation. This allows for more specific tel validation rules than the browser's default. If provided, it overrides the browser's default tel validation.
         */
        "pattern"?: string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='(123) 456-7890')
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputTelState;
        /**
          * The tel input value.
         */
        "value"?: string;
    }
    interface PInputText {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='name').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Show or hide the character counter.
         */
        "counter"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Enter your full name'). This text is displayed when the input field is empty.
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicate whether to enable spell-checking.
         */
        "spellCheck"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputTextState;
        /**
          * The text input value.
         */
        "value"?: string;
    }
    interface PInputTime {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., auto-complete='on').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * Specifies the latest time that can be selected. The value must be a time string in hh:mm or hh:mm:ss format (e.g., max='17:30').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * Specifies the earliest time that can be selected. The value must be a time string in hh:mm or hh:mm:ss format (e.g., min='09:00').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputTimeState;
        /**
          * efines the granularity of the time input. The step value is given in seconds. The default is 60 (one minute). You can also specify smaller increments (e.g., step='1' for seconds, step='0.001' for milliseconds).
         */
        "step"?: number;
        /**
          * The default time value for the input, in hh:mm or hh:mm:ss format (e.g., value='14:00').
         */
        "value"?: string;
    }
    interface PInputUrl {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='url').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Controls the visibility of the url icon.
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * Specifies a regular expression that the input's value must match for the value to pass constraint validation. This allows for more specific url validation rules than the browser's default. If provided, it overrides the browser's default tel validation.
         */
        "pattern"?: string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='https://porsche.com/')
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputUrlState;
        /**
          * The url input value.
         */
        "value"?: string;
    }
    interface PInputWeek {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features.
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * Specifies the latest week that can be selected. The value must be a week string in YYYY-Www format (e.g., max='2024-W52').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * Specifies the earliest week that can be selected. The value must be a week string in YYYY-Www format (e.g., min='2024-W01').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name": string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputWeekState;
        /**
          * Defines the stepping interval in weeks. For example, step="1" increments by 1 week. The default is 1 month.
         */
        "step"?: number;
        /**
          * The default week value for the input, in YYYY-Www format (e.g., value='2025-W27')
         */
        "value"?: string;
    }
    interface PLink {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkAriaAttribute>;
        /**
          * Displays as compact version.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: LinkIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTarget;
        /**
          * The style variant of the link.
         */
        "variant"?: LinkVariant;
    }
    interface PLinkPure {
        /**
          * Display link in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<LinkPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkPureAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed
         */
        "icon"?: LinkPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Size of the link.
         */
        "size"?: BreakpointCustomizable<LinkPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkPureTarget;
        /**
          * Shows an underline under the label.
         */
        "underline"?: boolean;
    }
    interface PLinkTile {
        /**
          * Alignment of link and description.
         */
        "align"?: LinkTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkTileAriaAttribute>;
        /**
          * Aspect ratio of the link-tile.
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileAspectRatio>;
        /**
          * Displays the link-tile as compact version with description and link icon only.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description": string;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show gradient.
         */
        "gradient"?: boolean;
        /**
          * href of the `<a>`.
         */
        "href": string;
        /**
          * Label of the <a />.
         */
        "label": string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Font size of the description.
         */
        "size"?: BreakpointCustomizable<LinkTileSize>;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTileTarget;
        /**
          * Font weight of the description.
         */
        "weight"?: BreakpointCustomizable<LinkTileWeight>;
    }
    /**
     * @controlled {"props": ["liked"], "event": "like"}
     * @experimental 
     */
    interface PLinkTileProduct {
        /**
          * Aspect ratio of the link-tile-product.
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileProductAspectRatio>;
        /**
          * Additional product description.
         */
        "description"?: string;
        /**
          * Product heading.
         */
        "heading": string;
        /**
          * href of the `<a>`.
         */
        "href"?: string;
        /**
          * A Boolean attribute indicating that a like button should be shown.
         */
        "likeButton"?: boolean;
        /**
          * A Boolean attribute indicating that a product is liked.
         */
        "liked"?: boolean;
        /**
          * Product retail price (with or without discount).
         */
        "price": string;
        /**
          * Shows original price (recommended retail price) with line-through. Needs prop "price" to be defined, otherwise this prop has no effect.
         */
        "priceOriginal"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTileProductTarget;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PModal {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ModalAriaAttribute>;
        /**
          * Defines the backdrop, 'blur' (should be used when Modal is opened by user interaction, e.g. after a click on a button) and 'shading' (should be used when Modal gets opened automatically, e.g. Cookie Consent).
         */
        "backdrop"?: ModalBackdrop;
        /**
          * Defines the background color
         */
        "background"?: ModalBackground;
        /**
          * If true, the modal will not be closable via backdrop click.
         */
        "disableBackdropClick"?: boolean;
        /**
          * If false, the modal will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * If true the modal uses max viewport height and width. Should only be used for mobile.
         */
        "fullscreen"?: BreakpointCustomizable<boolean>;
        /**
          * If true, the modal is open.
         */
        "open": boolean;
    }
    interface PModelSignature {
        /**
          * Adapts the color of the component.
         */
        "color"?: ModelSignatureColor;
        /**
          * Defines the fetch priority of the model signature. In the end it is just a recommendation to the browser, but it defines the priority on its own.
         */
        "fetchPriority"?: ModelSignatureFetchPriority;
        /**
          * Defines whether the model signature is always loaded or only loaded when it is in the viewport (this feature may not work reliably).
         */
        "lazy"?: boolean;
        /**
          * Adapts the model of the component.
         */
        "model"?: ModelSignatureModel;
        /**
          * When set to `true`, then all model signatures are visually aligned with each other. When set to `false` the model signature comes without any safe zone.
         */
        "safeZone"?: boolean;
        /**
          * Adapts the size of the component. When set to `inherit` a CSS `width` or `height` needs to be defined on the host but not both.
         */
        "size"?: ModelSignatureSize;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PMultiSelect {
        /**
          * Displays as compact version.
         */
        "compact"?: boolean;
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Disables the multi-select
         */
        "disabled"?: boolean;
        /**
          * Changes the direction to which the dropdown list appears.
         */
        "dropdownDirection"?: MultiSelectDropdownDirection;
        /**
          * The id of a form element the multi-select should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The name of the control.
         */
        "name": string;
        /**
          * A Boolean attribute indicating that an option with a non-empty string value must be selected.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: MultiSelectState;
        /**
          * The selected values.
         */
        "value"?: string[];
    }
    interface PMultiSelectOption {
        /**
          * Disables the option.
         */
        "disabled"?: boolean;
        /**
          * The option value.
         */
        "value": string;
    }
    interface POptgroup {
        /**
          * Disables the optgroup.
         */
        "disabled"?: boolean;
        /**
          * The optgroup label.
         */
        "label"?: string;
    }
    /**
     * @controlled { "props": ["activePage"], "event": "update", "isInternallyMutated": true }
     */
    interface PPagination {
        /**
          * Index of the currently active page.
         */
        "activePage"?: number;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev and page buttons.
         */
        "intl"?: PaginationInternationalization;
        /**
          * The total count of items which should be shown per page.
         */
        "itemsPerPage": number;
        /**
          * Show or hide the button to jump to the last page.
         */
        "showLastPage"?: boolean;
        /**
          * The total count of items.
         */
        "totalItemsCount": number;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PPinCode {
        /**
          * A boolean value that, if present, renders the pin-code as a compact version.
         */
        "compact"?: boolean;
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Disables the Pin Code. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the pin-code should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label and description text. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * Number of characters of the Pin Code.
         */
        "length"?: PinCodeLength;
        /**
          * Disables the Pin Code and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Name of the control.
         */
        "name"?: string;
        /**
          * Marks the Pin Code as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: PinCodeState;
        /**
          * Pin Code type.
         */
        "type"?: PinCodeType;
        /**
          * Sets the initial value of the Pin Code.
         */
        "value"?: string;
    }
    interface PPopover {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<PopoverAriaAttribute>;
        /**
          * Descriptive text to show additional information when popover is open
         */
        "description"?: string;
        /**
          * Preferred direction in which popover should open, given there is enough space in viewport. Otherwise, it will be opened in the direction with most available space.
         */
        "direction"?: PopoverDirection;
    }
    interface PRadioGroup {
        /**
          * A boolean value that, if present, renders the radio group as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the radio group.
         */
        "description"?: string;
        /**
          * Defines the direction of the main and cross axis. The default is 'column' showing options vertically stacked. You always need to provide a base value when using breakpoints.
         */
        "direction"?: BreakpointCustomizable<RadioGroupDirection>;
        /**
          * A boolean value that, if present, makes the radio group unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the radio group belongs to (useful if the radio group is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * The name of the group of radio buttons, used when submitting the form data.
         */
        "name": string;
        /**
          * A boolean value that specifies a selection must be made from the group before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the radio group component.
         */
        "state"?: RadioGroupState;
        /**
          * The default value for the radio-group.
         */
        "value"?: string;
    }
    interface PRadioGroupOption {
        /**
          * A boolean value that, if present, makes the radio group option unusable and unclickable.
         */
        "disabled"?: boolean;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * The value for the input.
         */
        "value"?: string;
    }
    interface PScroller {
        /**
          * Sets the vertical position of scroll indicator.
         */
        "alignScrollIndicator"?: ScrollerAlignScrollIndicator;
        /**
          * Add ARIA role.
         */
        "aria"?: SelectedAriaAttributes<ScrollerAriaAttribute>;
        /**
          * Scrolls the scroll area to the left either smooth or immediately.
         */
        "scrollToPosition"?: ScrollerScrollToPosition;
        /**
          * Specifies if scrollbar should be shown.
         */
        "scrollbar"?: boolean;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PSegmentedControl {
        /**
          * Sets the amount of columns.
         */
        "columns"?: BreakpointCustomizable<SegmentedControlColumns>;
        /**
          * A boolean value that, if present, renders the segmented-control as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the segmented-control.
         */
        "description"?: string;
        /**
          * Disables the segmented-control.
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the segmented-control should be associated with.
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * The name of the segmented-control.
         */
        "name"?: string;
        /**
          * A boolean value that specifies a selection must be made from the group before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the component.
         */
        "state"?: SegmentedControlState;
        /**
          * Sets the initial value of the segmented-control.
         */
        "value"?: string | number;
    }
    interface PSegmentedControlItem {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SegmentedControlItemAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The icon shown.
         */
        "icon"?: SegmentedControlItemIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The value of this item which is emitted by the parent element if it becomes selected. This property is **required**.
         */
        "value": string | number;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PSelect {
        /**
          * Displays as compact version.
         */
        "compact"?: boolean;
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Disables the select.
         */
        "disabled"?: boolean;
        /**
          * Changes the direction to which the dropdown list appears.
         */
        "dropdownDirection"?: SelectDropdownDirection;
        /**
          * Shows an input in the dropdown allowing options to be filtered. Will be ignored if the `filter` slot is used.
         */
        "filter"?: boolean;
        /**
          * The id of a form element the select should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The name of the control.
         */
        "name": string;
        /**
          * A Boolean attribute indicating that an option with a non-empty string value must be selected.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: SelectState;
        /**
          * The selected value.
         */
        "value"?: string;
    }
    interface PSelectOption {
        /**
          * Disables the option.
         */
        "disabled"?: boolean;
        /**
          * The option value.
         */
        "value"?: string;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PSheet {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SheetAriaAttribute>;
        /**
          * Defines the background color
         */
        "background"?: SheetBackground;
        /**
          * If true, the sheet will not be closable via backdrop click.
         */
        "disableBackdropClick"?: boolean;
        /**
          * If false, the sheet will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * If true, the sheet is open.
         */
        "open": boolean;
    }
    interface PSpinner {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SpinnerAriaAttribute>;
        /**
          * Size of the spinner.
         */
        "size"?: BreakpointCustomizable<SpinnerSize>;
    }
    interface PStepperHorizontal {
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<StepperHorizontalSize>;
    }
    interface PStepperHorizontalItem {
        /**
          * Disables the stepper-horizontal-item. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The validation state.
         */
        "state"?: StepperHorizontalItemState;
    }
    /**
     * @controlled {"props": ["checked"], "event": "update"}
     */
    interface PSwitch {
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<SwitchAlignLabel>;
        /**
          * Visualize the switch with on/off status.
         */
        "checked"?: boolean;
        /**
          * Displays as compact version.
         */
        "compact"?: boolean;
        /**
          * Disables the switch. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Disables the switch and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Stretches the contents to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
    }
    interface PTable {
        /**
          * A caption describing the contents of the table for accessibility only. This won't be visible in the browser. Use an element with an attribute of `slot="caption"` for a visible caption.
         */
        "caption"?: string;
        /**
          * Displays as compact version.
         */
        "compact"?: boolean;
        /**
          * Controls the layout behavior of the table.
         */
        "layout"?: TableLayout;
    }
    interface PTableBody {
    }
    interface PTableCell {
        /**
          * Displays slotted text multiline or forced into a single line.
         */
        "multiline"?: boolean;
    }
    interface PTableHead {
    }
    interface PTableHeadCell {
        /**
          * Hides the label but stays accessible for screen readers. This property only takes effect when sort property is not defined.
         */
        "hideLabel"?: boolean;
        /**
          * Displays slotted text multiline or forced into a single line.
         */
        "multiline"?: boolean;
        /**
          * Defines sortability properties.
         */
        "sort"?: TableHeadCellSort;
    }
    interface PTableHeadRow {
    }
    interface PTableRow {
    }
    /**
     * @controlled { "props": ["activeTabIndex"], "event": "update", "isInternallyMutated": true }
     */
    interface PTabs {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering).
         */
        "activeTabIndex"?: number;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabsSize>;
        /**
          * The text weight.
         */
        "weight"?: TabsWeight;
    }
    /**
     * @controlled {"props": ["activeTabIndex"], "event": "update"}
     */
    interface PTabsBar {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering), undefined if none should be selected.
         */
        "activeTabIndex"?: number | undefined;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabsBarSize>;
        /**
          * The text weight.
         */
        "weight"?: TabsBarWeight;
    }
    interface PTabsItem {
        /**
          * Defines the label used in tabs.
         */
        "label": string;
    }
    interface PTag {
        /**
          * Displays as compact version.
         */
        "compact"?: boolean;
        /**
          * The icon shown.
         */
        "icon"?: TagIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Background color variations.
         */
        "variant"?: TagVariant;
    }
    interface PTagDismissible {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<TagDismissibleAriaAttribute>;
        /**
          * A boolean value that, if present, renders the tag dismissible as a compact version.
         */
        "compact"?: boolean;
        /**
          * The label text.
         */
        "label"?: string;
    }
    interface PText {
        /**
          * Text alignment of the component.
         */
        "align"?: TextAlign;
        /**
          * Basic text color variations.
         */
        "color"?: TextColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the text. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<TextSize>;
        /**
          * Sets a custom HTML tag depending on the usage of the text component.
         */
        "tag"?: TextTag;
        /**
          * The weight of the text.
         */
        "weight"?: TextWeight;
    }
    interface PTextList {
        /**
          * The list style type.
         */
        "type"?: TextListType;
    }
    interface PTextListItem {
    }
    interface PTextarea {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='on').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the textarea as a compact version.
         */
        "compact"?: boolean;
        /**
          * Show or hide the character counter.
         */
        "counter"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the textarea.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the textarea unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the textarea belongs to (useful if the textarea is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the textarea.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the textarea's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the textarea, used when submitting the form data.
         */
        "name": string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Write your message here...'). This text is displayed when the textarea is empty.
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the textarea uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the textarea must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Controls whether the textarea is resizable and in which direction.
         */
        "resize"?: TextareaResize;
        /**
          * The number of rows. Has no effect when field-sizing CSS Variable '--p-textarea-field-sizing' is set to 'content'.
         */
        "rows"?: number;
        /**
          * Specifies whether the textarea should have its spelling and grammar checked
         */
        "spellCheck"?: boolean;
        /**
          * Indicates the validation or overall status of the textarea component.
         */
        "state"?: TextareaState;
        /**
          * The textarea value.
         */
        "value"?: string;
        /**
          * Handles wrapping behavior of elements.
         */
        "wrap"?: TextareaWrap;
    }
    interface PToast {
        "addMessage": (message: ToastMessage) => Promise<void>;
    }
    interface PToastItem {
        /**
          * State of the toast-item.
         */
        "state"?: ToastState;
        /**
          * Text of the toast-item.
         */
        "text"?: string;
    }
    interface PWordmark {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<WordmarkAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Adapts sizing of wordmark.
         */
        "size"?: WordmarkSize;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: WordmarkTarget;
    }
}
export interface PAccordionCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPAccordionElement;
}
export interface PBannerCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPBannerElement;
}
export interface PCanvasCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPCanvasElement;
}
export interface PCarouselCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPCarouselElement;
}
export interface PCheckboxCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPCheckboxElement;
}
export interface PDrilldownCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPDrilldownElement;
}
export interface PFlyoutCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPFlyoutElement;
}
export interface PInlineNotificationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInlineNotificationElement;
}
export interface PInputDateCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputDateElement;
}
export interface PInputEmailCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputEmailElement;
}
export interface PInputMonthCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputMonthElement;
}
export interface PInputNumberCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputNumberElement;
}
export interface PInputPasswordCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputPasswordElement;
}
export interface PInputSearchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputSearchElement;
}
export interface PInputTelCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputTelElement;
}
export interface PInputTextCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputTextElement;
}
export interface PInputTimeCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputTimeElement;
}
export interface PInputUrlCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputUrlElement;
}
export interface PInputWeekCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPInputWeekElement;
}
export interface PLinkTileProductCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPLinkTileProductElement;
}
export interface PModalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPModalElement;
}
export interface PMultiSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPMultiSelectElement;
}
export interface PPaginationCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPPaginationElement;
}
export interface PPinCodeCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPPinCodeElement;
}
export interface PRadioGroupCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPRadioGroupElement;
}
export interface PSegmentedControlCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPSegmentedControlElement;
}
export interface PSelectCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPSelectElement;
}
export interface PSheetCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPSheetElement;
}
export interface PStepperHorizontalCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPStepperHorizontalElement;
}
export interface PSwitchCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPSwitchElement;
}
export interface PTableCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTableElement;
}
export interface PTabsCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTabsElement;
}
export interface PTabsBarCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTabsBarElement;
}
export interface PTextareaCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPTextareaElement;
}
export interface PToastItemCustomEvent<T> extends CustomEvent<T> {
    detail: T;
    target: HTMLPToastItemElement;
}
declare global {
    interface HTMLPAccordionElementEventMap {
        "update": AccordionUpdateEventDetail;
    }
    /**
     * @controlled {"props": ["open"], "event": "update"}
     */
    interface HTMLPAccordionElement extends Components.PAccordion, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPAccordionElementEventMap>(type: K, listener: (this: HTMLPAccordionElement, ev: PAccordionCustomEvent<HTMLPAccordionElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPAccordionElementEventMap>(type: K, listener: (this: HTMLPAccordionElement, ev: PAccordionCustomEvent<HTMLPAccordionElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPAccordionElement: {
        prototype: HTMLPAccordionElement;
        new (): HTMLPAccordionElement;
    };
    interface HTMLPBannerElementEventMap {
        "dismiss": void;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface HTMLPBannerElement extends Components.PBanner, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPBannerElementEventMap>(type: K, listener: (this: HTMLPBannerElement, ev: PBannerCustomEvent<HTMLPBannerElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPBannerElementEventMap>(type: K, listener: (this: HTMLPBannerElement, ev: PBannerCustomEvent<HTMLPBannerElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPBannerElement: {
        prototype: HTMLPBannerElement;
        new (): HTMLPBannerElement;
    };
    interface HTMLPButtonElement extends Components.PButton, HTMLStencilElement {
    }
    var HTMLPButtonElement: {
        prototype: HTMLPButtonElement;
        new (): HTMLPButtonElement;
    };
    interface HTMLPButtonPureElement extends Components.PButtonPure, HTMLStencilElement {
    }
    var HTMLPButtonPureElement: {
        prototype: HTMLPButtonPureElement;
        new (): HTMLPButtonPureElement;
    };
    interface HTMLPButtonTileElement extends Components.PButtonTile, HTMLStencilElement {
    }
    var HTMLPButtonTileElement: {
        prototype: HTMLPButtonTileElement;
        new (): HTMLPButtonTileElement;
    };
    interface HTMLPCanvasElementEventMap {
        "sidebarStartUpdate": CanvasSidebarStartUpdateEventDetail;
        "sidebarEndDismiss": void;
    }
    /**
     * @experimental 
     */
    interface HTMLPCanvasElement extends Components.PCanvas, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPCanvasElementEventMap>(type: K, listener: (this: HTMLPCanvasElement, ev: PCanvasCustomEvent<HTMLPCanvasElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPCanvasElementEventMap>(type: K, listener: (this: HTMLPCanvasElement, ev: PCanvasCustomEvent<HTMLPCanvasElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPCanvasElement: {
        prototype: HTMLPCanvasElement;
        new (): HTMLPCanvasElement;
    };
    interface HTMLPCarouselElementEventMap {
        "update": CarouselUpdateEventDetail;
    }
    /**
     * @controlled { "props": ["activeSlideIndex"], "event": "update", "isInternallyMutated": true }
     */
    interface HTMLPCarouselElement extends Components.PCarousel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPCarouselElementEventMap>(type: K, listener: (this: HTMLPCarouselElement, ev: PCarouselCustomEvent<HTMLPCarouselElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPCarouselElementEventMap>(type: K, listener: (this: HTMLPCarouselElement, ev: PCarouselCustomEvent<HTMLPCarouselElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPCarouselElement: {
        prototype: HTMLPCarouselElement;
        new (): HTMLPCarouselElement;
    };
    interface HTMLPCheckboxElementEventMap {
        "change": CheckboxChangeEventDetail;
        "blur": CheckboxBlurEventDetail;
    }
    interface HTMLPCheckboxElement extends Components.PCheckbox, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPCheckboxElementEventMap>(type: K, listener: (this: HTMLPCheckboxElement, ev: PCheckboxCustomEvent<HTMLPCheckboxElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPCheckboxElementEventMap>(type: K, listener: (this: HTMLPCheckboxElement, ev: PCheckboxCustomEvent<HTMLPCheckboxElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPCheckboxElement: {
        prototype: HTMLPCheckboxElement;
        new (): HTMLPCheckboxElement;
    };
    interface HTMLPCrestElement extends Components.PCrest, HTMLStencilElement {
    }
    var HTMLPCrestElement: {
        prototype: HTMLPCrestElement;
        new (): HTMLPCrestElement;
    };
    interface HTMLPDisplayElement extends Components.PDisplay, HTMLStencilElement {
    }
    var HTMLPDisplayElement: {
        prototype: HTMLPDisplayElement;
        new (): HTMLPDisplayElement;
    };
    interface HTMLPDividerElement extends Components.PDivider, HTMLStencilElement {
    }
    var HTMLPDividerElement: {
        prototype: HTMLPDividerElement;
        new (): HTMLPDividerElement;
    };
    interface HTMLPDrilldownElementEventMap {
        "dismiss": void;
        "update": DrilldownUpdateEventDetail;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     * @controlled {"props": ["activeIdentifier"], "event": "update"}
     * @experimental 
     */
    interface HTMLPDrilldownElement extends Components.PDrilldown, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPDrilldownElementEventMap>(type: K, listener: (this: HTMLPDrilldownElement, ev: PDrilldownCustomEvent<HTMLPDrilldownElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPDrilldownElementEventMap>(type: K, listener: (this: HTMLPDrilldownElement, ev: PDrilldownCustomEvent<HTMLPDrilldownElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPDrilldownElement: {
        prototype: HTMLPDrilldownElement;
        new (): HTMLPDrilldownElement;
    };
    /**
     * @experimental 
     */
    interface HTMLPDrilldownItemElement extends Components.PDrilldownItem, HTMLStencilElement {
    }
    var HTMLPDrilldownItemElement: {
        prototype: HTMLPDrilldownItemElement;
        new (): HTMLPDrilldownItemElement;
    };
    /**
     * @experimental 
     */
    interface HTMLPDrilldownLinkElement extends Components.PDrilldownLink, HTMLStencilElement {
    }
    var HTMLPDrilldownLinkElement: {
        prototype: HTMLPDrilldownLinkElement;
        new (): HTMLPDrilldownLinkElement;
    };
    interface HTMLPFieldsetElement extends Components.PFieldset, HTMLStencilElement {
    }
    var HTMLPFieldsetElement: {
        prototype: HTMLPFieldsetElement;
        new (): HTMLPFieldsetElement;
    };
    interface HTMLPFlagElement extends Components.PFlag, HTMLStencilElement {
    }
    var HTMLPFlagElement: {
        prototype: HTMLPFlagElement;
        new (): HTMLPFlagElement;
    };
    interface HTMLPFlyoutElementEventMap {
        "dismiss": void;
        "motionVisibleEnd": FlyoutMotionVisibleEndEventDetail;
        "motionHiddenEnd": FlyoutMotionHiddenEndEventDetail;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface HTMLPFlyoutElement extends Components.PFlyout, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPFlyoutElementEventMap>(type: K, listener: (this: HTMLPFlyoutElement, ev: PFlyoutCustomEvent<HTMLPFlyoutElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPFlyoutElementEventMap>(type: K, listener: (this: HTMLPFlyoutElement, ev: PFlyoutCustomEvent<HTMLPFlyoutElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPFlyoutElement: {
        prototype: HTMLPFlyoutElement;
        new (): HTMLPFlyoutElement;
    };
    interface HTMLPHeadingElement extends Components.PHeading, HTMLStencilElement {
    }
    var HTMLPHeadingElement: {
        prototype: HTMLPHeadingElement;
        new (): HTMLPHeadingElement;
    };
    interface HTMLPIconElement extends Components.PIcon, HTMLStencilElement {
    }
    var HTMLPIconElement: {
        prototype: HTMLPIconElement;
        new (): HTMLPIconElement;
    };
    interface HTMLPInlineNotificationElementEventMap {
        "dismiss": void;
        "action": void;
    }
    interface HTMLPInlineNotificationElement extends Components.PInlineNotification, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInlineNotificationElementEventMap>(type: K, listener: (this: HTMLPInlineNotificationElement, ev: PInlineNotificationCustomEvent<HTMLPInlineNotificationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInlineNotificationElementEventMap>(type: K, listener: (this: HTMLPInlineNotificationElement, ev: PInlineNotificationCustomEvent<HTMLPInlineNotificationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInlineNotificationElement: {
        prototype: HTMLPInlineNotificationElement;
        new (): HTMLPInlineNotificationElement;
    };
    interface HTMLPInputDateElementEventMap {
        "change": InputDateChangeEventDetail;
        "blur": InputDateBlurEventDetail;
        "input": InputDateInputEventDetail;
    }
    interface HTMLPInputDateElement extends Components.PInputDate, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputDateElementEventMap>(type: K, listener: (this: HTMLPInputDateElement, ev: PInputDateCustomEvent<HTMLPInputDateElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputDateElementEventMap>(type: K, listener: (this: HTMLPInputDateElement, ev: PInputDateCustomEvent<HTMLPInputDateElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputDateElement: {
        prototype: HTMLPInputDateElement;
        new (): HTMLPInputDateElement;
    };
    interface HTMLPInputEmailElementEventMap {
        "change": InputEmailChangeEventDetail;
        "blur": InputEmailBlurEventDetail;
        "input": InputEmailInputEventDetail;
    }
    interface HTMLPInputEmailElement extends Components.PInputEmail, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputEmailElementEventMap>(type: K, listener: (this: HTMLPInputEmailElement, ev: PInputEmailCustomEvent<HTMLPInputEmailElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputEmailElementEventMap>(type: K, listener: (this: HTMLPInputEmailElement, ev: PInputEmailCustomEvent<HTMLPInputEmailElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputEmailElement: {
        prototype: HTMLPInputEmailElement;
        new (): HTMLPInputEmailElement;
    };
    interface HTMLPInputMonthElementEventMap {
        "change": InputMonthChangeEventDetail;
        "blur": InputMonthBlurEventDetail;
        "input": InputMonthInputEventDetail;
    }
    interface HTMLPInputMonthElement extends Components.PInputMonth, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputMonthElementEventMap>(type: K, listener: (this: HTMLPInputMonthElement, ev: PInputMonthCustomEvent<HTMLPInputMonthElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputMonthElementEventMap>(type: K, listener: (this: HTMLPInputMonthElement, ev: PInputMonthCustomEvent<HTMLPInputMonthElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputMonthElement: {
        prototype: HTMLPInputMonthElement;
        new (): HTMLPInputMonthElement;
    };
    interface HTMLPInputNumberElementEventMap {
        "change": InputNumberChangeEventDetail;
        "blur": InputNumberBlurEventDetail;
        "input": InputNumberInputEventDetail;
    }
    interface HTMLPInputNumberElement extends Components.PInputNumber, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputNumberElementEventMap>(type: K, listener: (this: HTMLPInputNumberElement, ev: PInputNumberCustomEvent<HTMLPInputNumberElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputNumberElementEventMap>(type: K, listener: (this: HTMLPInputNumberElement, ev: PInputNumberCustomEvent<HTMLPInputNumberElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputNumberElement: {
        prototype: HTMLPInputNumberElement;
        new (): HTMLPInputNumberElement;
    };
    interface HTMLPInputPasswordElementEventMap {
        "change": InputPasswordChangeEventDetail;
        "blur": InputPasswordBlurEventDetail;
        "input": InputPasswordInputEventDetail;
    }
    interface HTMLPInputPasswordElement extends Components.PInputPassword, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputPasswordElementEventMap>(type: K, listener: (this: HTMLPInputPasswordElement, ev: PInputPasswordCustomEvent<HTMLPInputPasswordElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputPasswordElementEventMap>(type: K, listener: (this: HTMLPInputPasswordElement, ev: PInputPasswordCustomEvent<HTMLPInputPasswordElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputPasswordElement: {
        prototype: HTMLPInputPasswordElement;
        new (): HTMLPInputPasswordElement;
    };
    interface HTMLPInputSearchElementEventMap {
        "change": InputSearchChangeEventDetail;
        "blur": InputSearchBlurEventDetail;
        "input": InputSearchInputEventDetail;
    }
    interface HTMLPInputSearchElement extends Components.PInputSearch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputSearchElementEventMap>(type: K, listener: (this: HTMLPInputSearchElement, ev: PInputSearchCustomEvent<HTMLPInputSearchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputSearchElementEventMap>(type: K, listener: (this: HTMLPInputSearchElement, ev: PInputSearchCustomEvent<HTMLPInputSearchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputSearchElement: {
        prototype: HTMLPInputSearchElement;
        new (): HTMLPInputSearchElement;
    };
    interface HTMLPInputTelElementEventMap {
        "change": InputTelChangeEventDetail;
        "blur": InputTelBlurEventDetail;
        "input": InputTelInputEventDetail;
    }
    interface HTMLPInputTelElement extends Components.PInputTel, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputTelElementEventMap>(type: K, listener: (this: HTMLPInputTelElement, ev: PInputTelCustomEvent<HTMLPInputTelElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputTelElementEventMap>(type: K, listener: (this: HTMLPInputTelElement, ev: PInputTelCustomEvent<HTMLPInputTelElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputTelElement: {
        prototype: HTMLPInputTelElement;
        new (): HTMLPInputTelElement;
    };
    interface HTMLPInputTextElementEventMap {
        "change": InputTextChangeEventDetail;
        "blur": InputTextBlurEventDetail;
        "input": InputTextInputEventDetail;
    }
    interface HTMLPInputTextElement extends Components.PInputText, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputTextElementEventMap>(type: K, listener: (this: HTMLPInputTextElement, ev: PInputTextCustomEvent<HTMLPInputTextElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputTextElementEventMap>(type: K, listener: (this: HTMLPInputTextElement, ev: PInputTextCustomEvent<HTMLPInputTextElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputTextElement: {
        prototype: HTMLPInputTextElement;
        new (): HTMLPInputTextElement;
    };
    interface HTMLPInputTimeElementEventMap {
        "change": InputTimeChangeEventDetail;
        "blur": InputTimeBlurEventDetail;
        "input": InputTimeInputEventDetail;
    }
    interface HTMLPInputTimeElement extends Components.PInputTime, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputTimeElementEventMap>(type: K, listener: (this: HTMLPInputTimeElement, ev: PInputTimeCustomEvent<HTMLPInputTimeElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputTimeElementEventMap>(type: K, listener: (this: HTMLPInputTimeElement, ev: PInputTimeCustomEvent<HTMLPInputTimeElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputTimeElement: {
        prototype: HTMLPInputTimeElement;
        new (): HTMLPInputTimeElement;
    };
    interface HTMLPInputUrlElementEventMap {
        "change": InputUrlChangeEventDetail;
        "blur": InputUrlBlurEventDetail;
        "input": InputUrlInputEventDetail;
    }
    interface HTMLPInputUrlElement extends Components.PInputUrl, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputUrlElementEventMap>(type: K, listener: (this: HTMLPInputUrlElement, ev: PInputUrlCustomEvent<HTMLPInputUrlElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputUrlElementEventMap>(type: K, listener: (this: HTMLPInputUrlElement, ev: PInputUrlCustomEvent<HTMLPInputUrlElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputUrlElement: {
        prototype: HTMLPInputUrlElement;
        new (): HTMLPInputUrlElement;
    };
    interface HTMLPInputWeekElementEventMap {
        "change": InputWeekChangeEventDetail;
        "blur": InputWeekBlurEventDetail;
        "input": InputWeekInputEventDetail;
    }
    interface HTMLPInputWeekElement extends Components.PInputWeek, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPInputWeekElementEventMap>(type: K, listener: (this: HTMLPInputWeekElement, ev: PInputWeekCustomEvent<HTMLPInputWeekElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPInputWeekElementEventMap>(type: K, listener: (this: HTMLPInputWeekElement, ev: PInputWeekCustomEvent<HTMLPInputWeekElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPInputWeekElement: {
        prototype: HTMLPInputWeekElement;
        new (): HTMLPInputWeekElement;
    };
    interface HTMLPLinkElement extends Components.PLink, HTMLStencilElement {
    }
    var HTMLPLinkElement: {
        prototype: HTMLPLinkElement;
        new (): HTMLPLinkElement;
    };
    interface HTMLPLinkPureElement extends Components.PLinkPure, HTMLStencilElement {
    }
    var HTMLPLinkPureElement: {
        prototype: HTMLPLinkPureElement;
        new (): HTMLPLinkPureElement;
    };
    interface HTMLPLinkTileElement extends Components.PLinkTile, HTMLStencilElement {
    }
    var HTMLPLinkTileElement: {
        prototype: HTMLPLinkTileElement;
        new (): HTMLPLinkTileElement;
    };
    interface HTMLPLinkTileProductElementEventMap {
        "like": LinkTileProductLikeEventDetail;
    }
    /**
     * @controlled {"props": ["liked"], "event": "like"}
     * @experimental 
     */
    interface HTMLPLinkTileProductElement extends Components.PLinkTileProduct, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPLinkTileProductElementEventMap>(type: K, listener: (this: HTMLPLinkTileProductElement, ev: PLinkTileProductCustomEvent<HTMLPLinkTileProductElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPLinkTileProductElementEventMap>(type: K, listener: (this: HTMLPLinkTileProductElement, ev: PLinkTileProductCustomEvent<HTMLPLinkTileProductElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPLinkTileProductElement: {
        prototype: HTMLPLinkTileProductElement;
        new (): HTMLPLinkTileProductElement;
    };
    interface HTMLPModalElementEventMap {
        "dismiss": void;
        "motionVisibleEnd": ModalMotionVisibleEndEventDetail;
        "motionHiddenEnd": ModalMotionHiddenEndEventDetail;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface HTMLPModalElement extends Components.PModal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPModalElementEventMap>(type: K, listener: (this: HTMLPModalElement, ev: PModalCustomEvent<HTMLPModalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPModalElementEventMap>(type: K, listener: (this: HTMLPModalElement, ev: PModalCustomEvent<HTMLPModalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPModalElement: {
        prototype: HTMLPModalElement;
        new (): HTMLPModalElement;
    };
    interface HTMLPModelSignatureElement extends Components.PModelSignature, HTMLStencilElement {
    }
    var HTMLPModelSignatureElement: {
        prototype: HTMLPModelSignatureElement;
        new (): HTMLPModelSignatureElement;
    };
    interface HTMLPMultiSelectElementEventMap {
        "blur": void;
        "change": MultiSelectChangeEventDetail;
        "toggle": MultiSelectToggleEventDetail;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface HTMLPMultiSelectElement extends Components.PMultiSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPMultiSelectElementEventMap>(type: K, listener: (this: HTMLPMultiSelectElement, ev: PMultiSelectCustomEvent<HTMLPMultiSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPMultiSelectElementEventMap>(type: K, listener: (this: HTMLPMultiSelectElement, ev: PMultiSelectCustomEvent<HTMLPMultiSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPMultiSelectElement: {
        prototype: HTMLPMultiSelectElement;
        new (): HTMLPMultiSelectElement;
    };
    interface HTMLPMultiSelectOptionElement extends Components.PMultiSelectOption, HTMLStencilElement {
    }
    var HTMLPMultiSelectOptionElement: {
        prototype: HTMLPMultiSelectOptionElement;
        new (): HTMLPMultiSelectOptionElement;
    };
    interface HTMLPOptgroupElement extends Components.POptgroup, HTMLStencilElement {
    }
    var HTMLPOptgroupElement: {
        prototype: HTMLPOptgroupElement;
        new (): HTMLPOptgroupElement;
    };
    interface HTMLPPaginationElementEventMap {
        "update": PaginationUpdateEventDetail;
    }
    /**
     * @controlled { "props": ["activePage"], "event": "update", "isInternallyMutated": true }
     */
    interface HTMLPPaginationElement extends Components.PPagination, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPPaginationElementEventMap>(type: K, listener: (this: HTMLPPaginationElement, ev: PPaginationCustomEvent<HTMLPPaginationElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPPaginationElementEventMap>(type: K, listener: (this: HTMLPPaginationElement, ev: PPaginationCustomEvent<HTMLPPaginationElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPPaginationElement: {
        prototype: HTMLPPaginationElement;
        new (): HTMLPPaginationElement;
    };
    interface HTMLPPinCodeElementEventMap {
        "blur": void;
        "change": PinCodeChangeEventDetail;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface HTMLPPinCodeElement extends Components.PPinCode, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPPinCodeElementEventMap>(type: K, listener: (this: HTMLPPinCodeElement, ev: PPinCodeCustomEvent<HTMLPPinCodeElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPPinCodeElementEventMap>(type: K, listener: (this: HTMLPPinCodeElement, ev: PPinCodeCustomEvent<HTMLPPinCodeElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPPinCodeElement: {
        prototype: HTMLPPinCodeElement;
        new (): HTMLPPinCodeElement;
    };
    interface HTMLPPopoverElement extends Components.PPopover, HTMLStencilElement {
    }
    var HTMLPPopoverElement: {
        prototype: HTMLPPopoverElement;
        new (): HTMLPPopoverElement;
    };
    interface HTMLPRadioGroupElementEventMap {
        "blur": void;
        "change": RadioGroupChangeEventDetail;
    }
    interface HTMLPRadioGroupElement extends Components.PRadioGroup, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPRadioGroupElementEventMap>(type: K, listener: (this: HTMLPRadioGroupElement, ev: PRadioGroupCustomEvent<HTMLPRadioGroupElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPRadioGroupElementEventMap>(type: K, listener: (this: HTMLPRadioGroupElement, ev: PRadioGroupCustomEvent<HTMLPRadioGroupElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPRadioGroupElement: {
        prototype: HTMLPRadioGroupElement;
        new (): HTMLPRadioGroupElement;
    };
    interface HTMLPRadioGroupOptionElement extends Components.PRadioGroupOption, HTMLStencilElement {
    }
    var HTMLPRadioGroupOptionElement: {
        prototype: HTMLPRadioGroupOptionElement;
        new (): HTMLPRadioGroupOptionElement;
    };
    interface HTMLPScrollerElement extends Components.PScroller, HTMLStencilElement {
    }
    var HTMLPScrollerElement: {
        prototype: HTMLPScrollerElement;
        new (): HTMLPScrollerElement;
    };
    interface HTMLPSegmentedControlElementEventMap {
        "blur": void;
        "change": SegmentedControlChangeEventDetail;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface HTMLPSegmentedControlElement extends Components.PSegmentedControl, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPSegmentedControlElementEventMap>(type: K, listener: (this: HTMLPSegmentedControlElement, ev: PSegmentedControlCustomEvent<HTMLPSegmentedControlElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPSegmentedControlElementEventMap>(type: K, listener: (this: HTMLPSegmentedControlElement, ev: PSegmentedControlCustomEvent<HTMLPSegmentedControlElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPSegmentedControlElement: {
        prototype: HTMLPSegmentedControlElement;
        new (): HTMLPSegmentedControlElement;
    };
    interface HTMLPSegmentedControlItemElement extends Components.PSegmentedControlItem, HTMLStencilElement {
    }
    var HTMLPSegmentedControlItemElement: {
        prototype: HTMLPSegmentedControlItemElement;
        new (): HTMLPSegmentedControlItemElement;
    };
    interface HTMLPSelectElementEventMap {
        "blur": void;
        "change": SelectChangeEventDetail;
        "toggle": SelectToggleEventDetail;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface HTMLPSelectElement extends Components.PSelect, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPSelectElementEventMap>(type: K, listener: (this: HTMLPSelectElement, ev: PSelectCustomEvent<HTMLPSelectElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPSelectElementEventMap>(type: K, listener: (this: HTMLPSelectElement, ev: PSelectCustomEvent<HTMLPSelectElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPSelectElement: {
        prototype: HTMLPSelectElement;
        new (): HTMLPSelectElement;
    };
    interface HTMLPSelectOptionElement extends Components.PSelectOption, HTMLStencilElement {
    }
    var HTMLPSelectOptionElement: {
        prototype: HTMLPSelectOptionElement;
        new (): HTMLPSelectOptionElement;
    };
    interface HTMLPSheetElementEventMap {
        "dismiss": void;
        "motionVisibleEnd": SheetMotionVisibleEndEventDetail;
        "motionHiddenEnd": SheetMotionHiddenEndEventDetail;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface HTMLPSheetElement extends Components.PSheet, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPSheetElementEventMap>(type: K, listener: (this: HTMLPSheetElement, ev: PSheetCustomEvent<HTMLPSheetElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPSheetElementEventMap>(type: K, listener: (this: HTMLPSheetElement, ev: PSheetCustomEvent<HTMLPSheetElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPSheetElement: {
        prototype: HTMLPSheetElement;
        new (): HTMLPSheetElement;
    };
    interface HTMLPSpinnerElement extends Components.PSpinner, HTMLStencilElement {
    }
    var HTMLPSpinnerElement: {
        prototype: HTMLPSpinnerElement;
        new (): HTMLPSpinnerElement;
    };
    interface HTMLPStepperHorizontalElementEventMap {
        "update": StepperHorizontalUpdateEventDetail;
    }
    interface HTMLPStepperHorizontalElement extends Components.PStepperHorizontal, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPStepperHorizontalElementEventMap>(type: K, listener: (this: HTMLPStepperHorizontalElement, ev: PStepperHorizontalCustomEvent<HTMLPStepperHorizontalElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPStepperHorizontalElementEventMap>(type: K, listener: (this: HTMLPStepperHorizontalElement, ev: PStepperHorizontalCustomEvent<HTMLPStepperHorizontalElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPStepperHorizontalElement: {
        prototype: HTMLPStepperHorizontalElement;
        new (): HTMLPStepperHorizontalElement;
    };
    interface HTMLPStepperHorizontalItemElement extends Components.PStepperHorizontalItem, HTMLStencilElement {
    }
    var HTMLPStepperHorizontalItemElement: {
        prototype: HTMLPStepperHorizontalItemElement;
        new (): HTMLPStepperHorizontalItemElement;
    };
    interface HTMLPSwitchElementEventMap {
        "update": SwitchUpdateEventDetail;
    }
    /**
     * @controlled {"props": ["checked"], "event": "update"}
     */
    interface HTMLPSwitchElement extends Components.PSwitch, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPSwitchElementEventMap>(type: K, listener: (this: HTMLPSwitchElement, ev: PSwitchCustomEvent<HTMLPSwitchElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPSwitchElementEventMap>(type: K, listener: (this: HTMLPSwitchElement, ev: PSwitchCustomEvent<HTMLPSwitchElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPSwitchElement: {
        prototype: HTMLPSwitchElement;
        new (): HTMLPSwitchElement;
    };
    interface HTMLPTableElementEventMap {
        "update": TableUpdateEventDetail;
    }
    interface HTMLPTableElement extends Components.PTable, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPTableElementEventMap>(type: K, listener: (this: HTMLPTableElement, ev: PTableCustomEvent<HTMLPTableElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPTableElementEventMap>(type: K, listener: (this: HTMLPTableElement, ev: PTableCustomEvent<HTMLPTableElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPTableElement: {
        prototype: HTMLPTableElement;
        new (): HTMLPTableElement;
    };
    interface HTMLPTableBodyElement extends Components.PTableBody, HTMLStencilElement {
    }
    var HTMLPTableBodyElement: {
        prototype: HTMLPTableBodyElement;
        new (): HTMLPTableBodyElement;
    };
    interface HTMLPTableCellElement extends Components.PTableCell, HTMLStencilElement {
    }
    var HTMLPTableCellElement: {
        prototype: HTMLPTableCellElement;
        new (): HTMLPTableCellElement;
    };
    interface HTMLPTableHeadElement extends Components.PTableHead, HTMLStencilElement {
    }
    var HTMLPTableHeadElement: {
        prototype: HTMLPTableHeadElement;
        new (): HTMLPTableHeadElement;
    };
    interface HTMLPTableHeadCellElement extends Components.PTableHeadCell, HTMLStencilElement {
    }
    var HTMLPTableHeadCellElement: {
        prototype: HTMLPTableHeadCellElement;
        new (): HTMLPTableHeadCellElement;
    };
    interface HTMLPTableHeadRowElement extends Components.PTableHeadRow, HTMLStencilElement {
    }
    var HTMLPTableHeadRowElement: {
        prototype: HTMLPTableHeadRowElement;
        new (): HTMLPTableHeadRowElement;
    };
    interface HTMLPTableRowElement extends Components.PTableRow, HTMLStencilElement {
    }
    var HTMLPTableRowElement: {
        prototype: HTMLPTableRowElement;
        new (): HTMLPTableRowElement;
    };
    interface HTMLPTabsElementEventMap {
        "update": TabsUpdateEventDetail;
    }
    /**
     * @controlled { "props": ["activeTabIndex"], "event": "update", "isInternallyMutated": true }
     */
    interface HTMLPTabsElement extends Components.PTabs, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPTabsElementEventMap>(type: K, listener: (this: HTMLPTabsElement, ev: PTabsCustomEvent<HTMLPTabsElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPTabsElementEventMap>(type: K, listener: (this: HTMLPTabsElement, ev: PTabsCustomEvent<HTMLPTabsElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPTabsElement: {
        prototype: HTMLPTabsElement;
        new (): HTMLPTabsElement;
    };
    interface HTMLPTabsBarElementEventMap {
        "update": TabsBarUpdateEventDetail;
    }
    /**
     * @controlled {"props": ["activeTabIndex"], "event": "update"}
     */
    interface HTMLPTabsBarElement extends Components.PTabsBar, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPTabsBarElementEventMap>(type: K, listener: (this: HTMLPTabsBarElement, ev: PTabsBarCustomEvent<HTMLPTabsBarElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPTabsBarElementEventMap>(type: K, listener: (this: HTMLPTabsBarElement, ev: PTabsBarCustomEvent<HTMLPTabsBarElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPTabsBarElement: {
        prototype: HTMLPTabsBarElement;
        new (): HTMLPTabsBarElement;
    };
    interface HTMLPTabsItemElement extends Components.PTabsItem, HTMLStencilElement {
    }
    var HTMLPTabsItemElement: {
        prototype: HTMLPTabsItemElement;
        new (): HTMLPTabsItemElement;
    };
    interface HTMLPTagElement extends Components.PTag, HTMLStencilElement {
    }
    var HTMLPTagElement: {
        prototype: HTMLPTagElement;
        new (): HTMLPTagElement;
    };
    interface HTMLPTagDismissibleElement extends Components.PTagDismissible, HTMLStencilElement {
    }
    var HTMLPTagDismissibleElement: {
        prototype: HTMLPTagDismissibleElement;
        new (): HTMLPTagDismissibleElement;
    };
    interface HTMLPTextElement extends Components.PText, HTMLStencilElement {
    }
    var HTMLPTextElement: {
        prototype: HTMLPTextElement;
        new (): HTMLPTextElement;
    };
    interface HTMLPTextListElement extends Components.PTextList, HTMLStencilElement {
    }
    var HTMLPTextListElement: {
        prototype: HTMLPTextListElement;
        new (): HTMLPTextListElement;
    };
    interface HTMLPTextListItemElement extends Components.PTextListItem, HTMLStencilElement {
    }
    var HTMLPTextListItemElement: {
        prototype: HTMLPTextListItemElement;
        new (): HTMLPTextListItemElement;
    };
    interface HTMLPTextareaElementEventMap {
        "change": TextareaChangeEventDetail;
        "blur": TextareaBlurEventDetail;
        "input": TextareaInputEventDetail;
    }
    interface HTMLPTextareaElement extends Components.PTextarea, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPTextareaElementEventMap>(type: K, listener: (this: HTMLPTextareaElement, ev: PTextareaCustomEvent<HTMLPTextareaElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPTextareaElementEventMap>(type: K, listener: (this: HTMLPTextareaElement, ev: PTextareaCustomEvent<HTMLPTextareaElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPTextareaElement: {
        prototype: HTMLPTextareaElement;
        new (): HTMLPTextareaElement;
    };
    interface HTMLPToastElement extends Components.PToast, HTMLStencilElement {
    }
    var HTMLPToastElement: {
        prototype: HTMLPToastElement;
        new (): HTMLPToastElement;
    };
    interface HTMLPToastItemElementEventMap {
        "dismiss": void;
    }
    interface HTMLPToastItemElement extends Components.PToastItem, HTMLStencilElement {
        addEventListener<K extends keyof HTMLPToastItemElementEventMap>(type: K, listener: (this: HTMLPToastItemElement, ev: PToastItemCustomEvent<HTMLPToastItemElementEventMap[K]>) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | AddEventListenerOptions): void;
        addEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | AddEventListenerOptions): void;
        removeEventListener<K extends keyof HTMLPToastItemElementEventMap>(type: K, listener: (this: HTMLPToastItemElement, ev: PToastItemCustomEvent<HTMLPToastItemElementEventMap[K]>) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof DocumentEventMap>(type: K, listener: (this: Document, ev: DocumentEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener<K extends keyof HTMLElementEventMap>(type: K, listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any, options?: boolean | EventListenerOptions): void;
        removeEventListener(type: string, listener: EventListenerOrEventListenerObject, options?: boolean | EventListenerOptions): void;
    }
    var HTMLPToastItemElement: {
        prototype: HTMLPToastItemElement;
        new (): HTMLPToastItemElement;
    };
    interface HTMLPWordmarkElement extends Components.PWordmark, HTMLStencilElement {
    }
    var HTMLPWordmarkElement: {
        prototype: HTMLPWordmarkElement;
        new (): HTMLPWordmarkElement;
    };
    interface HTMLElementTagNameMap {
        "p-accordion": HTMLPAccordionElement;
        "p-banner": HTMLPBannerElement;
        "p-button": HTMLPButtonElement;
        "p-button-pure": HTMLPButtonPureElement;
        "p-button-tile": HTMLPButtonTileElement;
        "p-canvas": HTMLPCanvasElement;
        "p-carousel": HTMLPCarouselElement;
        "p-checkbox": HTMLPCheckboxElement;
        "p-crest": HTMLPCrestElement;
        "p-display": HTMLPDisplayElement;
        "p-divider": HTMLPDividerElement;
        "p-drilldown": HTMLPDrilldownElement;
        "p-drilldown-item": HTMLPDrilldownItemElement;
        "p-drilldown-link": HTMLPDrilldownLinkElement;
        "p-fieldset": HTMLPFieldsetElement;
        "p-flag": HTMLPFlagElement;
        "p-flyout": HTMLPFlyoutElement;
        "p-heading": HTMLPHeadingElement;
        "p-icon": HTMLPIconElement;
        "p-inline-notification": HTMLPInlineNotificationElement;
        "p-input-date": HTMLPInputDateElement;
        "p-input-email": HTMLPInputEmailElement;
        "p-input-month": HTMLPInputMonthElement;
        "p-input-number": HTMLPInputNumberElement;
        "p-input-password": HTMLPInputPasswordElement;
        "p-input-search": HTMLPInputSearchElement;
        "p-input-tel": HTMLPInputTelElement;
        "p-input-text": HTMLPInputTextElement;
        "p-input-time": HTMLPInputTimeElement;
        "p-input-url": HTMLPInputUrlElement;
        "p-input-week": HTMLPInputWeekElement;
        "p-link": HTMLPLinkElement;
        "p-link-pure": HTMLPLinkPureElement;
        "p-link-tile": HTMLPLinkTileElement;
        "p-link-tile-product": HTMLPLinkTileProductElement;
        "p-modal": HTMLPModalElement;
        "p-model-signature": HTMLPModelSignatureElement;
        "p-multi-select": HTMLPMultiSelectElement;
        "p-multi-select-option": HTMLPMultiSelectOptionElement;
        "p-optgroup": HTMLPOptgroupElement;
        "p-pagination": HTMLPPaginationElement;
        "p-pin-code": HTMLPPinCodeElement;
        "p-popover": HTMLPPopoverElement;
        "p-radio-group": HTMLPRadioGroupElement;
        "p-radio-group-option": HTMLPRadioGroupOptionElement;
        "p-scroller": HTMLPScrollerElement;
        "p-segmented-control": HTMLPSegmentedControlElement;
        "p-segmented-control-item": HTMLPSegmentedControlItemElement;
        "p-select": HTMLPSelectElement;
        "p-select-option": HTMLPSelectOptionElement;
        "p-sheet": HTMLPSheetElement;
        "p-spinner": HTMLPSpinnerElement;
        "p-stepper-horizontal": HTMLPStepperHorizontalElement;
        "p-stepper-horizontal-item": HTMLPStepperHorizontalItemElement;
        "p-switch": HTMLPSwitchElement;
        "p-table": HTMLPTableElement;
        "p-table-body": HTMLPTableBodyElement;
        "p-table-cell": HTMLPTableCellElement;
        "p-table-head": HTMLPTableHeadElement;
        "p-table-head-cell": HTMLPTableHeadCellElement;
        "p-table-head-row": HTMLPTableHeadRowElement;
        "p-table-row": HTMLPTableRowElement;
        "p-tabs": HTMLPTabsElement;
        "p-tabs-bar": HTMLPTabsBarElement;
        "p-tabs-item": HTMLPTabsItemElement;
        "p-tag": HTMLPTagElement;
        "p-tag-dismissible": HTMLPTagDismissibleElement;
        "p-text": HTMLPTextElement;
        "p-text-list": HTMLPTextListElement;
        "p-text-list-item": HTMLPTextListItemElement;
        "p-textarea": HTMLPTextareaElement;
        "p-toast": HTMLPToastElement;
        "p-toast-item": HTMLPToastItemElement;
        "p-wordmark": HTMLPWordmarkElement;
    }
}
declare namespace LocalJSX {
    /**
     * @controlled {"props": ["open"], "event": "update"}
     */
    interface PAccordion {
        /**
          * Aligns the icon within the summary section.
         */
        "alignIcon"?: AccordionAlignIcon;
        /**
          * Defines the background color
         */
        "background"?: AccordionBackground;
        /**
          * Displays the Accordion as compact version.
         */
        "compact"?: boolean;
        /**
          * Emitted when accordion state is changed.
         */
        "onUpdate"?: (event: PAccordionCustomEvent<AccordionUpdateEventDetail>) => void;
        /**
          * Sets the open/closed state of the Accordion.
         */
        "open"?: boolean;
        /**
          * @experimental Sticks the Accordion heading at the top, fixed while scrolling
         */
        "sticky"?: boolean;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PBanner {
        /**
          * Description of the banner.
         */
        "description"?: string;
        /**
          * If false, the banner will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the banner.
         */
        "heading"?: string;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
         */
        "headingTag"?: BannerHeadingTag;
        /**
          * Emitted when the close button is clicked.
         */
        "onDismiss"?: (event: PBannerCustomEvent<void>) => void;
        /**
          * If true, the banner is open.
         */
        "open"?: boolean;
        /**
          * State of the banner.
         */
        "state"?: BannerState;
    }
    interface PButton {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonAriaAttribute>;
        /**
          * Displays as compact version.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the button should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: ButtonIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * The name of the button, submitted as a pair with the button's value as part of the form data, when that button is used to submit the form.
         */
        "name"?: string;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonType;
        /**
          * Defines the value associated with the button's name when it's submitted with the form data. This value is passed to the server in params when the form is submitted using this button.
         */
        "value"?: string;
        /**
          * The style variant of the button.
         */
        "variant"?: ButtonVariant;
    }
    interface PButtonPure {
        /**
          * Display button in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<ButtonPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonPureAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the button should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The icon shown.
         */
        "icon"?: ButtonPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Disables the button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * The name of the button, submitted as a pair with the button's value as part of the form data, when that button is used to submit the form.
         */
        "name"?: string;
        /**
          * Size of the button.
         */
        "size"?: BreakpointCustomizable<ButtonPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonPureType;
        /**
          * Shows an underline under the label.
         */
        "underline"?: boolean;
        /**
          * Defines the value associated with the button's name when it's submitted with the form data. This value is passed to the server in params when the form is submitted using this button.
         */
        "value"?: string;
    }
    interface PButtonTile {
        /**
          * Alignment of button and description.
         */
        "align"?: ButtonTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ButtonTileAriaAttribute>;
        /**
          * Aspect ratio of the button-tile.
         */
        "aspectRatio"?: BreakpointCustomizable<ButtonTileAspectRatio>;
        /**
          * Displays the button-tile as compact version with description and button icon only.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description"?: string;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show gradient.
         */
        "gradient"?: boolean;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: ButtonTileIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Label of the button.
         */
        "label"?: string;
        /**
          * Disables the button-tile and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Font size of the description.
         */
        "size"?: BreakpointCustomizable<ButtonTileSize>;
        /**
          * Specifies the type of the button.
         */
        "type"?: ButtonTileType;
        /**
          * Font weight of the description.
         */
        "weight"?: BreakpointCustomizable<ButtonTileWeight>;
    }
    /**
     * @experimental 
     */
    interface PCanvas {
        /**
          * Defines the background color of the main section and auto adjust it for the sidebar
         */
        "background"?: CanvasBackground;
        /**
          * Emitted when the sidebar end requests to be dismissed.
         */
        "onSidebarEndDismiss"?: (event: PCanvasCustomEvent<void>) => void;
        /**
          * Emitted when the sidebar start requests to be opened or dismissed.
         */
        "onSidebarStartUpdate"?: (event: PCanvasCustomEvent<CanvasSidebarStartUpdateEventDetail>) => void;
        /**
          * Open the sidebar on the end side
         */
        "sidebarEndOpen"?: boolean;
        /**
          * Open the sidebar on the start side
         */
        "sidebarStartOpen"?: boolean;
    }
    /**
     * @controlled { "props": ["activeSlideIndex"], "event": "update", "isInternallyMutated": true }
     */
    interface PCarousel {
        /**
          * Defines which slide to be active (zero-based numbering).
         */
        "activeSlideIndex"?: number;
        /**
          * Alignment of slotted controls
         */
        "alignControls"?: CarouselAlignControls;
        /**
          * Alignment of heading and description
         */
        "alignHeader"?: CarouselAlignHeader;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<CarouselAriaAttribute>;
        /**
          * Defines the description used in the carousel.
         */
        "description"?: string;
        /**
          * Indicates whether focus should be set on the center slide. If true, the carousel loops by individual slide; otherwise, it loops by page.
         */
        "focusOnCenterSlide"?: boolean;
        /**
          * Fades the slides out.
         */
        "gradient"?: boolean;
        /**
          * Defines the heading used in the carousel.
         */
        "heading"?: string;
        /**
          * Defines the heading size used in the carousel.
         */
        "headingSize"?: CarouselHeadingSize;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev buttons and pagination.
         */
        "intl"?: CarouselInternationalization;
        /**
          * Emitted when carousel's content slides.
         */
        "onUpdate"?: (event: PCarouselCustomEvent<CarouselUpdateEventDetail>) => void;
        /**
          * If false, the carousel will not show pagination bullets at the bottom.
         */
        "pagination"?: BreakpointCustomizable<boolean>;
        /**
          * Whether the slides should rewind from last to first slide and vice versa.
         */
        "rewind"?: boolean;
        /**
          * Defines target of skip link (to skip carousel entries).
         */
        "skipLinkTarget"?: string;
        /**
          * Sets the amount of slides visible at the same time. Can be set to `auto` if you want to define different widths per slide via CSS.
         */
        "slidesPerPage"?: BreakpointCustomizable<CarouselSlidesPerPage>;
        /**
          * Determines whether to trim spaces before/after the carousel if `focusOnCenterSlide` option is true.
         */
        "trimSpace"?: boolean;
        /**
          * Defines the outer spacings between the carousel and the left and right screen sides.
         */
        "width"?: CarouselWidth;
    }
    interface PCheckbox {
        /**
          * Reflects the checkbox current checked state and allows setting the initial checked state.
         */
        "checked"?: boolean;
        /**
          * Displays as a compact version.
         */
        "compact"?: boolean;
        /**
          * Marks the checkbox as disabled.
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the checkbox should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility, it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Marks the checkbox as indeterminate.
         */
        "indeterminate"?: boolean;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * @experimental Disables the checkbox and shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The name of the checkbox.
         */
        "name"?: string;
        /**
          * Emitted when the checkbox has lost focus.
         */
        "onBlur"?: (event: PCheckboxCustomEvent<CheckboxBlurEventDetail>) => void;
        /**
          * Emitted when checkbox checked property is changed.
         */
        "onChange"?: (event: PCheckboxCustomEvent<CheckboxChangeEventDetail>) => void;
        /**
          * Marks the checkbox as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: CheckboxState;
        /**
          * The checkbox value. When a form is submitted, only a checkbox which is currently checked is included in the submission.
         */
        "value"?: string;
    }
    interface PCrest {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<CrestAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: CrestTarget;
    }
    interface PDisplay {
        /**
          * Text alignment of the component.
         */
        "align"?: DisplayAlign;
        /**
          * Basic text color variations.
         */
        "color"?: DisplayColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "medium", l: "large"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<DisplaySize>;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
         */
        "tag"?: DisplayTag;
    }
    interface PDivider {
        /**
          * Defines color.
         */
        "color"?: DividerColor;
        /**
          * Defines direction.
         */
        "direction"?: BreakpointCustomizable<DividerDirection>;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     * @controlled {"props": ["activeIdentifier"], "event": "update"}
     * @experimental 
     */
    interface PDrilldown {
        /**
          * Defines which drilldown-item to be visualized as opened.
         */
        "activeIdentifier"?: string | undefined;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<DrilldownAriaAttribute>;
        /**
          * Emitted when the component requests to be dismissed.
         */
        "onDismiss"?: (event: PDrilldownCustomEvent<void>) => void;
        /**
          * Emitted when activeIdentifier is changed.
         */
        "onUpdate"?: (event: PDrilldownCustomEvent<DrilldownUpdateEventDetail>) => void;
        /**
          * If true, the drilldown is visualized as opened.
         */
        "open"?: boolean;
    }
    /**
     * @experimental 
     */
    interface PDrilldownItem {
        /**
          * Private property set by the component itself.
         */
        "cascade"?: boolean;
        /**
          * Unique identifier which controls if this item should be shown when the active-identifier on the drilldown is set to this value.
         */
        "identifier"?: string;
        /**
          * Renders back button, header section on mobile view and cascade button to reach a deeper level of the navigation structure.
         */
        "label"?: string;
        /**
          * Private property set by the component itself.
         */
        "primary"?: boolean;
        /**
          * Private property set by the component itself.
         */
        "secondary"?: boolean;
    }
    /**
     * @experimental 
     */
    interface PDrilldownLink {
        /**
          * Display link in active state.
         */
        "active"?: boolean;
        /**
          * Add ARIA attributes (only has effect when `href` is defined and no slotted anchor is used).
         */
        "aria"?: SelectedAriaAttributes<DrilldownLinkAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file (only has effect when `href` is defined and no slotted anchor is used).
         */
        "download"?: string;
        /**
          * When providing an url then the component will be rendered as `<a>` otherwise the component expects a slotted anchor.
         */
        "href"?: string;
        /**
          * Specifies the relationship of the target object to the link object (only has effect when `href` is defined and no slotted anchor is used).
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened (only has effect when `href` is defined and no slotted anchor is used).
         */
        "target"?: DrilldownLinkTarget;
    }
    interface PFieldset {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaRole<'radiogroup'>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The size of the label text.
         */
        "labelSize"?: FieldsetLabelSize;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Marks the Fieldset as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: FieldsetState;
    }
    interface PFlag {
        /**
          * A map of ARIA attributes to enhance the flag's accessibility. For example, use `{ 'aria-label': 'German flag' }` to provide a descriptive label for screen readers.
         */
        "aria"?: SelectedAriaAttributes<FlagAriaAttribute>;
        /**
          * Specifies the country flag to display. Use the two-letter ISO 3166-1 alpha-2 country code. For example, use `us` for the United States, `de` for Germany, `gb` for Great Britain.
         */
        "name"?: FlagName;
        /**
          * The size of the flag. Pre-defined sizes are aligned with the Porsche Next typescale. Available values are `small`, `medium`, `large`, etc.
         */
        "size"?: FlagSize;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PFlyout {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<FlyoutAriaAttribute>;
        /**
          * Defines the backdrop, 'blur' (should be used when the underlying content is not relevant for users) and 'shading' (should be used when the user still needs a visual connection to the underlying content).
         */
        "backdrop"?: FlyoutBackdrop;
        /**
          * Defines the background color
         */
        "background"?: FlyoutBackground;
        /**
          * If true, the flyout will not be closable via backdrop click.
         */
        "disableBackdropClick"?: boolean;
        /**
          * Determines the footer's position behavior. When set to "fixed," the flyout content stretches to fill the full height, keeping the footer permanently at the bottom. When set to "sticky," the footer flows beneath the content and only becomes fixed if the content overflows.
         */
        "footerBehavior"?: FlyoutFooterBehavior;
        /**
          * Emitted when the component requests to be dismissed.
         */
        "onDismiss"?: (event: PFlyoutCustomEvent<void>) => void;
        /**
          * Emitted when the flyout is closed and the transition is finished.
         */
        "onMotionHiddenEnd"?: (event: PFlyoutCustomEvent<FlyoutMotionHiddenEndEventDetail>) => void;
        /**
          * Emitted when the flyout is opened and the transition is finished.
         */
        "onMotionVisibleEnd"?: (event: PFlyoutCustomEvent<FlyoutMotionVisibleEndEventDetail>) => void;
        /**
          * If true, the flyout is open.
         */
        "open"?: boolean;
        /**
          * The position of the flyout
         */
        "position"?: FlyoutPosition;
    }
    interface PHeading {
        /**
          * Text alignment of the component.
         */
        "align"?: HeadingAlign;
        /**
          * Basic text color variations.
         */
        "color"?: HeadingColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the component. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<HeadingSize>;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
         */
        "tag"?: HeadingTag;
    }
    interface PIcon {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<IconAriaAttribute>;
        /**
          * Basic color variations.
         */
        "color"?: IconColor;
        /**
          * Specifies which icon to use.
         */
        "name"?: IconName;
        /**
          * The size of the icon.
         */
        "size"?: IconSize;
        /**
          * Specifies a whole icon path which can be used for custom icons.
         */
        "source"?: string;
    }
    interface PInlineNotification {
        /**
          * Action icon of the inline-notification.
         */
        "actionIcon"?: InlineNotificationActionIcon;
        /**
          * Action label of the inline-notification.
         */
        "actionLabel"?: string;
        /**
          * Disables the action button and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "actionLoading"?: boolean;
        /**
          * Description of the inline-notification.
         */
        "description"?: string;
        /**
          * If false, the inline-notification will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * Heading of the inline-notification.
         */
        "heading"?: string;
        /**
          * Sets a heading tag, so it fits correctly within the outline of the page.
         */
        "headingTag"?: InlineNotificationHeadingTag;
        /**
          * Emitted when the action button is clicked.
         */
        "onAction"?: (event: PInlineNotificationCustomEvent<void>) => void;
        /**
          * Emitted when the close button is clicked.
         */
        "onDismiss"?: (event: PInlineNotificationCustomEvent<void>) => void;
        /**
          * State of the inline-notification.
         */
        "state"?: InlineNotificationState;
    }
    interface PInputDate {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., auto-complete='bday' for a birthday).
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * Specifies the latest date that can be selected. The value must be a date string in YYYY-MM-DD format (e.g., max='2024-12-31').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * Specifies the earliest date that can be selected. The value must be a date string in YYYY-MM-DD format (e.g., min='2023-01-01').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the number input has lost focus.
         */
        "onBlur"?: (event: PInputDateCustomEvent<InputDateBlurEventDetail>) => void;
        /**
          * Emitted when the number input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputDateCustomEvent<InputDateChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputDateCustomEvent<InputDateInputEventDetail>) => void;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputDateState;
        /**
          * Defines the granularity of the date input. This value is given in days. The default is 1 (one day).
         */
        "step"?: number;
        /**
          * The default date value for the input, in YYYY-MM-DD format (e.g., value='2025-07-02').
         */
        "value"?: string;
    }
    interface PInputEmail {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='email').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Controls the visibility of the email icon.
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * A boolean value that, if present, it allows the user to enter a list of multiple email addresses, separated by commas (and optional whitespace). The browser will validate each email address in the list.
         */
        "multiple"?: boolean;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the email input has lost focus.
         */
        "onBlur"?: (event: PInputEmailCustomEvent<InputEmailBlurEventDetail>) => void;
        /**
          * Emitted when the email input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputEmailCustomEvent<InputEmailChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputEmailCustomEvent<InputEmailInputEventDetail>) => void;
        /**
          * Specifies a regular expression that the input's value must match for the value to pass constraint validation. This allows for more specific email validation rules than the browser's default (e.g., restricting to a specific domain). If provided, it overrides the browser's default email validation.
         */
        "pattern"?: string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='you@example.com'). This text is displayed when the input field is empty.
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputEmailState;
        /**
          * The default email address (or comma-separated list of addresses) for the input.
         */
        "value"?: string;
    }
    interface PInputMonth {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features.
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * Specifies the latest month that can be selected. The value must be a month string in YYYY-MM format(e.g., max='2024-12').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * Specifies the earliest month that can be selected. The value must be a month string in YYYY-MM format (e.g., min='2023-01').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the number input has lost focus.
         */
        "onBlur"?: (event: PInputMonthCustomEvent<InputMonthBlurEventDetail>) => void;
        /**
          * Emitted when the number input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputMonthCustomEvent<InputMonthChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputMonthCustomEvent<InputMonthInputEventDetail>) => void;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputMonthState;
        /**
          * Defines the stepping interval in months. For example, step="1" increments by 1 month, step="12" by 1 year. The default is 1 month.
         */
        "step"?: number;
        /**
          * The default month value for the input, in YYYY-MM format (e.g., value='2025-07').
         */
        "value"?: string;
    }
    interface PInputNumber {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='postal-code').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Show or hide the increment/decrement stepper controls.
         */
        "controls"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * The max value of the number input.
         */
        "max"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * The min value of the number input.
         */
        "min"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the number input has lost focus.
         */
        "onBlur"?: (event: PInputNumberCustomEvent<InputNumberBlurEventDetail>) => void;
        /**
          * Emitted when the number input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputNumberCustomEvent<InputNumberChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputNumberCustomEvent<InputNumberInputEventDetail>) => void;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Enter a number'). This text is displayed when the input field is empty.
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputNumberState;
        /**
          * The granularity that the value must adhere to.
         */
        "step"?: number;
        /**
          * The number input value.
         */
        "value"?: string;
    }
    interface PInputPassword {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='current-password', autocomplete='new-password').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the password input has lost focus.
         */
        "onBlur"?: (event: PInputPasswordCustomEvent<InputPasswordBlurEventDetail>) => void;
        /**
          * Emitted when the password input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputPasswordCustomEvent<InputPasswordChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputPasswordCustomEvent<InputPasswordInputEventDetail>) => void;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Enter your password'). This text is displayed when the input field is empty.
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputPasswordState;
        /**
          * Show or hide password toggle for `input type="password"`.
         */
        "toggle"?: boolean;
        /**
          * The password input value.
         */
        "value"?: string;
    }
    interface PInputSearch {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='on').
         */
        "autoComplete"?: string;
        /**
          * Show clear input value button
         */
        "clear"?: boolean;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Show search indicator icon
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the search input has lost focus.
         */
        "onBlur"?: (event: PInputSearchCustomEvent<InputSearchBlurEventDetail>) => void;
        /**
          * Emitted when the search input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputSearchCustomEvent<InputSearchChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputSearchCustomEvent<InputSearchInputEventDetail>) => void;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Search...'). This text is displayed when the input field is empty.
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputSearchState;
        /**
          * The search input value.
         */
        "value"?: string;
    }
    interface PInputTel {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='tel').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Controls the visibility of the phone icon.
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the tel input has lost focus.
         */
        "onBlur"?: (event: PInputTelCustomEvent<InputTelBlurEventDetail>) => void;
        /**
          * Emitted when the tel input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputTelCustomEvent<InputTelChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputTelCustomEvent<InputTelInputEventDetail>) => void;
        /**
          * Specifies a regular expression that the input's value must match for the value to pass constraint validation. This allows for more specific tel validation rules than the browser's default. If provided, it overrides the browser's default tel validation.
         */
        "pattern"?: string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='(123) 456-7890')
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputTelState;
        /**
          * The tel input value.
         */
        "value"?: string;
    }
    interface PInputText {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='name').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Show or hide the character counter.
         */
        "counter"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the text input has lost focus.
         */
        "onBlur"?: (event: PInputTextCustomEvent<InputTextBlurEventDetail>) => void;
        /**
          * Emitted when the text input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputTextCustomEvent<InputTextChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputTextCustomEvent<InputTextInputEventDetail>) => void;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Enter your full name'). This text is displayed when the input field is empty.
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicate whether to enable spell-checking.
         */
        "spellCheck"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputTextState;
        /**
          * The text input value.
         */
        "value"?: string;
    }
    interface PInputTime {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., auto-complete='on').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * Specifies the latest time that can be selected. The value must be a time string in hh:mm or hh:mm:ss format (e.g., max='17:30').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * Specifies the earliest time that can be selected. The value must be a time string in hh:mm or hh:mm:ss format (e.g., min='09:00').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the number input has lost focus.
         */
        "onBlur"?: (event: PInputTimeCustomEvent<InputTimeBlurEventDetail>) => void;
        /**
          * Emitted when the number input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputTimeCustomEvent<InputTimeChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputTimeCustomEvent<InputTimeInputEventDetail>) => void;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputTimeState;
        /**
          * efines the granularity of the time input. The step value is given in seconds. The default is 60 (one minute). You can also specify smaller increments (e.g., step='1' for seconds, step='0.001' for milliseconds).
         */
        "step"?: number;
        /**
          * The default time value for the input, in hh:mm or hh:mm:ss format (e.g., value='14:00').
         */
        "value"?: string;
    }
    interface PInputUrl {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='url').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Controls the visibility of the url icon.
         */
        "indicator"?: boolean;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the input.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the input's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the url input has lost focus.
         */
        "onBlur"?: (event: PInputUrlCustomEvent<InputUrlBlurEventDetail>) => void;
        /**
          * Emitted when the url input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputUrlCustomEvent<InputUrlChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputUrlCustomEvent<InputUrlInputEventDetail>) => void;
        /**
          * Specifies a regular expression that the input's value must match for the value to pass constraint validation. This allows for more specific url validation rules than the browser's default. If provided, it overrides the browser's default tel validation.
         */
        "pattern"?: string;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='https://porsche.com/')
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputUrlState;
        /**
          * The url input value.
         */
        "value"?: string;
    }
    interface PInputWeek {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features.
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the input field as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the input.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the input field unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the input belongs to (useful if the input is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * Specifies the latest week that can be selected. The value must be a week string in YYYY-Www format (e.g., max='2024-W52').
         */
        "max"?: string;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * Specifies the earliest week that can be selected. The value must be a week string in YYYY-Www format (e.g., min='2024-W01').
         */
        "min"?: string;
        /**
          * The name of the input field, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the number input has lost focus.
         */
        "onBlur"?: (event: PInputWeekCustomEvent<InputWeekBlurEventDetail>) => void;
        /**
          * Emitted when the number input loses focus after its value was changed.
         */
        "onChange"?: (event: PInputWeekCustomEvent<InputWeekChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PInputWeekCustomEvent<InputWeekInputEventDetail>) => void;
        /**
          * A boolean value that, if present, makes the input field uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the input field must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the input component.
         */
        "state"?: InputWeekState;
        /**
          * Defines the stepping interval in weeks. For example, step="1" increments by 1 week. The default is 1 month.
         */
        "step"?: number;
        /**
          * The default week value for the input, in YYYY-Www format (e.g., value='2025-W27')
         */
        "value"?: string;
    }
    interface PLink {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkAriaAttribute>;
        /**
          * Displays as compact version.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed.
         */
        "icon"?: LinkIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTarget;
        /**
          * The style variant of the link.
         */
        "variant"?: LinkVariant;
    }
    interface PLinkPure {
        /**
          * Display link in active state.
         */
        "active"?: boolean;
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<LinkPureAlignLabel>;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkPureAriaAttribute>;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * The icon shown. By choosing 'none', no icon is displayed
         */
        "icon"?: LinkPureIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Size of the link.
         */
        "size"?: BreakpointCustomizable<LinkPureSize>;
        /**
          * Stretches the area between icon and label to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkPureTarget;
        /**
          * Shows an underline under the label.
         */
        "underline"?: boolean;
    }
    interface PLinkTile {
        /**
          * Alignment of link and description.
         */
        "align"?: LinkTileAlign;
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<LinkTileAriaAttribute>;
        /**
          * Aspect ratio of the link-tile.
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileAspectRatio>;
        /**
          * Displays the link-tile as compact version with description and link icon only.
         */
        "compact"?: BreakpointCustomizable<boolean>;
        /**
          * Description text.
         */
        "description"?: string;
        /**
          * Special download attribute to open native browser download dialog if target url points to a downloadable file.
         */
        "download"?: string;
        /**
          * Show gradient.
         */
        "gradient"?: boolean;
        /**
          * href of the `<a>`.
         */
        "href"?: string;
        /**
          * Label of the <a />.
         */
        "label"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Font size of the description.
         */
        "size"?: BreakpointCustomizable<LinkTileSize>;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTileTarget;
        /**
          * Font weight of the description.
         */
        "weight"?: BreakpointCustomizable<LinkTileWeight>;
    }
    /**
     * @controlled {"props": ["liked"], "event": "like"}
     * @experimental 
     */
    interface PLinkTileProduct {
        /**
          * Aspect ratio of the link-tile-product.
         */
        "aspectRatio"?: BreakpointCustomizable<LinkTileProductAspectRatio>;
        /**
          * Additional product description.
         */
        "description"?: string;
        /**
          * Product heading.
         */
        "heading"?: string;
        /**
          * href of the `<a>`.
         */
        "href"?: string;
        /**
          * A Boolean attribute indicating that a like button should be shown.
         */
        "likeButton"?: boolean;
        /**
          * A Boolean attribute indicating that a product is liked.
         */
        "liked"?: boolean;
        /**
          * Emitted when the like button is clicked.
         */
        "onLike"?: (event: PLinkTileProductCustomEvent<LinkTileProductLikeEventDetail>) => void;
        /**
          * Product retail price (with or without discount).
         */
        "price"?: string;
        /**
          * Shows original price (recommended retail price) with line-through. Needs prop "price" to be defined, otherwise this prop has no effect.
         */
        "priceOriginal"?: string;
        /**
          * Specifies the relationship of the target object to the link object.
         */
        "rel"?: string;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: LinkTileProductTarget;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PModal {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<ModalAriaAttribute>;
        /**
          * Defines the backdrop, 'blur' (should be used when Modal is opened by user interaction, e.g. after a click on a button) and 'shading' (should be used when Modal gets opened automatically, e.g. Cookie Consent).
         */
        "backdrop"?: ModalBackdrop;
        /**
          * Defines the background color
         */
        "background"?: ModalBackground;
        /**
          * If true, the modal will not be closable via backdrop click.
         */
        "disableBackdropClick"?: boolean;
        /**
          * If false, the modal will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * If true the modal uses max viewport height and width. Should only be used for mobile.
         */
        "fullscreen"?: BreakpointCustomizable<boolean>;
        /**
          * Emitted when the component requests to be dismissed.
         */
        "onDismiss"?: (event: PModalCustomEvent<void>) => void;
        /**
          * Emitted when the modal is closed and the transition is finished.
         */
        "onMotionHiddenEnd"?: (event: PModalCustomEvent<ModalMotionHiddenEndEventDetail>) => void;
        /**
          * Emitted when the modal is opened and the transition is finished.
         */
        "onMotionVisibleEnd"?: (event: PModalCustomEvent<ModalMotionVisibleEndEventDetail>) => void;
        /**
          * If true, the modal is open.
         */
        "open"?: boolean;
    }
    interface PModelSignature {
        /**
          * Adapts the color of the component.
         */
        "color"?: ModelSignatureColor;
        /**
          * Defines the fetch priority of the model signature. In the end it is just a recommendation to the browser, but it defines the priority on its own.
         */
        "fetchPriority"?: ModelSignatureFetchPriority;
        /**
          * Defines whether the model signature is always loaded or only loaded when it is in the viewport (this feature may not work reliably).
         */
        "lazy"?: boolean;
        /**
          * Adapts the model of the component.
         */
        "model"?: ModelSignatureModel;
        /**
          * When set to `true`, then all model signatures are visually aligned with each other. When set to `false` the model signature comes without any safe zone.
         */
        "safeZone"?: boolean;
        /**
          * Adapts the size of the component. When set to `inherit` a CSS `width` or `height` needs to be defined on the host but not both.
         */
        "size"?: ModelSignatureSize;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PMultiSelect {
        /**
          * Displays as compact version.
         */
        "compact"?: boolean;
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Disables the multi-select
         */
        "disabled"?: boolean;
        /**
          * Changes the direction to which the dropdown list appears.
         */
        "dropdownDirection"?: MultiSelectDropdownDirection;
        /**
          * The id of a form element the multi-select should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The name of the control.
         */
        "name"?: string;
        /**
          * Emitted when the multi-select has lost focus.
         */
        "onBlur"?: (event: PMultiSelectCustomEvent<void>) => void;
        /**
          * Emitted when the selection is changed.
         */
        "onChange"?: (event: PMultiSelectCustomEvent<MultiSelectChangeEventDetail>) => void;
        /**
          * Emitted when the dropdown is toggled.
         */
        "onToggle"?: (event: PMultiSelectCustomEvent<MultiSelectToggleEventDetail>) => void;
        /**
          * A Boolean attribute indicating that an option with a non-empty string value must be selected.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: MultiSelectState;
        /**
          * The selected values.
         */
        "value"?: string[];
    }
    interface PMultiSelectOption {
        /**
          * Disables the option.
         */
        "disabled"?: boolean;
        /**
          * The option value.
         */
        "value"?: string;
    }
    interface POptgroup {
        /**
          * Disables the optgroup.
         */
        "disabled"?: boolean;
        /**
          * The optgroup label.
         */
        "label"?: string;
    }
    /**
     * @controlled { "props": ["activePage"], "event": "update", "isInternallyMutated": true }
     */
    interface PPagination {
        /**
          * Index of the currently active page.
         */
        "activePage"?: number;
        /**
          * Override the default wordings that are used for aria-labels on the next/prev and page buttons.
         */
        "intl"?: PaginationInternationalization;
        /**
          * The total count of items which should be shown per page.
         */
        "itemsPerPage"?: number;
        /**
          * Emitted when the page changes.
         */
        "onUpdate"?: (event: PPaginationCustomEvent<PaginationUpdateEventDetail>) => void;
        /**
          * Show or hide the button to jump to the last page.
         */
        "showLastPage"?: boolean;
        /**
          * The total count of items.
         */
        "totalItemsCount"?: number;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PPinCode {
        /**
          * A boolean value that, if present, renders the pin-code as a compact version.
         */
        "compact"?: boolean;
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Disables the Pin Code. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the pin-code should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label and description text. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * Number of characters of the Pin Code.
         */
        "length"?: PinCodeLength;
        /**
          * Disables the Pin Code and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * Name of the control.
         */
        "name"?: string;
        /**
          * Emitted when the pin-code has lost focus.
         */
        "onBlur"?: (event: PPinCodeCustomEvent<void>) => void;
        /**
          * Emitted when the input is changed.
         */
        "onChange"?: (event: PPinCodeCustomEvent<PinCodeChangeEventDetail>) => void;
        /**
          * Marks the Pin Code as required.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: PinCodeState;
        /**
          * Pin Code type.
         */
        "type"?: PinCodeType;
        /**
          * Sets the initial value of the Pin Code.
         */
        "value"?: string;
    }
    interface PPopover {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<PopoverAriaAttribute>;
        /**
          * Descriptive text to show additional information when popover is open
         */
        "description"?: string;
        /**
          * Preferred direction in which popover should open, given there is enough space in viewport. Otherwise, it will be opened in the direction with most available space.
         */
        "direction"?: PopoverDirection;
    }
    interface PRadioGroup {
        /**
          * A boolean value that, if present, renders the radio group as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the radio group.
         */
        "description"?: string;
        /**
          * Defines the direction of the main and cross axis. The default is 'column' showing options vertically stacked. You always need to provide a base value when using breakpoints.
         */
        "direction"?: BreakpointCustomizable<RadioGroupDirection>;
        /**
          * A boolean value that, if present, makes the radio group unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the radio group belongs to (useful if the radio group is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * The name of the group of radio buttons, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the radio-group has lost focus.
         */
        "onBlur"?: (event: PRadioGroupCustomEvent<void>) => void;
        /**
          * Emitted when the selected option is changed.
         */
        "onChange"?: (event: PRadioGroupCustomEvent<RadioGroupChangeEventDetail>) => void;
        /**
          * A boolean value that specifies a selection must be made from the group before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the radio group component.
         */
        "state"?: RadioGroupState;
        /**
          * The default value for the radio-group.
         */
        "value"?: string;
    }
    interface PRadioGroupOption {
        /**
          * A boolean value that, if present, makes the radio group option unusable and unclickable.
         */
        "disabled"?: boolean;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * @experimental Shows a loading indicator.
         */
        "loading"?: boolean;
        /**
          * The value for the input.
         */
        "value"?: string;
    }
    interface PScroller {
        /**
          * Sets the vertical position of scroll indicator.
         */
        "alignScrollIndicator"?: ScrollerAlignScrollIndicator;
        /**
          * Add ARIA role.
         */
        "aria"?: SelectedAriaAttributes<ScrollerAriaAttribute>;
        /**
          * Scrolls the scroll area to the left either smooth or immediately.
         */
        "scrollToPosition"?: ScrollerScrollToPosition;
        /**
          * Specifies if scrollbar should be shown.
         */
        "scrollbar"?: boolean;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PSegmentedControl {
        /**
          * Sets the amount of columns.
         */
        "columns"?: BreakpointCustomizable<SegmentedControlColumns>;
        /**
          * A boolean value that, if present, renders the segmented-control as a compact version.
         */
        "compact"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the segmented-control.
         */
        "description"?: string;
        /**
          * Disables the segmented-control.
         */
        "disabled"?: boolean;
        /**
          * The id of a form element the segmented-control should be associated with.
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * The name of the segmented-control.
         */
        "name"?: string;
        /**
          * Emitted when the segmented-control has lost focus.
         */
        "onBlur"?: (event: PSegmentedControlCustomEvent<void>) => void;
        /**
          * Emitted when the selection is changed.
         */
        "onChange"?: (event: PSegmentedControlCustomEvent<SegmentedControlChangeEventDetail>) => void;
        /**
          * A boolean value that specifies a selection must be made from the group before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Indicates the validation or overall status of the component.
         */
        "state"?: SegmentedControlState;
        /**
          * Sets the initial value of the segmented-control.
         */
        "value"?: string | number;
    }
    interface PSegmentedControlItem {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SegmentedControlItemAriaAttribute>;
        /**
          * Disables the button. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The icon shown.
         */
        "icon"?: SegmentedControlItemIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The value of this item which is emitted by the parent element if it becomes selected. This property is **required**.
         */
        "value"?: string | number;
    }
    /**
     * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
     */
    interface PSelect {
        /**
          * Displays as compact version.
         */
        "compact"?: boolean;
        /**
          * The description text.
         */
        "description"?: string;
        /**
          * Disables the select.
         */
        "disabled"?: boolean;
        /**
          * Changes the direction to which the dropdown list appears.
         */
        "dropdownDirection"?: SelectDropdownDirection;
        /**
          * Shows an input in the dropdown allowing options to be filtered. Will be ignored if the `filter` slot is used.
         */
        "filter"?: boolean;
        /**
          * The id of a form element the select should be associated with.
         */
        "form"?: string;
        /**
          * Show or hide label. For better accessibility it is recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * The label text.
         */
        "label"?: string;
        /**
          * The message styled depending on validation state.
         */
        "message"?: string;
        /**
          * The name of the control.
         */
        "name"?: string;
        /**
          * Emitted when the select has lost focus.
         */
        "onBlur"?: (event: PSelectCustomEvent<void>) => void;
        /**
          * Emitted when the selection is changed.
         */
        "onChange"?: (event: PSelectCustomEvent<SelectChangeEventDetail>) => void;
        /**
          * Emitted when the dropdown is toggled.
         */
        "onToggle"?: (event: PSelectCustomEvent<SelectToggleEventDetail>) => void;
        /**
          * A Boolean attribute indicating that an option with a non-empty string value must be selected.
         */
        "required"?: boolean;
        /**
          * The validation state.
         */
        "state"?: SelectState;
        /**
          * The selected value.
         */
        "value"?: string;
    }
    interface PSelectOption {
        /**
          * Disables the option.
         */
        "disabled"?: boolean;
        /**
          * The option value.
         */
        "value"?: string;
    }
    /**
     * @controlled {"props": ["open"], "event": "dismiss"}
     */
    interface PSheet {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SheetAriaAttribute>;
        /**
          * Defines the background color
         */
        "background"?: SheetBackground;
        /**
          * If true, the sheet will not be closable via backdrop click.
         */
        "disableBackdropClick"?: boolean;
        /**
          * If false, the sheet will not have a dismiss button.
         */
        "dismissButton"?: boolean;
        /**
          * Emitted when the component requests to be dismissed.
         */
        "onDismiss"?: (event: PSheetCustomEvent<void>) => void;
        /**
          * Emitted when the sheet is closed and the transition is finished.
         */
        "onMotionHiddenEnd"?: (event: PSheetCustomEvent<SheetMotionHiddenEndEventDetail>) => void;
        /**
          * Emitted when the sheet is opened and the transition is finished.
         */
        "onMotionVisibleEnd"?: (event: PSheetCustomEvent<SheetMotionVisibleEndEventDetail>) => void;
        /**
          * If true, the sheet is open.
         */
        "open"?: boolean;
    }
    interface PSpinner {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<SpinnerAriaAttribute>;
        /**
          * Size of the spinner.
         */
        "size"?: BreakpointCustomizable<SpinnerSize>;
    }
    interface PStepperHorizontal {
        /**
          * Emitted when active step is changed.
         */
        "onUpdate"?: (event: PStepperHorizontalCustomEvent<StepperHorizontalUpdateEventDetail>) => void;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<StepperHorizontalSize>;
    }
    interface PStepperHorizontalItem {
        /**
          * Disables the stepper-horizontal-item. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * The validation state.
         */
        "state"?: StepperHorizontalItemState;
    }
    /**
     * @controlled {"props": ["checked"], "event": "update"}
     */
    interface PSwitch {
        /**
          * Aligns the label.
         */
        "alignLabel"?: BreakpointCustomizable<SwitchAlignLabel>;
        /**
          * Visualize the switch with on/off status.
         */
        "checked"?: boolean;
        /**
          * Displays as compact version.
         */
        "compact"?: boolean;
        /**
          * Disables the switch. No events will be triggered while disabled state is active.
         */
        "disabled"?: boolean;
        /**
          * Show or hide label. For better accessibility it's recommended to show the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Disables the switch and shows a loading indicator. No events will be triggered while loading state is active.
         */
        "loading"?: boolean;
        /**
          * Emitted when checked status is changed.
         */
        "onUpdate"?: (event: PSwitchCustomEvent<SwitchUpdateEventDetail>) => void;
        /**
          * Stretches the contents to max available space.
         */
        "stretch"?: BreakpointCustomizable<boolean>;
    }
    interface PTable {
        /**
          * A caption describing the contents of the table for accessibility only. This won't be visible in the browser. Use an element with an attribute of `slot="caption"` for a visible caption.
         */
        "caption"?: string;
        /**
          * Displays as compact version.
         */
        "compact"?: boolean;
        /**
          * Controls the layout behavior of the table.
         */
        "layout"?: TableLayout;
        /**
          * Emitted when sorting is changed.
         */
        "onUpdate"?: (event: PTableCustomEvent<TableUpdateEventDetail>) => void;
    }
    interface PTableBody {
    }
    interface PTableCell {
        /**
          * Displays slotted text multiline or forced into a single line.
         */
        "multiline"?: boolean;
    }
    interface PTableHead {
    }
    interface PTableHeadCell {
        /**
          * Hides the label but stays accessible for screen readers. This property only takes effect when sort property is not defined.
         */
        "hideLabel"?: boolean;
        /**
          * Displays slotted text multiline or forced into a single line.
         */
        "multiline"?: boolean;
        /**
          * Defines sortability properties.
         */
        "sort"?: TableHeadCellSort;
    }
    interface PTableHeadRow {
    }
    interface PTableRow {
    }
    /**
     * @controlled { "props": ["activeTabIndex"], "event": "update", "isInternallyMutated": true }
     */
    interface PTabs {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering).
         */
        "activeTabIndex"?: number;
        /**
          * Emitted when active tab is changed.
         */
        "onUpdate"?: (event: PTabsCustomEvent<TabsUpdateEventDetail>) => void;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabsSize>;
        /**
          * The text weight.
         */
        "weight"?: TabsWeight;
    }
    /**
     * @controlled {"props": ["activeTabIndex"], "event": "update"}
     */
    interface PTabsBar {
        /**
          * Defines which tab to be visualized as selected (zero-based numbering), undefined if none should be selected.
         */
        "activeTabIndex"?: number | undefined;
        /**
          * Emitted when active tab is changed.
         */
        "onUpdate"?: (event: PTabsBarCustomEvent<TabsBarUpdateEventDetail>) => void;
        /**
          * The text size.
         */
        "size"?: BreakpointCustomizable<TabsBarSize>;
        /**
          * The text weight.
         */
        "weight"?: TabsBarWeight;
    }
    interface PTabsItem {
        /**
          * Defines the label used in tabs.
         */
        "label"?: string;
    }
    interface PTag {
        /**
          * Displays as compact version.
         */
        "compact"?: boolean;
        /**
          * The icon shown.
         */
        "icon"?: TagIcon;
        /**
          * A URL path to a custom icon.
         */
        "iconSource"?: string;
        /**
          * Background color variations.
         */
        "variant"?: TagVariant;
    }
    interface PTagDismissible {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<TagDismissibleAriaAttribute>;
        /**
          * A boolean value that, if present, renders the tag dismissible as a compact version.
         */
        "compact"?: boolean;
        /**
          * The label text.
         */
        "label"?: string;
    }
    interface PText {
        /**
          * Text alignment of the component.
         */
        "align"?: TextAlign;
        /**
          * Basic text color variations.
         */
        "color"?: TextColor;
        /**
          * Adds an ellipsis to a single line of text if it overflows.
         */
        "ellipsis"?: boolean;
        /**
          * Size of the text. Also defines the size for specific breakpoints, like {base: "small", l: "medium"}. You always need to provide a base value when doing this.
         */
        "size"?: BreakpointCustomizable<TextSize>;
        /**
          * Sets a custom HTML tag depending on the usage of the text component.
         */
        "tag"?: TextTag;
        /**
          * The weight of the text.
         */
        "weight"?: TextWeight;
    }
    interface PTextList {
        /**
          * The list style type.
         */
        "type"?: TextListType;
    }
    interface PTextListItem {
    }
    interface PTextarea {
        /**
          * Provides a hint to the browser about what type of data the field expects, which can assist with autofill features (e.g., autocomplete='on').
         */
        "autoComplete"?: string;
        /**
          * A boolean value that, if present, renders the textarea as a compact version.
         */
        "compact"?: boolean;
        /**
          * Show or hide the character counter.
         */
        "counter"?: boolean;
        /**
          * Supplementary text providing more context or explanation for the textarea.
         */
        "description"?: string;
        /**
          * A boolean value that, if present, makes the textarea unusable and unclickable. The value will not be submitted with the form.
         */
        "disabled"?: boolean;
        /**
          * Specifies the id of the <form> element that the textarea belongs to (useful if the textarea is not a direct descendant of the form).
         */
        "form"?: string;
        /**
          * Controls the visibility of the label.
         */
        "hideLabel"?: BreakpointCustomizable<boolean>;
        /**
          * Text content for a user-facing label.
         */
        "label"?: string;
        /**
          * A non-negative integer specifying the maximum number of characters the user can enter into the textarea.
         */
        "maxLength"?: number;
        /**
          * Dynamic feedback text for validation or status.
         */
        "message"?: string;
        /**
          * A non-negative integer specifying the minimum number of characters required for the textarea's value to be considered valid.
         */
        "minLength"?: number;
        /**
          * The name of the textarea, used when submitting the form data.
         */
        "name"?: string;
        /**
          * Emitted when the textarea has lost focus.
         */
        "onBlur"?: (event: PTextareaCustomEvent<TextareaBlurEventDetail>) => void;
        /**
          * Emitted when the textarea loses focus after its value was changed.
         */
        "onChange"?: (event: PTextareaCustomEvent<TextareaChangeEventDetail>) => void;
        /**
          * Emitted when the value has been changed as a direct result of a user action.
         */
        "onInput"?: (event: PTextareaCustomEvent<TextareaInputEventDetail>) => void;
        /**
          * A string that provides a brief hint to the user about what kind of information is expected in the field (e.g., placeholder='Write your message here...'). This text is displayed when the textarea is empty.
         */
        "placeholder"?: string;
        /**
          * A boolean value that, if present, makes the textarea uneditable by the user, but its value will still be submitted with the form.
         */
        "readOnly"?: boolean;
        /**
          * A boolean value that, if present, indicates that the textarea must be filled out before the form can be submitted.
         */
        "required"?: boolean;
        /**
          * Controls whether the textarea is resizable and in which direction.
         */
        "resize"?: TextareaResize;
        /**
          * The number of rows. Has no effect when field-sizing CSS Variable '--p-textarea-field-sizing' is set to 'content'.
         */
        "rows"?: number;
        /**
          * Specifies whether the textarea should have its spelling and grammar checked
         */
        "spellCheck"?: boolean;
        /**
          * Indicates the validation or overall status of the textarea component.
         */
        "state"?: TextareaState;
        /**
          * The textarea value.
         */
        "value"?: string;
        /**
          * Handles wrapping behavior of elements.
         */
        "wrap"?: TextareaWrap;
    }
    interface PToast {
    }
    interface PToastItem {
        /**
          * Emitted when the close button is clicked.
         */
        "onDismiss"?: (event: PToastItemCustomEvent<void>) => void;
        /**
          * State of the toast-item.
         */
        "state"?: ToastState;
        /**
          * Text of the toast-item.
         */
        "text"?: string;
    }
    interface PWordmark {
        /**
          * Add ARIA attributes.
         */
        "aria"?: SelectedAriaAttributes<WordmarkAriaAttribute>;
        /**
          * When providing an url then the component will be rendered as `<a>`.
         */
        "href"?: string;
        /**
          * Adapts sizing of wordmark.
         */
        "size"?: WordmarkSize;
        /**
          * Target attribute where the link should be opened.
         */
        "target"?: WordmarkTarget;
    }
    interface IntrinsicElements {
        "p-accordion": PAccordion;
        "p-banner": PBanner;
        "p-button": PButton;
        "p-button-pure": PButtonPure;
        "p-button-tile": PButtonTile;
        "p-canvas": PCanvas;
        "p-carousel": PCarousel;
        "p-checkbox": PCheckbox;
        "p-crest": PCrest;
        "p-display": PDisplay;
        "p-divider": PDivider;
        "p-drilldown": PDrilldown;
        "p-drilldown-item": PDrilldownItem;
        "p-drilldown-link": PDrilldownLink;
        "p-fieldset": PFieldset;
        "p-flag": PFlag;
        "p-flyout": PFlyout;
        "p-heading": PHeading;
        "p-icon": PIcon;
        "p-inline-notification": PInlineNotification;
        "p-input-date": PInputDate;
        "p-input-email": PInputEmail;
        "p-input-month": PInputMonth;
        "p-input-number": PInputNumber;
        "p-input-password": PInputPassword;
        "p-input-search": PInputSearch;
        "p-input-tel": PInputTel;
        "p-input-text": PInputText;
        "p-input-time": PInputTime;
        "p-input-url": PInputUrl;
        "p-input-week": PInputWeek;
        "p-link": PLink;
        "p-link-pure": PLinkPure;
        "p-link-tile": PLinkTile;
        "p-link-tile-product": PLinkTileProduct;
        "p-modal": PModal;
        "p-model-signature": PModelSignature;
        "p-multi-select": PMultiSelect;
        "p-multi-select-option": PMultiSelectOption;
        "p-optgroup": POptgroup;
        "p-pagination": PPagination;
        "p-pin-code": PPinCode;
        "p-popover": PPopover;
        "p-radio-group": PRadioGroup;
        "p-radio-group-option": PRadioGroupOption;
        "p-scroller": PScroller;
        "p-segmented-control": PSegmentedControl;
        "p-segmented-control-item": PSegmentedControlItem;
        "p-select": PSelect;
        "p-select-option": PSelectOption;
        "p-sheet": PSheet;
        "p-spinner": PSpinner;
        "p-stepper-horizontal": PStepperHorizontal;
        "p-stepper-horizontal-item": PStepperHorizontalItem;
        "p-switch": PSwitch;
        "p-table": PTable;
        "p-table-body": PTableBody;
        "p-table-cell": PTableCell;
        "p-table-head": PTableHead;
        "p-table-head-cell": PTableHeadCell;
        "p-table-head-row": PTableHeadRow;
        "p-table-row": PTableRow;
        "p-tabs": PTabs;
        "p-tabs-bar": PTabsBar;
        "p-tabs-item": PTabsItem;
        "p-tag": PTag;
        "p-tag-dismissible": PTagDismissible;
        "p-text": PText;
        "p-text-list": PTextList;
        "p-text-list-item": PTextListItem;
        "p-textarea": PTextarea;
        "p-toast": PToast;
        "p-toast-item": PToastItem;
        "p-wordmark": PWordmark;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            /**
             * @controlled {"props": ["open"], "event": "update"}
             */
            "p-accordion": LocalJSX.PAccordion & JSXBase.HTMLAttributes<HTMLPAccordionElement>;
            /**
             * @controlled {"props": ["open"], "event": "dismiss"}
             */
            "p-banner": LocalJSX.PBanner & JSXBase.HTMLAttributes<HTMLPBannerElement>;
            "p-button": LocalJSX.PButton & JSXBase.HTMLAttributes<HTMLPButtonElement>;
            "p-button-pure": LocalJSX.PButtonPure & JSXBase.HTMLAttributes<HTMLPButtonPureElement>;
            "p-button-tile": LocalJSX.PButtonTile & JSXBase.HTMLAttributes<HTMLPButtonTileElement>;
            /**
             * @experimental 
             */
            "p-canvas": LocalJSX.PCanvas & JSXBase.HTMLAttributes<HTMLPCanvasElement>;
            /**
             * @controlled { "props": ["activeSlideIndex"], "event": "update", "isInternallyMutated": true }
             */
            "p-carousel": LocalJSX.PCarousel & JSXBase.HTMLAttributes<HTMLPCarouselElement>;
            "p-checkbox": LocalJSX.PCheckbox & JSXBase.HTMLAttributes<HTMLPCheckboxElement>;
            "p-crest": LocalJSX.PCrest & JSXBase.HTMLAttributes<HTMLPCrestElement>;
            "p-display": LocalJSX.PDisplay & JSXBase.HTMLAttributes<HTMLPDisplayElement>;
            "p-divider": LocalJSX.PDivider & JSXBase.HTMLAttributes<HTMLPDividerElement>;
            /**
             * @controlled {"props": ["open"], "event": "dismiss"}
             * @controlled {"props": ["activeIdentifier"], "event": "update"}
             * @experimental 
             */
            "p-drilldown": LocalJSX.PDrilldown & JSXBase.HTMLAttributes<HTMLPDrilldownElement>;
            /**
             * @experimental 
             */
            "p-drilldown-item": LocalJSX.PDrilldownItem & JSXBase.HTMLAttributes<HTMLPDrilldownItemElement>;
            /**
             * @experimental 
             */
            "p-drilldown-link": LocalJSX.PDrilldownLink & JSXBase.HTMLAttributes<HTMLPDrilldownLinkElement>;
            "p-fieldset": LocalJSX.PFieldset & JSXBase.HTMLAttributes<HTMLPFieldsetElement>;
            "p-flag": LocalJSX.PFlag & JSXBase.HTMLAttributes<HTMLPFlagElement>;
            /**
             * @controlled {"props": ["open"], "event": "dismiss"}
             */
            "p-flyout": LocalJSX.PFlyout & JSXBase.HTMLAttributes<HTMLPFlyoutElement>;
            "p-heading": LocalJSX.PHeading & JSXBase.HTMLAttributes<HTMLPHeadingElement>;
            "p-icon": LocalJSX.PIcon & JSXBase.HTMLAttributes<HTMLPIconElement>;
            "p-inline-notification": LocalJSX.PInlineNotification & JSXBase.HTMLAttributes<HTMLPInlineNotificationElement>;
            "p-input-date": LocalJSX.PInputDate & JSXBase.HTMLAttributes<HTMLPInputDateElement>;
            "p-input-email": LocalJSX.PInputEmail & JSXBase.HTMLAttributes<HTMLPInputEmailElement>;
            "p-input-month": LocalJSX.PInputMonth & JSXBase.HTMLAttributes<HTMLPInputMonthElement>;
            "p-input-number": LocalJSX.PInputNumber & JSXBase.HTMLAttributes<HTMLPInputNumberElement>;
            "p-input-password": LocalJSX.PInputPassword & JSXBase.HTMLAttributes<HTMLPInputPasswordElement>;
            "p-input-search": LocalJSX.PInputSearch & JSXBase.HTMLAttributes<HTMLPInputSearchElement>;
            "p-input-tel": LocalJSX.PInputTel & JSXBase.HTMLAttributes<HTMLPInputTelElement>;
            "p-input-text": LocalJSX.PInputText & JSXBase.HTMLAttributes<HTMLPInputTextElement>;
            "p-input-time": LocalJSX.PInputTime & JSXBase.HTMLAttributes<HTMLPInputTimeElement>;
            "p-input-url": LocalJSX.PInputUrl & JSXBase.HTMLAttributes<HTMLPInputUrlElement>;
            "p-input-week": LocalJSX.PInputWeek & JSXBase.HTMLAttributes<HTMLPInputWeekElement>;
            "p-link": LocalJSX.PLink & JSXBase.HTMLAttributes<HTMLPLinkElement>;
            "p-link-pure": LocalJSX.PLinkPure & JSXBase.HTMLAttributes<HTMLPLinkPureElement>;
            "p-link-tile": LocalJSX.PLinkTile & JSXBase.HTMLAttributes<HTMLPLinkTileElement>;
            /**
             * @controlled {"props": ["liked"], "event": "like"}
             * @experimental 
             */
            "p-link-tile-product": LocalJSX.PLinkTileProduct & JSXBase.HTMLAttributes<HTMLPLinkTileProductElement>;
            /**
             * @controlled {"props": ["open"], "event": "dismiss"}
             */
            "p-modal": LocalJSX.PModal & JSXBase.HTMLAttributes<HTMLPModalElement>;
            "p-model-signature": LocalJSX.PModelSignature & JSXBase.HTMLAttributes<HTMLPModelSignatureElement>;
            /**
             * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
             */
            "p-multi-select": LocalJSX.PMultiSelect & JSXBase.HTMLAttributes<HTMLPMultiSelectElement>;
            "p-multi-select-option": LocalJSX.PMultiSelectOption & JSXBase.HTMLAttributes<HTMLPMultiSelectOptionElement>;
            "p-optgroup": LocalJSX.POptgroup & JSXBase.HTMLAttributes<HTMLPOptgroupElement>;
            /**
             * @controlled { "props": ["activePage"], "event": "update", "isInternallyMutated": true }
             */
            "p-pagination": LocalJSX.PPagination & JSXBase.HTMLAttributes<HTMLPPaginationElement>;
            /**
             * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
             */
            "p-pin-code": LocalJSX.PPinCode & JSXBase.HTMLAttributes<HTMLPPinCodeElement>;
            "p-popover": LocalJSX.PPopover & JSXBase.HTMLAttributes<HTMLPPopoverElement>;
            "p-radio-group": LocalJSX.PRadioGroup & JSXBase.HTMLAttributes<HTMLPRadioGroupElement>;
            "p-radio-group-option": LocalJSX.PRadioGroupOption & JSXBase.HTMLAttributes<HTMLPRadioGroupOptionElement>;
            "p-scroller": LocalJSX.PScroller & JSXBase.HTMLAttributes<HTMLPScrollerElement>;
            /**
             * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
             */
            "p-segmented-control": LocalJSX.PSegmentedControl & JSXBase.HTMLAttributes<HTMLPSegmentedControlElement>;
            "p-segmented-control-item": LocalJSX.PSegmentedControlItem & JSXBase.HTMLAttributes<HTMLPSegmentedControlItemElement>;
            /**
             * @controlled { "props": ["value"], "event": "change", "isInternallyMutated": true }
             */
            "p-select": LocalJSX.PSelect & JSXBase.HTMLAttributes<HTMLPSelectElement>;
            "p-select-option": LocalJSX.PSelectOption & JSXBase.HTMLAttributes<HTMLPSelectOptionElement>;
            /**
             * @controlled {"props": ["open"], "event": "dismiss"}
             */
            "p-sheet": LocalJSX.PSheet & JSXBase.HTMLAttributes<HTMLPSheetElement>;
            "p-spinner": LocalJSX.PSpinner & JSXBase.HTMLAttributes<HTMLPSpinnerElement>;
            "p-stepper-horizontal": LocalJSX.PStepperHorizontal & JSXBase.HTMLAttributes<HTMLPStepperHorizontalElement>;
            "p-stepper-horizontal-item": LocalJSX.PStepperHorizontalItem & JSXBase.HTMLAttributes<HTMLPStepperHorizontalItemElement>;
            /**
             * @controlled {"props": ["checked"], "event": "update"}
             */
            "p-switch": LocalJSX.PSwitch & JSXBase.HTMLAttributes<HTMLPSwitchElement>;
            "p-table": LocalJSX.PTable & JSXBase.HTMLAttributes<HTMLPTableElement>;
            "p-table-body": LocalJSX.PTableBody & JSXBase.HTMLAttributes<HTMLPTableBodyElement>;
            "p-table-cell": LocalJSX.PTableCell & JSXBase.HTMLAttributes<HTMLPTableCellElement>;
            "p-table-head": LocalJSX.PTableHead & JSXBase.HTMLAttributes<HTMLPTableHeadElement>;
            "p-table-head-cell": LocalJSX.PTableHeadCell & JSXBase.HTMLAttributes<HTMLPTableHeadCellElement>;
            "p-table-head-row": LocalJSX.PTableHeadRow & JSXBase.HTMLAttributes<HTMLPTableHeadRowElement>;
            "p-table-row": LocalJSX.PTableRow & JSXBase.HTMLAttributes<HTMLPTableRowElement>;
            /**
             * @controlled { "props": ["activeTabIndex"], "event": "update", "isInternallyMutated": true }
             */
            "p-tabs": LocalJSX.PTabs & JSXBase.HTMLAttributes<HTMLPTabsElement>;
            /**
             * @controlled {"props": ["activeTabIndex"], "event": "update"}
             */
            "p-tabs-bar": LocalJSX.PTabsBar & JSXBase.HTMLAttributes<HTMLPTabsBarElement>;
            "p-tabs-item": LocalJSX.PTabsItem & JSXBase.HTMLAttributes<HTMLPTabsItemElement>;
            "p-tag": LocalJSX.PTag & JSXBase.HTMLAttributes<HTMLPTagElement>;
            "p-tag-dismissible": LocalJSX.PTagDismissible & JSXBase.HTMLAttributes<HTMLPTagDismissibleElement>;
            "p-text": LocalJSX.PText & JSXBase.HTMLAttributes<HTMLPTextElement>;
            "p-text-list": LocalJSX.PTextList & JSXBase.HTMLAttributes<HTMLPTextListElement>;
            "p-text-list-item": LocalJSX.PTextListItem & JSXBase.HTMLAttributes<HTMLPTextListItemElement>;
            "p-textarea": LocalJSX.PTextarea & JSXBase.HTMLAttributes<HTMLPTextareaElement>;
            "p-toast": LocalJSX.PToast & JSXBase.HTMLAttributes<HTMLPToastElement>;
            "p-toast-item": LocalJSX.PToastItem & JSXBase.HTMLAttributes<HTMLPToastItemElement>;
            "p-wordmark": LocalJSX.PWordmark & JSXBase.HTMLAttributes<HTMLPWordmarkElement>;
        }
    }
}
