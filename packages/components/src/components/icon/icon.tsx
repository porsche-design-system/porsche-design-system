import { Component, Element, h, Prop } from '@stencil/core';
import { buildIconUrl, getSvgContent, ICON_ARIA_ATTRIBUTES, patchAriaIntoSVG } from './icon-utils';
import type { IconAriaAttributes } from './icon-utils';
import {
  AllowedTypes,
  attachComponentCss,
  getShadowRootHTMLElement,
  ICON_SIZES,
  isBrowser,
  TEXT_COLORS,
  THEMES_EXTENDED_ELECTRIC_DARK,
  validateProps,
} from '../../utils';
import type {
  IconName,
  IconSize,
  PropTypes,
  SelectedAriaAttributes,
  TextColor,
  ThemeExtendedElectricDark,
} from '../../types';
import { getComponentCss } from './icon-styles';

const propTypes: PropTypes<typeof Icon> = {
  name: AllowedTypes.string,
  source: AllowedTypes.string,
  color: AllowedTypes.oneOf<TextColor>(TEXT_COLORS),
  size: AllowedTypes.oneOf<IconSize>(ICON_SIZES),
  lazy: AllowedTypes.boolean,
  theme: AllowedTypes.oneOf<ThemeExtendedElectricDark>(THEMES_EXTENDED_ELECTRIC_DARK),
  aria: AllowedTypes.aria<IconAriaAttributes>(ICON_ARIA_ATTRIBUTES),
};

@Component({
  tag: 'p-icon',
  shadow: true,
})
export class Icon {
  @Element() public host!: HTMLElement;

  /** Specifies which icon to use. */
  @Prop() public name?: IconName = 'arrow-head-right'; // We have to assign defaults as string for correct visualization in stencils autogenerated readme

  /** Specifies a whole icon path which can be used for custom icons. */
  @Prop() public source?: string;

  /** Basic color variations depending on theme property. */
  @Prop() public color?: TextColor = 'default';

  /** The size of the icon. */
  @Prop() public size?: IconSize = 'small';

  /** If enabled, icon will be loaded lazily when it's visible in the viewport. */
  @Prop() public lazy?: boolean = false;

  /** Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop. */
  @Prop() public theme?: ThemeExtendedElectricDark = 'light';

  /** Add ARIA attributes. */
  @Prop() public aria?: SelectedAriaAttributes<IconAriaAttributes>;

  private intersectionObserver?: IntersectionObserver;
  private key = 0; // use unique random key to trick stencil cache
  private svgContent = '';

  public componentWillLoad(): void {
    this.initIntersectionObserver();
  }

  public componentWillRender(): void {
    validateProps(this, propTypes);
    attachComponentCss(this.host, getComponentCss, this.color, this.size, this.theme);
  }

  public componentWillUpdate(): void {
    // reset old icon if there is any
    if (this.svgContent) {
      this.setIconContent('');
    }
    this.initIntersectionObserver();
  }

  public componentDidRender(): void {
    // if icon was fetched before component was rendered
    this.setIconContent(this.svgContent);
  }

  public disconnectedCallback(): void {
    this.intersectionObserver?.disconnect();
  }

  public render(): JSX.Element {
    return <i key={this.key++} class="root" />;
  }

  private initIntersectionObserver(): void {
    if (this.lazy && isBrowser()) {
      // load icon once it reaches the viewport
      if (!this.intersectionObserver) {
        this.intersectionObserver = new IntersectionObserver(
          (entries, observer) => {
            if (entries[0].isIntersecting) {
              // is in viewport
              observer.unobserve(this.host);
              this.loadIcon();
            }
          },
          { rootMargin: '50px' }
        );
      }
      this.intersectionObserver.observe(this.host);
    } else {
      this.loadIcon();
    }
  }

  private loadIcon(): void {
    const url = buildIconUrl(this.source || this.name);

    getSvgContent(url).then((iconContent) => {
      // check if response matches current icon source
      if (url === buildIconUrl(this.source || this.name)) {
        this.setIconContent(iconContent);
      }
    });
  }

  private setIconContent(content: string): void {
    this.svgContent = content;
    const el = getShadowRootHTMLElement(this.host, 'i');
    // manipulating the DOM directly, to prevent unnecessary stencil lifecycles
    if (el) {
      el.innerHTML = patchAriaIntoSVG(content, this.aria);
    }
  }
}
