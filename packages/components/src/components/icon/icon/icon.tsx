import { Component, Element, h, Host, Prop, State } from '@stencil/core';
import { buildIconUrl, getSvgContent } from './icon-utils';
import { getShadowRootHTMLElement, isBrowser, isDark } from '../../../utils';
import type { Theme, IconName, TextColor } from '../../../types';

@Component({
  tag: 'p-icon',
  styleUrl: 'icon.scss',
  shadow: true,
})
export class Icon {
  @Element() public host!: HTMLElement;

  /** Specifies which icon to use. */
  @Prop() public name?: IconName = 'arrow-head-right'; // We have to assign defaults as string for correct visualization in stencils autogenerated readme

  /** Specifies a whole icon path which can be used for custom icons. */
  @Prop() public source?: string;

  /** @internal Specifies which icon variant to use. */
  @Prop() public variant?: 'outline' | 'filled' = 'outline';

  /** Basic color variations depending on theme property. */
  @Prop() public color?: TextColor = 'default';

  /** The size of the icon. */
  @Prop() public size?: 'small' | 'medium' | 'large' | 'inherit' = 'small';

  /** If enabled, ion-icon will be loaded lazily when it's visible in the viewport. Default, `false`. */
  @Prop() public lazy?: boolean = false;

  /** Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop. */
  @Prop() public theme?: Theme = 'light';

  @State() private svgContent?: string;

  private intersectionObserver?: IntersectionObserver;
  private key = 0; // use unique random key to trick stencil cache

  public componentWillLoad(): void {
    this.initIntersectionObserver();
  }

  public componentWillUpdate(): void {
    this.initIntersectionObserver();
  }

  public disconnectedCallback(): void {
    this.intersectionObserver?.disconnect();
  }

  public render(): JSX.Element {
    const rootClasses = {
      ['root']: true,
      [`root--size-${this.size}`]: this.size !== 'small',
      [`root--color-${this.color}`]: this.color !== 'default',
      ['root--theme-dark']: isDark(this.theme) && this.color !== 'inherit',
    };

    return (
      <Host>
        <i key={this.key++} class={rootClasses} />
      </Host>
    );
  }

  private initIntersectionObserver(): void {
    if (this.lazy && isBrowser()) {
      // load icon once it reaches the viewport
      if (!this.intersectionObserver) {
        this.intersectionObserver = new IntersectionObserver(
          (entries, observer) => {
            if (entries[0].isIntersecting) {
              // is in viewport
              observer.unobserve(this.host);
              this.loadIcon();
            }
          },
          { rootMargin: '50px' }
        );
      }
      this.intersectionObserver.observe(this.host);
    } else {
      this.loadIcon();
    }
  }

  private loadIcon(): void {
    if (this.svgContent) {
      // reset old icon if there is any
      this.setIconContent('');
    }

    const url = buildIconUrl(this.source ?? this.name);

    getSvgContent(url).then((iconContent) => {
      // check if response matches current icon source
      if (url === buildIconUrl(this.source ?? this.name)) {
        this.setIconContent(iconContent);
        this.svgContent = iconContent;
      }
    });
  }

  private setIconContent(content: string): void {
    const el = getShadowRootHTMLElement(this.host, 'i');
    // manipulating the DOM directly, to prevent unnecessary stencil lifecycles
    if (el) {
      el.innerHTML = content;
    }
  }
}
