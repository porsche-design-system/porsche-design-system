import { Component, Element, h, Prop } from '@stencil/core';
import { buildIconUrl, getSvgContent, patchAriaIntoSVG, IconAriaAttributes } from './icon-utils';
import { attachComponentCss, getShadowRootHTMLElement, isBrowser } from '../../../utils';
import type { Theme, IconName, TextColor, IconSize, SelectedAriaAttributes } from '../../../types';
import { getComponentCss } from './icon-styles';

@Component({
  tag: 'p-icon',
  shadow: true,
})
export class Icon {
  @Element() public host!: HTMLElement;

  /** Specifies which icon to use. */
  @Prop() public name?: IconName = 'arrow-head-right'; // We have to assign defaults as string for correct visualization in stencils autogenerated readme

  /** Specifies a whole icon path which can be used for custom icons. */
  @Prop() public source?: string;

  /** Basic color variations depending on theme property. */
  @Prop() public color?: TextColor = 'default';

  /** The size of the icon. */
  @Prop() public size?: IconSize = 'small';

  /** If enabled, icon will be loaded lazily when it's visible in the viewport. */
  @Prop() public lazy?: boolean = false;

  /** Adapts the text color depending on the theme. Has no effect when "inherit" is set as color prop. */
  @Prop() public theme?: Exclude<Theme, 'light-electric'> = 'light';

  /** Add ARIA attributes. */
  @Prop() public aria?: SelectedAriaAttributes<IconAriaAttributes>;

  private intersectionObserver?: IntersectionObserver;
  private key = 0; // use unique random key to trick stencil cache
  private svgContent = '';

  public componentWillLoad(): void {
    this.initIntersectionObserver();
  }

  public componentWillRender(): void {
    attachComponentCss(this.host, getComponentCss, this.color, this.size, this.theme);
  }

  public componentWillUpdate(): void {
    // reset old icon if there is any
    if (this.svgContent) {
      this.setIconContent('');
    }
    this.initIntersectionObserver();
  }

  public componentDidRender(): void {
    // if icon was fetched before component was rendered
    this.setIconContent(this.svgContent);
  }

  public disconnectedCallback(): void {
    this.intersectionObserver?.disconnect();
  }

  public render(): JSX.Element {
    return <i key={this.key++} class="root" />;
  }

  private initIntersectionObserver(): void {
    if (this.lazy && isBrowser()) {
      // load icon once it reaches the viewport
      if (!this.intersectionObserver) {
        this.intersectionObserver = new IntersectionObserver(
          (entries, observer) => {
            if (entries[0].isIntersecting) {
              // is in viewport
              observer.unobserve(this.host);
              this.loadIcon();
            }
          },
          { rootMargin: '50px' }
        );
      }
      this.intersectionObserver.observe(this.host);
    } else {
      this.loadIcon();
    }
  }

  private loadIcon(): void {
    const url = buildIconUrl(this.source ?? this.name);

    getSvgContent(url).then((iconContent) => {
      // check if response matches current icon source
      if (url === buildIconUrl(this.source ?? this.name)) {
        this.setIconContent(iconContent);
      }
    });
  }

  private setIconContent(content: string): void {
    this.svgContent = content;
    const el = getShadowRootHTMLElement(this.host, 'i');
    // manipulating the DOM directly, to prevent unnecessary stencil lifecycles
    if (el) {
      el.innerHTML = patchAriaIntoSVG(content, this.aria);
    }
  }
}
