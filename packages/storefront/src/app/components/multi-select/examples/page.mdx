import { ComponentStatus } from '@/components/components/ComponentStatus';
import { TableOfContents } from '@/components/common/TableOfContents';
import { Configurator } from '@/components/playground/Configurator';
import { multiSelectStory, multiSelectStoryOptgroup } from '@/app/components/multi-select/multi-select.stories';
import { Notification } from '@/components/common/Notification';
import { ComponentExample } from '@/components/playground/ComponentExample';
import {
  multiSelectExampleForm,
  multiSelectExampleDynamic,
  multiSelectExampleAsyncFilter,
  multiSelectExampleSelectedSlot,
} from '@porsche-design-system/shared/examples';
import { ComponentStory } from '@/components/playground/ComponentStory';

export const metadata = {
  title: 'Multi Select - Porsche Design System',
  description: 'Discover detailed examples and insights of the Multi Select component.',
};

# Multi Select <ComponentStatus tagName="p-multi-select"></ComponentStatus>

<TableOfContents
  headings={['Form', 'Set Value', 'With optgroups', 'Custom asynchronous filtering', 'Custom option rendering']}
/>

## Form

The `p-multi-select` can be integrated into a form in two ways: **controlled** or **uncontrolled**, depending on your
needs.

In the **controlled** approach, the select state is externally managed using the `value` property and `change` event to
keep it in sync with your application logic. This approach is ideal for complex forms or when using a form library. Note
that the component will still always update its internal value automatically when interacted with.

In the **uncontrolled** approach, the select behaves similar to a native `<select multiple>`, automatically managing its
own state and including its value in form submissions through the
[ElementInternals](https://developer.mozilla.org/en-US/docs/Web/API/ElementInternals) API. This is convenient for
smaller forms or simple submissions.

<Notification heading="Attention" heading-tag="h2" state="warning">
  <code>p-multi-select</code> does not use a native select internally. As a result, it lacks access to native{' '}
  <code>ValidityState</code>
  properties and <code>validationMessage</code>, and it cannot display the native validation popover. This means
  validation behavior and error display will need to be implemented separately if required.
</Notification>

For more details on form integration, refer to the `Form` section in the
[developing documentation](/developing/introduction) for your framework of choice, or find a full form integration
example in our [examples repository](https://github.com/porsche-design-system/examples/tree/v3/frameworks).

<ComponentExample codeSample={multiSelectExampleForm} />

## Set Value

The `p-multi-select` component behaves like regular form elements. It updates its value automatically based on user
choices, but can also be changed manually by using the value property. This property takes an array of strings that
represent the selected option values.

<ComponentExample codeSample={multiSelectExampleDynamic} />

## With optgroups

<ComponentStory story={multiSelectStoryOptgroup} />

## Custom asynchronous filtering

The `p-multi-select` component automatically filters options based on user input. However, if you have a large dataset
or need custom filtering logic (for example, server-side filtering), you can override this behavior using the `filter`
slot.

To do so, place a `p-input-search` inside the `filter` slot and bind it as shown in the example. Handle user input and
option fetching manually to control filtering behavior. Be sure to include custom loading, no results, and error states,
as these are not provided automatically when using the controlled filtering approach.

<ComponentExample codeSample={multiSelectExampleAsyncFilter} />

## Custom option rendering

By default, `p-multi-select-option` only allows `#text` nodes. To customize option rendering further, implement a custom
selection renderer using the `selected` slot. This allows you to render different content in the selected area versus
the dropdown options, enabling more complex option layouts.

The default filter behavior filters against all `textContent` within the options. For more granular control over
filtering, implement custom filtering logic as shown in the
[previous example](/components/multi-select/examples#custom-asynchronous-filtering).

<ComponentExample codeSample={multiSelectExampleSelectedSlot} />
